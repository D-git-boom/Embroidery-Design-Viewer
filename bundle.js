!function t(e, r, i) {
    function n(a, s) {
        if (!r[a]) {
            if (!e[a]) {
                var h = "function" == typeof require && require;
                if (!s && h)
                    return h(a, !0);
                if (o)
                    return o(a, !0);
                var c = new Error("Cannot find module '" + a + "'");
                throw c.code = "MODULE_NOT_FOUND",
                c
            }
            var l = r[a] = {
                exports: {}
            };
            e[a][0].call(l.exports, function(t) {
                var r = e[a][1][t];
                return n(r ? r : t)
            }, l, l.exports, t, e, r, i)
        }
        return r[a].exports
    }
    for (var o = "function" == typeof require && require, a = 0; a < i.length; a++)
        n(i[a]);
    return n
}({
    1: [function(t, e, r) {
        "use strict";
        function i() {
            for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0, r = t.length; e < r; ++e)
                h[e] = t[e],
                c[t.charCodeAt(e)] = e;
            c["-".charCodeAt(0)] = 62,
            c["_".charCodeAt(0)] = 63
        }
        function n(t) {
            var e, r, i, n, o, a, s = t.length;
            if (s % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4");
            o = "=" === t[s - 2] ? 2 : "=" === t[s - 1] ? 1 : 0,
            a = new l(3 * s / 4 - o),
            i = o > 0 ? s - 4 : s;
            var h = 0;
            for (e = 0,
            r = 0; e < i; e += 4,
            r += 3)
                n = c[t.charCodeAt(e)] << 18 | c[t.charCodeAt(e + 1)] << 12 | c[t.charCodeAt(e + 2)] << 6 | c[t.charCodeAt(e + 3)],
                a[h++] = n >> 16 & 255,
                a[h++] = n >> 8 & 255,
                a[h++] = 255 & n;
            return 2 === o ? (n = c[t.charCodeAt(e)] << 2 | c[t.charCodeAt(e + 1)] >> 4,
            a[h++] = 255 & n) : 1 === o && (n = c[t.charCodeAt(e)] << 10 | c[t.charCodeAt(e + 1)] << 4 | c[t.charCodeAt(e + 2)] >> 2,
            a[h++] = n >> 8 & 255,
            a[h++] = 255 & n),
            a
        }
        function o(t) {
            return h[t >> 18 & 63] + h[t >> 12 & 63] + h[t >> 6 & 63] + h[63 & t]
        }
        function a(t, e, r) {
            for (var i, n = [], a = e; a < r; a += 3)
                i = (t[a] << 16) + (t[a + 1] << 8) + t[a + 2],
                n.push(o(i));
            return n.join("")
        }
        function s(t) {
            for (var e, r = t.length, i = r % 3, n = "", o = [], s = 16383, c = 0, l = r - i; c < l; c += s)
                o.push(a(t, c, c + s > l ? l : c + s));
            return 1 === i ? (e = t[r - 1],
            n += h[e >> 2],
            n += h[e << 4 & 63],
            n += "==") : 2 === i && (e = (t[r - 2] << 8) + t[r - 1],
            n += h[e >> 10],
            n += h[e >> 4 & 63],
            n += h[e << 2 & 63],
            n += "="),
            o.push(n),
            o.join("")
        }
        r.toByteArray = n,
        r.fromByteArray = s;
        var h = []
          , c = []
          , l = "undefined" != typeof Uint8Array ? Uint8Array : Array;
        i()
    }
    , {}],
    2: [function(t, e, r) {
        (function(e) {
            "use strict";
            function i() {
                try {
                    var t = new Uint8Array(1);
                    return t.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42
                        }
                    },
                    42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
                } catch (t) {
                    return !1
                }
            }
            function n() {
                return a.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
            }
            function o(t, e) {
                if (n() < e)
                    throw new RangeError("Invalid typed array length");
                return a.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e),
                t.__proto__ = a.prototype) : (null === t && (t = new a(e)),
                t.length = e),
                t
            }
            function a(t, e, r) {
                if (!(a.TYPED_ARRAY_SUPPORT || this instanceof a))
                    return new a(t,e,r);
                if ("number" == typeof t) {
                    if ("string" == typeof e)
                        throw new Error("If encoding is specified then the first argument must be a string");
                    return l(this, t)
                }
                return s(this, t, e, r)
            }
            function s(t, e, r, i) {
                if ("number" == typeof e)
                    throw new TypeError('"value" argument must not be a number');
                return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? d(t, e, r, i) : "string" == typeof e ? u(t, e, r) : f(t, e)
            }
            function h(t) {
                if ("number" != typeof t)
                    throw new TypeError('"size" argument must be a number');
                if (t < 0)
                    throw new RangeError('"size" argument must not be negative')
            }
            function c(t, e, r, i) {
                return h(e),
                e <= 0 ? o(t, e) : void 0 !== r ? "string" == typeof i ? o(t, e).fill(r, i) : o(t, e).fill(r) : o(t, e)
            }
            function l(t, e) {
                if (h(e),
                t = o(t, e < 0 ? 0 : 0 | m(e)),
                !a.TYPED_ARRAY_SUPPORT)
                    for (var r = 0; r < e; ++r)
                        t[r] = 0;
                return t
            }
            function u(t, e, r) {
                if ("string" == typeof r && "" !== r || (r = "utf8"),
                !a.isEncoding(r))
                    throw new TypeError('"encoding" must be a valid string encoding');
                var i = 0 | v(e, r);
                t = o(t, i);
                var n = t.write(e, r);
                return n !== i && (t = t.slice(0, n)),
                t
            }
            function p(t, e) {
                var r = e.length < 0 ? 0 : 0 | m(e.length);
                t = o(t, r);
                for (var i = 0; i < r; i += 1)
                    t[i] = 255 & e[i];
                return t
            }
            function d(t, e, r, i) {
                if (e.byteLength,
                r < 0 || e.byteLength < r)
                    throw new RangeError("'offset' is out of bounds");
                if (e.byteLength < r + (i || 0))
                    throw new RangeError("'length' is out of bounds");
                return e = void 0 === r && void 0 === i ? new Uint8Array(e) : void 0 === i ? new Uint8Array(e,r) : new Uint8Array(e,r,i),
                a.TYPED_ARRAY_SUPPORT ? (t = e,
                t.__proto__ = a.prototype) : t = p(t, e),
                t
            }
            function f(t, e) {
                if (a.isBuffer(e)) {
                    var r = 0 | m(e.length);
                    return t = o(t, r),
                    0 === t.length ? t : (e.copy(t, 0, 0, r),
                    t)
                }
                if (e) {
                    if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length"in e)
                        return "number" != typeof e.length || Q(e.length) ? o(t, 0) : p(t, e);
                    if ("Buffer" === e.type && $(e.data))
                        return p(t, e.data)
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
            }
            function m(t) {
                if (t >= n())
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n().toString(16) + " bytes");
                return 0 | t
            }
            function g(t) {
                return +t != t && (t = 0),
                a.alloc(+t)
            }
            function v(t, e) {
                if (a.isBuffer(t))
                    return t.length;
                if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer))
                    return t.byteLength;
                "string" != typeof t && (t = "" + t);
                var r = t.length;
                if (0 === r)
                    return 0;
                for (var i = !1; ; )
                    switch (e) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return r;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                        return W(t).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * r;
                    case "hex":
                        return r >>> 1;
                    case "base64":
                        return q(t).length;
                    default:
                        if (i)
                            return W(t).length;
                        e = ("" + e).toLowerCase(),
                        i = !0
                    }
            }
            function y(t, e, r) {
                var i = !1;
                if ((void 0 === e || e < 0) && (e = 0),
                e > this.length)
                    return "";
                if ((void 0 === r || r > this.length) && (r = this.length),
                r <= 0)
                    return "";
                if (r >>>= 0,
                e >>>= 0,
                r <= e)
                    return "";
                for (t || (t = "utf8"); ; )
                    switch (t) {
                    case "hex":
                        return I(this, e, r);
                    case "utf8":
                    case "utf-8":
                        return C(this, e, r);
                    case "ascii":
                        return P(this, e, r);
                    case "latin1":
                    case "binary":
                        return U(this, e, r);
                    case "base64":
                        return L(this, e, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return D(this, e, r);
                    default:
                        if (i)
                            throw new TypeError("Unknown encoding: " + t);
                        t = (t + "").toLowerCase(),
                        i = !0
                    }
            }
            function x(t, e, r) {
                var i = t[e];
                t[e] = t[r],
                t[r] = i
            }
            function b(t, e, r, i, n) {
                if (0 === t.length)
                    return -1;
                if ("string" == typeof r ? (i = r,
                r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648),
                r = +r,
                isNaN(r) && (r = n ? 0 : t.length - 1),
                r < 0 && (r = t.length + r),
                r >= t.length) {
                    if (n)
                        return -1;
                    r = t.length - 1
                } else if (r < 0) {
                    if (!n)
                        return -1;
                    r = 0
                }
                if ("string" == typeof e && (e = a.from(e, i)),
                a.isBuffer(e))
                    return 0 === e.length ? -1 : w(t, e, r, i, n);
                if ("number" == typeof e)
                    return e = 255 & e,
                    a.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? n ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : w(t, [e], r, i, n);
                throw new TypeError("val must be string, number or Buffer")
            }
            function w(t, e, r, i, n) {
                function o(t, e) {
                    return 1 === a ? t[e] : t.readUInt16BE(e * a)
                }
                var a = 1
                  , s = t.length
                  , h = e.length;
                if (void 0 !== i && (i = String(i).toLowerCase(),
                "ucs2" === i || "ucs-2" === i || "utf16le" === i || "utf-16le" === i)) {
                    if (t.length < 2 || e.length < 2)
                        return -1;
                    a = 2,
                    s /= 2,
                    h /= 2,
                    r /= 2
                }
                var c;
                if (n) {
                    var l = -1;
                    for (c = r; c < s; c++)
                        if (o(t, c) === o(e, l === -1 ? 0 : c - l)) {
                            if (l === -1 && (l = c),
                            c - l + 1 === h)
                                return l * a
                        } else
                            l !== -1 && (c -= c - l),
                            l = -1
                } else
                    for (r + h > s && (r = s - h),
                    c = r; c >= 0; c--) {
                        for (var u = !0, p = 0; p < h; p++)
                            if (o(t, c + p) !== o(e, p)) {
                                u = !1;
                                break
                            }
                        if (u)
                            return c
                    }
                return -1
            }
            function _(t, e, r, i) {
                r = Number(r) || 0;
                var n = t.length - r;
                i ? (i = Number(i),
                i > n && (i = n)) : i = n;
                var o = e.length;
                if (o % 2 !== 0)
                    throw new TypeError("Invalid hex string");
                i > o / 2 && (i = o / 2);
                for (var a = 0; a < i; ++a) {
                    var s = parseInt(e.substr(2 * a, 2), 16);
                    if (isNaN(s))
                        return a;
                    t[r + a] = s
                }
                return a
            }
            function M(t, e, r, i) {
                return Z(W(e, t.length - r), t, r, i)
            }
            function S(t, e, r, i) {
                return Z(X(e), t, r, i)
            }
            function E(t, e, r, i) {
                return S(t, e, r, i)
            }
            function T(t, e, r, i) {
                return Z(q(e), t, r, i)
            }
            function A(t, e, r, i) {
                return Z(Y(e, t.length - r), t, r, i)
            }
            function L(t, e, r) {
                return 0 === e && r === t.length ? J.fromByteArray(t) : J.fromByteArray(t.slice(e, r))
            }
            function C(t, e, r) {
                r = Math.min(t.length, r);
                for (var i = [], n = e; n < r; ) {
                    var o = t[n]
                      , a = null
                      , s = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
                    if (n + s <= r) {
                        var h, c, l, u;
                        switch (s) {
                        case 1:
                            o < 128 && (a = o);
                            break;
                        case 2:
                            h = t[n + 1],
                            128 === (192 & h) && (u = (31 & o) << 6 | 63 & h,
                            u > 127 && (a = u));
                            break;
                        case 3:
                            h = t[n + 1],
                            c = t[n + 2],
                            128 === (192 & h) && 128 === (192 & c) && (u = (15 & o) << 12 | (63 & h) << 6 | 63 & c,
                            u > 2047 && (u < 55296 || u > 57343) && (a = u));
                            break;
                        case 4:
                            h = t[n + 1],
                            c = t[n + 2],
                            l = t[n + 3],
                            128 === (192 & h) && 128 === (192 & c) && 128 === (192 & l) && (u = (15 & o) << 18 | (63 & h) << 12 | (63 & c) << 6 | 63 & l,
                            u > 65535 && u < 1114112 && (a = u))
                        }
                    }
                    null === a ? (a = 65533,
                    s = 1) : a > 65535 && (a -= 65536,
                    i.push(a >>> 10 & 1023 | 55296),
                    a = 56320 | 1023 & a),
                    i.push(a),
                    n += s
                }
                return R(i)
            }
            function R(t) {
                var e = t.length;
                if (e <= tt)
                    return String.fromCharCode.apply(String, t);
                for (var r = "", i = 0; i < e; )
                    r += String.fromCharCode.apply(String, t.slice(i, i += tt));
                return r
            }
            function P(t, e, r) {
                var i = "";
                r = Math.min(t.length, r);
                for (var n = e; n < r; ++n)
                    i += String.fromCharCode(127 & t[n]);
                return i
            }
            function U(t, e, r) {
                var i = "";
                r = Math.min(t.length, r);
                for (var n = e; n < r; ++n)
                    i += String.fromCharCode(t[n]);
                return i
            }
            function I(t, e, r) {
                var i = t.length;
                (!e || e < 0) && (e = 0),
                (!r || r < 0 || r > i) && (r = i);
                for (var n = "", o = e; o < r; ++o)
                    n += H(t[o]);
                return n
            }
            function D(t, e, r) {
                for (var i = t.slice(e, r), n = "", o = 0; o < i.length; o += 2)
                    n += String.fromCharCode(i[o] + 256 * i[o + 1]);
                return n
            }
            function O(t, e, r) {
                if (t % 1 !== 0 || t < 0)
                    throw new RangeError("offset is not uint");
                if (t + e > r)
                    throw new RangeError("Trying to access beyond buffer length")
            }
            function N(t, e, r, i, n, o) {
                if (!a.isBuffer(t))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                if (e > n || e < o)
                    throw new RangeError('"value" argument is out of bounds');
                if (r + i > t.length)
                    throw new RangeError("Index out of range")
            }
            function B(t, e, r, i) {
                e < 0 && (e = 65535 + e + 1);
                for (var n = 0, o = Math.min(t.length - r, 2); n < o; ++n)
                    t[r + n] = (e & 255 << 8 * (i ? n : 1 - n)) >>> 8 * (i ? n : 1 - n)
            }
            function F(t, e, r, i) {
                e < 0 && (e = 4294967295 + e + 1);
                for (var n = 0, o = Math.min(t.length - r, 4); n < o; ++n)
                    t[r + n] = e >>> 8 * (i ? n : 3 - n) & 255
            }
            function k(t, e, r, i, n, o) {
                if (r + i > t.length)
                    throw new RangeError("Index out of range");
                if (r < 0)
                    throw new RangeError("Index out of range")
            }
            function z(t, e, r, i, n) {
                return n || k(t, e, r, 4, 3.4028234663852886e38, -3.4028234663852886e38),
                K.write(t, e, r, i, 23, 4),
                r + 4
            }
            function V(t, e, r, i, n) {
                return n || k(t, e, r, 8, 1.7976931348623157e308, -1.7976931348623157e308),
                K.write(t, e, r, i, 52, 8),
                r + 8
            }
            function G(t) {
                if (t = j(t).replace(et, ""),
                t.length < 2)
                    return "";
                for (; t.length % 4 !== 0; )
                    t += "=";
                return t
            }
            function j(t) {
                return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
            }
            function H(t) {
                return t < 16 ? "0" + t.toString(16) : t.toString(16)
            }
            function W(t, e) {
                e = e || 1 / 0;
                for (var r, i = t.length, n = null, o = [], a = 0; a < i; ++a) {
                    if (r = t.charCodeAt(a),
                    r > 55295 && r < 57344) {
                        if (!n) {
                            if (r > 56319) {
                                (e -= 3) > -1 && o.push(239, 191, 189);
                                continue
                            }
                            if (a + 1 === i) {
                                (e -= 3) > -1 && o.push(239, 191, 189);
                                continue
                            }
                            n = r;
                            continue
                        }
                        if (r < 56320) {
                            (e -= 3) > -1 && o.push(239, 191, 189),
                            n = r;
                            continue
                        }
                        r = (n - 55296 << 10 | r - 56320) + 65536
                    } else
                        n && (e -= 3) > -1 && o.push(239, 191, 189);
                    if (n = null,
                    r < 128) {
                        if ((e -= 1) < 0)
                            break;
                        o.push(r)
                    } else if (r < 2048) {
                        if ((e -= 2) < 0)
                            break;
                        o.push(r >> 6 | 192, 63 & r | 128)
                    } else if (r < 65536) {
                        if ((e -= 3) < 0)
                            break;
                        o.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
                    } else {
                        if (!(r < 1114112))
                            throw new Error("Invalid code point");
                        if ((e -= 4) < 0)
                            break;
                        o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
                    }
                }
                return o
            }
            function X(t) {
                for (var e = [], r = 0; r < t.length; ++r)
                    e.push(255 & t.charCodeAt(r));
                return e
            }
            function Y(t, e) {
                for (var r, i, n, o = [], a = 0; a < t.length && !((e -= 2) < 0); ++a)
                    r = t.charCodeAt(a),
                    i = r >> 8,
                    n = r % 256,
                    o.push(n),
                    o.push(i);
                return o
            }
            function q(t) {
                return J.toByteArray(G(t))
            }
            function Z(t, e, r, i) {
                for (var n = 0; n < i && !(n + r >= e.length || n >= t.length); ++n)
                    e[n + r] = t[n];
                return n
            }
            function Q(t) {
                return t !== t
            }
            var J = t("base64-js")
              , K = t("ieee754")
              , $ = t("isarray");
            r.Buffer = a,
            r.SlowBuffer = g,
            r.INSPECT_MAX_BYTES = 50,
            a.TYPED_ARRAY_SUPPORT = void 0 !== e.TYPED_ARRAY_SUPPORT ? e.TYPED_ARRAY_SUPPORT : i(),
            r.kMaxLength = n(),
            a.poolSize = 8192,
            a._augment = function(t) {
                return t.__proto__ = a.prototype,
                t
            }
            ,
            a.from = function(t, e, r) {
                return s(null, t, e, r)
            }
            ,
            a.TYPED_ARRAY_SUPPORT && (a.prototype.__proto__ = Uint8Array.prototype,
            a.__proto__ = Uint8Array,
            "undefined" != typeof Symbol && Symbol.species && a[Symbol.species] === a && Object.defineProperty(a, Symbol.species, {
                value: null,
                configurable: !0
            })),
            a.alloc = function(t, e, r) {
                return c(null, t, e, r)
            }
            ,
            a.allocUnsafe = function(t) {
                return l(null, t)
            }
            ,
            a.allocUnsafeSlow = function(t) {
                return l(null, t)
            }
            ,
            a.isBuffer = function(t) {
                return !(null == t || !t._isBuffer)
            }
            ,
            a.compare = function(t, e) {
                if (!a.isBuffer(t) || !a.isBuffer(e))
                    throw new TypeError("Arguments must be Buffers");
                if (t === e)
                    return 0;
                for (var r = t.length, i = e.length, n = 0, o = Math.min(r, i); n < o; ++n)
                    if (t[n] !== e[n]) {
                        r = t[n],
                        i = e[n];
                        break
                    }
                return r < i ? -1 : i < r ? 1 : 0
            }
            ,
            a.isEncoding = function(t) {
                switch (String(t).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
                }
            }
            ,
            a.concat = function(t, e) {
                if (!$(t))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === t.length)
                    return a.alloc(0);
                var r;
                if (void 0 === e)
                    for (e = 0,
                    r = 0; r < t.length; ++r)
                        e += t[r].length;
                var i = a.allocUnsafe(e)
                  , n = 0;
                for (r = 0; r < t.length; ++r) {
                    var o = t[r];
                    if (!a.isBuffer(o))
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    o.copy(i, n),
                    n += o.length
                }
                return i
            }
            ,
            a.byteLength = v,
            a.prototype._isBuffer = !0,
            a.prototype.swap16 = function() {
                var t = this.length;
                if (t % 2 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (var e = 0; e < t; e += 2)
                    x(this, e, e + 1);
                return this
            }
            ,
            a.prototype.swap32 = function() {
                var t = this.length;
                if (t % 4 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (var e = 0; e < t; e += 4)
                    x(this, e, e + 3),
                    x(this, e + 1, e + 2);
                return this
            }
            ,
            a.prototype.swap64 = function() {
                var t = this.length;
                if (t % 8 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (var e = 0; e < t; e += 8)
                    x(this, e, e + 7),
                    x(this, e + 1, e + 6),
                    x(this, e + 2, e + 5),
                    x(this, e + 3, e + 4);
                return this
            }
            ,
            a.prototype.toString = function() {
                var t = 0 | this.length;
                return 0 === t ? "" : 0 === arguments.length ? C(this, 0, t) : y.apply(this, arguments)
            }
            ,
            a.prototype.equals = function(t) {
                if (!a.isBuffer(t))
                    throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === a.compare(this, t)
            }
            ,
            a.prototype.inspect = function() {
                var t = ""
                  , e = r.INSPECT_MAX_BYTES;
                return this.length > 0 && (t = this.toString("hex", 0, e).match(/.{2}/g).join(" "),
                this.length > e && (t += " ... ")),
                "<Buffer " + t + ">"
            }
            ,
            a.prototype.compare = function(t, e, r, i, n) {
                if (!a.isBuffer(t))
                    throw new TypeError("Argument must be a Buffer");
                if (void 0 === e && (e = 0),
                void 0 === r && (r = t ? t.length : 0),
                void 0 === i && (i = 0),
                void 0 === n && (n = this.length),
                e < 0 || r > t.length || i < 0 || n > this.length)
                    throw new RangeError("out of range index");
                if (i >= n && e >= r)
                    return 0;
                if (i >= n)
                    return -1;
                if (e >= r)
                    return 1;
                if (e >>>= 0,
                r >>>= 0,
                i >>>= 0,
                n >>>= 0,
                this === t)
                    return 0;
                for (var o = n - i, s = r - e, h = Math.min(o, s), c = this.slice(i, n), l = t.slice(e, r), u = 0; u < h; ++u)
                    if (c[u] !== l[u]) {
                        o = c[u],
                        s = l[u];
                        break
                    }
                return o < s ? -1 : s < o ? 1 : 0
            }
            ,
            a.prototype.includes = function(t, e, r) {
                return this.indexOf(t, e, r) !== -1
            }
            ,
            a.prototype.indexOf = function(t, e, r) {
                return b(this, t, e, r, !0)
            }
            ,
            a.prototype.lastIndexOf = function(t, e, r) {
                return b(this, t, e, r, !1)
            }
            ,
            a.prototype.write = function(t, e, r, i) {
                if (void 0 === e)
                    i = "utf8",
                    r = this.length,
                    e = 0;
                else if (void 0 === r && "string" == typeof e)
                    i = e,
                    r = this.length,
                    e = 0;
                else {
                    if (!isFinite(e))
                        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    e = 0 | e,
                    isFinite(r) ? (r = 0 | r,
                    void 0 === i && (i = "utf8")) : (i = r,
                    r = void 0)
                }
                var n = this.length - e;
                if ((void 0 === r || r > n) && (r = n),
                t.length > 0 && (r < 0 || e < 0) || e > this.length)
                    throw new RangeError("Attempt to write outside buffer bounds");
                i || (i = "utf8");
                for (var o = !1; ; )
                    switch (i) {
                    case "hex":
                        return _(this, t, e, r);
                    case "utf8":
                    case "utf-8":
                        return M(this, t, e, r);
                    case "ascii":
                        return S(this, t, e, r);
                    case "latin1":
                    case "binary":
                        return E(this, t, e, r);
                    case "base64":
                        return T(this, t, e, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return A(this, t, e, r);
                    default:
                        if (o)
                            throw new TypeError("Unknown encoding: " + i);
                        i = ("" + i).toLowerCase(),
                        o = !0
                    }
            }
            ,
            a.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }
            ;
            var tt = 4096;
            a.prototype.slice = function(t, e) {
                var r = this.length;
                t = ~~t,
                e = void 0 === e ? r : ~~e,
                t < 0 ? (t += r,
                t < 0 && (t = 0)) : t > r && (t = r),
                e < 0 ? (e += r,
                e < 0 && (e = 0)) : e > r && (e = r),
                e < t && (e = t);
                var i;
                if (a.TYPED_ARRAY_SUPPORT)
                    i = this.subarray(t, e),
                    i.__proto__ = a.prototype;
                else {
                    var n = e - t;
                    i = new a(n,(void 0));
                    for (var o = 0; o < n; ++o)
                        i[o] = this[o + t]
                }
                return i
            }
            ,
            a.prototype.readUIntLE = function(t, e, r) {
                t = 0 | t,
                e = 0 | e,
                r || O(t, e, this.length);
                for (var i = this[t], n = 1, o = 0; ++o < e && (n *= 256); )
                    i += this[t + o] * n;
                return i
            }
            ,
            a.prototype.readUIntBE = function(t, e, r) {
                t = 0 | t,
                e = 0 | e,
                r || O(t, e, this.length);
                for (var i = this[t + --e], n = 1; e > 0 && (n *= 256); )
                    i += this[t + --e] * n;
                return i
            }
            ,
            a.prototype.readUInt8 = function(t, e) {
                return e || O(t, 1, this.length),
                this[t]
            }
            ,
            a.prototype.readUInt16LE = function(t, e) {
                return e || O(t, 2, this.length),
                this[t] | this[t + 1] << 8
            }
            ,
            a.prototype.readUInt16BE = function(t, e) {
                return e || O(t, 2, this.length),
                this[t] << 8 | this[t + 1]
            }
            ,
            a.prototype.readUInt32LE = function(t, e) {
                return e || O(t, 4, this.length),
                (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
            }
            ,
            a.prototype.readUInt32BE = function(t, e) {
                return e || O(t, 4, this.length),
                16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
            }
            ,
            a.prototype.readIntLE = function(t, e, r) {
                t = 0 | t,
                e = 0 | e,
                r || O(t, e, this.length);
                for (var i = this[t], n = 1, o = 0; ++o < e && (n *= 256); )
                    i += this[t + o] * n;
                return n *= 128,
                i >= n && (i -= Math.pow(2, 8 * e)),
                i
            }
            ,
            a.prototype.readIntBE = function(t, e, r) {
                t = 0 | t,
                e = 0 | e,
                r || O(t, e, this.length);
                for (var i = e, n = 1, o = this[t + --i]; i > 0 && (n *= 256); )
                    o += this[t + --i] * n;
                return n *= 128,
                o >= n && (o -= Math.pow(2, 8 * e)),
                o
            }
            ,
            a.prototype.readInt8 = function(t, e) {
                return e || O(t, 1, this.length),
                128 & this[t] ? (255 - this[t] + 1) * -1 : this[t]
            }
            ,
            a.prototype.readInt16LE = function(t, e) {
                e || O(t, 2, this.length);
                var r = this[t] | this[t + 1] << 8;
                return 32768 & r ? 4294901760 | r : r
            }
            ,
            a.prototype.readInt16BE = function(t, e) {
                e || O(t, 2, this.length);
                var r = this[t + 1] | this[t] << 8;
                return 32768 & r ? 4294901760 | r : r
            }
            ,
            a.prototype.readInt32LE = function(t, e) {
                return e || O(t, 4, this.length),
                this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
            }
            ,
            a.prototype.readInt32BE = function(t, e) {
                return e || O(t, 4, this.length),
                this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
            }
            ,
            a.prototype.readFloatLE = function(t, e) {
                return e || O(t, 4, this.length),
                K.read(this, t, !0, 23, 4)
            }
            ,
            a.prototype.readFloatBE = function(t, e) {
                return e || O(t, 4, this.length),
                K.read(this, t, !1, 23, 4)
            }
            ,
            a.prototype.readDoubleLE = function(t, e) {
                return e || O(t, 8, this.length),
                K.read(this, t, !0, 52, 8)
            }
            ,
            a.prototype.readDoubleBE = function(t, e) {
                return e || O(t, 8, this.length),
                K.read(this, t, !1, 52, 8)
            }
            ,
            a.prototype.writeUIntLE = function(t, e, r, i) {
                if (t = +t,
                e = 0 | e,
                r = 0 | r,
                !i) {
                    var n = Math.pow(2, 8 * r) - 1;
                    N(this, t, e, r, n, 0)
                }
                var o = 1
                  , a = 0;
                for (this[e] = 255 & t; ++a < r && (o *= 256); )
                    this[e + a] = t / o & 255;
                return e + r
            }
            ,
            a.prototype.writeUIntBE = function(t, e, r, i) {
                if (t = +t,
                e = 0 | e,
                r = 0 | r,
                !i) {
                    var n = Math.pow(2, 8 * r) - 1;
                    N(this, t, e, r, n, 0)
                }
                var o = r - 1
                  , a = 1;
                for (this[e + o] = 255 & t; --o >= 0 && (a *= 256); )
                    this[e + o] = t / a & 255;
                return e + r
            }
            ,
            a.prototype.writeUInt8 = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 1, 255, 0),
                a.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                this[e] = 255 & t,
                e + 1
            }
            ,
            a.prototype.writeUInt16LE = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 2, 65535, 0),
                a.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t,
                this[e + 1] = t >>> 8) : B(this, t, e, !0),
                e + 2
            }
            ,
            a.prototype.writeUInt16BE = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 2, 65535, 0),
                a.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8,
                this[e + 1] = 255 & t) : B(this, t, e, !1),
                e + 2
            }
            ,
            a.prototype.writeUInt32LE = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 4, 4294967295, 0),
                a.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24,
                this[e + 2] = t >>> 16,
                this[e + 1] = t >>> 8,
                this[e] = 255 & t) : F(this, t, e, !0),
                e + 4
            }
            ,
            a.prototype.writeUInt32BE = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 4, 4294967295, 0),
                a.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24,
                this[e + 1] = t >>> 16,
                this[e + 2] = t >>> 8,
                this[e + 3] = 255 & t) : F(this, t, e, !1),
                e + 4
            }
            ,
            a.prototype.writeIntLE = function(t, e, r, i) {
                if (t = +t,
                e = 0 | e,
                !i) {
                    var n = Math.pow(2, 8 * r - 1);
                    N(this, t, e, r, n - 1, -n)
                }
                var o = 0
                  , a = 1
                  , s = 0;
                for (this[e] = 255 & t; ++o < r && (a *= 256); )
                    t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1),
                    this[e + o] = (t / a >> 0) - s & 255;
                return e + r
            }
            ,
            a.prototype.writeIntBE = function(t, e, r, i) {
                if (t = +t,
                e = 0 | e,
                !i) {
                    var n = Math.pow(2, 8 * r - 1);
                    N(this, t, e, r, n - 1, -n)
                }
                var o = r - 1
                  , a = 1
                  , s = 0;
                for (this[e + o] = 255 & t; --o >= 0 && (a *= 256); )
                    t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1),
                    this[e + o] = (t / a >> 0) - s & 255;
                return e + r
            }
            ,
            a.prototype.writeInt8 = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 1, 127, -128),
                a.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                t < 0 && (t = 255 + t + 1),
                this[e] = 255 & t,
                e + 1
            }
            ,
            a.prototype.writeInt16LE = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 2, 32767, -32768),
                a.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t,
                this[e + 1] = t >>> 8) : B(this, t, e, !0),
                e + 2
            }
            ,
            a.prototype.writeInt16BE = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 2, 32767, -32768),
                a.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8,
                this[e + 1] = 255 & t) : B(this, t, e, !1),
                e + 2
            }
            ,
            a.prototype.writeInt32LE = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 4, 2147483647, -2147483648),
                a.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t,
                this[e + 1] = t >>> 8,
                this[e + 2] = t >>> 16,
                this[e + 3] = t >>> 24) : F(this, t, e, !0),
                e + 4
            }
            ,
            a.prototype.writeInt32BE = function(t, e, r) {
                return t = +t,
                e = 0 | e,
                r || N(this, t, e, 4, 2147483647, -2147483648),
                t < 0 && (t = 4294967295 + t + 1),
                a.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24,
                this[e + 1] = t >>> 16,
                this[e + 2] = t >>> 8,
                this[e + 3] = 255 & t) : F(this, t, e, !1),
                e + 4
            }
            ,
            a.prototype.writeFloatLE = function(t, e, r) {
                return z(this, t, e, !0, r)
            }
            ,
            a.prototype.writeFloatBE = function(t, e, r) {
                return z(this, t, e, !1, r)
            }
            ,
            a.prototype.writeDoubleLE = function(t, e, r) {
                return V(this, t, e, !0, r)
            }
            ,
            a.prototype.writeDoubleBE = function(t, e, r) {
                return V(this, t, e, !1, r)
            }
            ,
            a.prototype.copy = function(t, e, r, i) {
                if (r || (r = 0),
                i || 0 === i || (i = this.length),
                e >= t.length && (e = t.length),
                e || (e = 0),
                i > 0 && i < r && (i = r),
                i === r)
                    return 0;
                if (0 === t.length || 0 === this.length)
                    return 0;
                if (e < 0)
                    throw new RangeError("targetStart out of bounds");
                if (r < 0 || r >= this.length)
                    throw new RangeError("sourceStart out of bounds");
                if (i < 0)
                    throw new RangeError("sourceEnd out of bounds");
                i > this.length && (i = this.length),
                t.length - e < i - r && (i = t.length - e + r);
                var n, o = i - r;
                if (this === t && r < e && e < i)
                    for (n = o - 1; n >= 0; --n)
                        t[n + e] = this[n + r];
                else if (o < 1e3 || !a.TYPED_ARRAY_SUPPORT)
                    for (n = 0; n < o; ++n)
                        t[n + e] = this[n + r];
                else
                    Uint8Array.prototype.set.call(t, this.subarray(r, r + o), e);
                return o
            }
            ,
            a.prototype.fill = function(t, e, r, i) {
                if ("string" == typeof t) {
                    if ("string" == typeof e ? (i = e,
                    e = 0,
                    r = this.length) : "string" == typeof r && (i = r,
                    r = this.length),
                    1 === t.length) {
                        var n = t.charCodeAt(0);
                        n < 256 && (t = n)
                    }
                    if (void 0 !== i && "string" != typeof i)
                        throw new TypeError("encoding must be a string");
                    if ("string" == typeof i && !a.isEncoding(i))
                        throw new TypeError("Unknown encoding: " + i)
                } else
                    "number" == typeof t && (t = 255 & t);
                if (e < 0 || this.length < e || this.length < r)
                    throw new RangeError("Out of range index");
                if (r <= e)
                    return this;
                e >>>= 0,
                r = void 0 === r ? this.length : r >>> 0,
                t || (t = 0);
                var o;
                if ("number" == typeof t)
                    for (o = e; o < r; ++o)
                        this[o] = t;
                else {
                    var s = a.isBuffer(t) ? t : W(new a(t,i).toString())
                      , h = s.length;
                    for (o = 0; o < r - e; ++o)
                        this[o + e] = s[o % h]
                }
                return this
            }
            ;
            var et = /[^+\/0-9A-Za-z-_]/g
        }
        ).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }
    , {
        "base64-js": 1,
        ieee754: 4,
        isarray: 5
    }],
    3: [function(t, e, r) {
        var i = i || function(t) {
            "use strict";
            if (!("undefined" == typeof t || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent))) {
                var e = t.document
                  , r = function() {
                    return t.URL || t.webkitURL || t
                }
                  , i = e.createElementNS("http://www.w3.org/1999/xhtml", "a")
                  , n = "download"in i
                  , o = function(t) {
                    var e = new MouseEvent("click");
                    t.dispatchEvent(e)
                }
                  , a = /constructor/i.test(t.HTMLElement)
                  , s = /CriOS\/[\d]+/.test(navigator.userAgent)
                  , h = function(e) {
                    (t.setImmediate || t.setTimeout)(function() {
                        throw e
                    }, 0)
                }
                  , c = "application/octet-stream"
                  , l = 4e4
                  , u = function(t) {
                    var e = function() {
                        "string" == typeof t ? r().revokeObjectURL(t) : t.remove()
                    };
                    setTimeout(e, l)
                }
                  , p = function(t, e, r) {
                    e = [].concat(e);
                    for (var i = e.length; i--; ) {
                        var n = t["on" + e[i]];
                        if ("function" == typeof n)
                            try {
                                n.call(t, r || t)
                            } catch (t) {
                                h(t)
                            }
                    }
                }
                  , d = function(t) {
                    return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t],{
                        type: t.type
                    }) : t
                }
                  , f = function(e, h, l) {
                    l || (e = d(e));
                    var f, m = this, g = e.type, v = g === c, y = function() {
                        p(m, "writestart progress write writeend".split(" "))
                    }, x = function() {
                        if ((s || v && a) && t.FileReader) {
                            var i = new FileReader;
                            return i.onloadend = function() {
                                var e = s ? i.result : i.result.replace(/^data:[^;]*;/, "data:attachment/file;")
                                  , r = t.open(e, "_blank");
                                r || (t.location.href = e),
                                e = void 0,
                                m.readyState = m.DONE,
                                y()
                            }
                            ,
                            i.readAsDataURL(e),
                            void (m.readyState = m.INIT)
                        }
                        if (f || (f = r().createObjectURL(e)),
                        v)
                            t.location.href = f;
                        else {
                            var n = t.open(f, "_blank");
                            n || (t.location.href = f)
                        }
                        m.readyState = m.DONE,
                        y(),
                        u(f)
                    };
                    return m.readyState = m.INIT,
                    n ? (f = r().createObjectURL(e),
                    void setTimeout(function() {
                        i.href = f,
                        i.download = h,
                        o(i),
                        y(),
                        u(f),
                        m.readyState = m.DONE
                    })) : void x()
                }
                  , m = f.prototype
                  , g = function(t, e, r) {
                    return new f(t,e || t.name || "download",r)
                };
                return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function(t, e, r) {
                    return e = e || t.name || "download",
                    r || (t = d(t)),
                    navigator.msSaveOrOpenBlob(t, e)
                }
                : (m.abort = function() {}
                ,
                m.readyState = m.INIT = 0,
                m.WRITING = 1,
                m.DONE = 2,
                m.error = m.onwritestart = m.onprogress = m.onwrite = m.onabort = m.onerror = m.onwriteend = null,
                g)
            }
        }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);
        "undefined" != typeof e && e.exports ? e.exports.saveAs = i : "undefined" != typeof define && null !== define && null !== define.amd && define([], function() {
            return i
        })
    }
    , {}],
    4: [function(t, e, r) {
        r.read = function(t, e, r, i, n) {
            var o, a, s = 8 * n - i - 1, h = (1 << s) - 1, c = h >> 1, l = -7, u = r ? n - 1 : 0, p = r ? -1 : 1, d = t[e + u];
            for (u += p,
            o = d & (1 << -l) - 1,
            d >>= -l,
            l += s; l > 0; o = 256 * o + t[e + u],
            u += p,
            l -= 8)
                ;
            for (a = o & (1 << -l) - 1,
            o >>= -l,
            l += i; l > 0; a = 256 * a + t[e + u],
            u += p,
            l -= 8)
                ;
            if (0 === o)
                o = 1 - c;
            else {
                if (o === h)
                    return a ? NaN : (d ? -1 : 1) * (1 / 0);
                a += Math.pow(2, i),
                o -= c
            }
            return (d ? -1 : 1) * a * Math.pow(2, o - i)
        }
        ,
        r.write = function(t, e, r, i, n, o) {
            var a, s, h, c = 8 * o - n - 1, l = (1 << c) - 1, u = l >> 1, p = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = i ? 0 : o - 1, f = i ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e),
            isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0,
            a = l) : (a = Math.floor(Math.log(e) / Math.LN2),
            e * (h = Math.pow(2, -a)) < 1 && (a--,
            h *= 2),
            e += a + u >= 1 ? p / h : p * Math.pow(2, 1 - u),
            e * h >= 2 && (a++,
            h /= 2),
            a + u >= l ? (s = 0,
            a = l) : a + u >= 1 ? (s = (e * h - 1) * Math.pow(2, n),
            a += u) : (s = e * Math.pow(2, u - 1) * Math.pow(2, n),
            a = 0)); n >= 8; t[r + d] = 255 & s,
            d += f,
            s /= 256,
            n -= 8)
                ;
            for (a = a << n | s,
            c += n; c > 0; t[r + d] = 255 & a,
            d += f,
            a /= 256,
            c -= 8)
                ;
            t[r + d - f] |= 128 * m
        }
    }
    , {}],
    5: [function(t, e, r) {
        var i = {}.toString;
        e.exports = Array.isArray || function(t) {
            return "[object Array]" == i.call(t)
        }
    }
    , {}],
    6: [function(t, e, r) {
        (function(t) {
            !function(t) {
                var r = this;
                e.exports = t(r)
            }(function(e) {
                "use strict";
                function r(t, e) {
                    return "object" == typeof t && null !== t && (t.constructor === e || Object.prototype.toString.call(t) === "[object " + e.name + "]")
                }
                function i(t, e) {
                    return !e && r(t, Array) ? t : Array.prototype.slice.call(t)
                }
                function n(t, e) {
                    return void 0 !== t ? t : e
                }
                function o(e, i, a, s) {
                    if (o.is(e)) {
                        var h = e.slice(i, i + a);
                        return h._littleEndian = n(s, h._littleEndian),
                        h
                    }
                    if (!o.is(this))
                        return new o(e,i,a,s);
                    if (this.buffer = e = o.wrapBuffer(e),
                    this._isArrayBuffer = l.ArrayBuffer && r(e, ArrayBuffer),
                    this._isPixelData = !1,
                    this._isDataView = l.DataView && this._isArrayBuffer,
                    this._isNodeBuffer = l.NodeBuffer && r(e, t),
                    !this._isNodeBuffer && !this._isArrayBuffer && !r(e, Array))
                        throw new TypeError("jDataView buffer has an incompatible type");
                    this._littleEndian = !!s;
                    var c = "byteLength"in e ? e.byteLength : e.length;
                    this.byteOffset = i = n(i, 0),
                    this.byteLength = a = n(a, c - i),
                    this._offset = this._bitOffset = 0,
                    this._isDataView ? this._view = new DataView(e,i,a) : this._checkBounds(i, a, c),
                    this._engineAction = this._isDataView ? this._dataViewAction : this._isNodeBuffer ? this._nodeBufferAction : this._isArrayBuffer ? this._arrayBufferAction : this._arrayAction
                }
                function a(e) {
                    if (l.NodeBuffer)
                        return new t(e,"binary");
                    for (var r = l.ArrayBuffer ? Uint8Array : Array, i = new r(e.length), n = 0, o = e.length; o > n; n++)
                        i[n] = 255 & e.charCodeAt(n);
                    return i
                }
                function s(t) {
                    return t >= 0 && 31 > t ? 1 << t : s[t] || (s[t] = Math.pow(2, t))
                }
                function h(t, e) {
                    this.lo = t,
                    this.hi = e
                }
                function c() {
                    h.apply(this, arguments)
                }
                var l = {
                    NodeBuffer: "Buffer"in e,
                    DataView: "DataView"in e,
                    ArrayBuffer: "ArrayBuffer"in e,
                    PixelData: !1
                }
                  , u = e.TextEncoder
                  , p = e.TextDecoder;
                l.NodeBuffer && !function(t) {
                    try {
                        t.writeFloatLE(1 / 0, 0)
                    } catch (t) {
                        l.NodeBuffer = !1
                    }
                }(new t(4));
                var d = {
                    Int8: 1,
                    Int16: 2,
                    Int32: 4,
                    Uint8: 1,
                    Uint16: 2,
                    Uint32: 4,
                    Float32: 4,
                    Float64: 8
                };
                o.wrapBuffer = function(e) {
                    switch (typeof e) {
                    case "number":
                        if (l.NodeBuffer)
                            e = new t(e),
                            e.fill(0);
                        else if (l.ArrayBuffer)
                            e = new Uint8Array(e).buffer;
                        else {
                            e = new Array(e);
                            for (var n = 0; n < e.length; n++)
                                e[n] = 0
                        }
                        return e;
                    case "string":
                        e = a(e);
                    default:
                        return "length"in e && !(l.NodeBuffer && r(e, t) || l.ArrayBuffer && r(e, ArrayBuffer)) && (l.NodeBuffer ? e = new t(e) : l.ArrayBuffer ? r(e, ArrayBuffer) || (e = new Uint8Array(e).buffer,
                        r(e, ArrayBuffer) || (e = new Uint8Array(i(e, !0)).buffer)) : e = i(e)),
                        e
                    }
                }
                ,
                o.is = function(t) {
                    return t && t.jDataView
                }
                ,
                o.from = function() {
                    return new o(arguments)
                }
                ,
                o.Uint64 = h,
                h.prototype = {
                    valueOf: function() {
                        return this.lo + s(32) * this.hi
                    },
                    toString: function() {
                        return Number.prototype.toString.apply(this.valueOf(), arguments)
                    }
                },
                h.fromNumber = function(t) {
                    var e = Math.floor(t / s(32))
                      , r = t - e * s(32);
                    return new h(r,e)
                }
                ,
                o.Int64 = c,
                c.prototype = "create"in Object ? Object.create(h.prototype) : new h,
                c.prototype.valueOf = function() {
                    return this.hi < s(31) ? h.prototype.valueOf.apply(this, arguments) : -(s(32) - this.lo + s(32) * (s(32) - 1 - this.hi))
                }
                ,
                c.fromNumber = function(t) {
                    var e, r;
                    if (t >= 0) {
                        var i = h.fromNumber(t);
                        e = i.lo,
                        r = i.hi
                    } else
                        r = Math.floor(t / s(32)),
                        e = t - r * s(32),
                        r += s(32);
                    return new c(e,r)
                }
                ;
                var f = o.prototype = {
                    compatibility: l,
                    jDataView: !0,
                    _checkBounds: function(t, e, r) {
                        if ("number" != typeof t)
                            throw new TypeError("Offset is not a number.");
                        if ("number" != typeof e)
                            throw new TypeError("Size is not a number.");
                        if (0 > e)
                            throw new RangeError("Length is negative.");
                        if (0 > t || t + e > n(r, this.byteLength))
                            throw new RangeError("Offsets are out of bounds.")
                    },
                    _action: function(t, e, r, i, o) {
                        return this._engineAction(t, e, n(r, this._offset), n(i, this._littleEndian), o)
                    },
                    _dataViewAction: function(t, e, r, i, n) {
                        return this._offset = r + d[t],
                        e ? this._view["get" + t](r, i) : this._view["set" + t](r, n, i)
                    },
                    _arrayBufferAction: function(t, r, i, o, a) {
                        var s, h = d[t], c = e[t + "Array"];
                        if (o = n(o, this._littleEndian),
                        1 === h || (this.byteOffset + i) % h === 0 && o)
                            return s = new c(this.buffer,this.byteOffset + i,1),
                            this._offset = i + h,
                            r ? s[0] : s[0] = a;
                        var l = new Uint8Array(r ? this.getBytes(h, i, o, !0) : h);
                        return s = new c(l.buffer,0,1),
                        r ? s[0] : (s[0] = a,
                        void this._setBytes(i, l, o))
                    },
                    _arrayAction: function(t, e, r, i, n) {
                        return e ? this["_get" + t](r, i) : this["_set" + t](r, n, i)
                    },
                    _getBytes: function(t, e, r) {
                        r = n(r, this._littleEndian),
                        e = n(e, this._offset),
                        t = n(t, this.byteLength - e),
                        this._checkBounds(e, t),
                        e += this.byteOffset,
                        this._offset = e - this.byteOffset + t;
                        var o = this._isArrayBuffer ? new Uint8Array(this.buffer,e,t) : (this.buffer.slice || Array.prototype.slice).call(this.buffer, e, e + t);
                        return r || 1 >= t ? o : i(o).reverse()
                    },
                    getBytes: function(t, e, r, o) {
                        var a = this._getBytes(t, e, n(r, !0));
                        return o ? i(a) : a
                    },
                    _setBytes: function(e, r, o) {
                        var a = r.length;
                        if (0 !== a) {
                            if (o = n(o, this._littleEndian),
                            e = n(e, this._offset),
                            this._checkBounds(e, a),
                            !o && a > 1 && (r = i(r, !0).reverse()),
                            e += this.byteOffset,
                            this._isArrayBuffer)
                                new Uint8Array(this.buffer,e,a).set(r);
                            else if (this._isNodeBuffer)
                                new t(r).copy(this.buffer, e);
                            else
                                for (var s = 0; a > s; s++)
                                    this.buffer[e + s] = r[s];
                            this._offset = e - this.byteOffset + a
                        }
                    },
                    setBytes: function(t, e, r) {
                        this._setBytes(t, e, n(r, !0))
                    },
                    getString: function(t, e, r) {
                        if (this._isNodeBuffer)
                            return e = n(e, this._offset),
                            t = n(t, this.byteLength - e),
                            this._checkBounds(e, t),
                            this._offset = e + t,
                            this.buffer.toString(r || "binary", this.byteOffset + e, this.byteOffset + this._offset);
                        var i = this._getBytes(t, e, !0);
                        if (r = "utf8" === r ? "utf-8" : r || "binary",
                        p && "binary" !== r)
                            return new p(r).decode(this._isArrayBuffer ? i : new Uint8Array(i));
                        var o = "";
                        t = i.length;
                        for (var a = 0; t > a; a++)
                            o += String.fromCharCode(i[a]);
                        return "utf-8" === r && (o = decodeURIComponent(escape(o))),
                        o
                    },
                    setString: function(t, e, r) {
                        if (this._isNodeBuffer)
                            return t = n(t, this._offset),
                            this._checkBounds(t, e.length),
                            void (this._offset = t + this.buffer.write(e, this.byteOffset + t, r || "binary"));
                        r = "utf8" === r ? "utf-8" : r || "binary";
                        var i;
                        u && "binary" !== r ? i = new u(r).encode(e) : ("utf-8" === r && (e = unescape(encodeURIComponent(e))),
                        i = a(e)),
                        this._setBytes(t, i, !0)
                    },
                    getChar: function(t) {
                        return this.getString(1, t)
                    },
                    setChar: function(t, e) {
                        this.setString(t, e)
                    },
                    tell: function() {
                        return this._offset
                    },
                    seek: function(t) {
                        return this._checkBounds(t, 0),
                        this._offset = t
                    },
                    skip: function(t) {
                        return this.seek(this._offset + t)
                    },
                    slice: function(t, e, r) {
                        function i(t, e) {
                            return 0 > t ? t + e : t
                        }
                        return t = i(t, this.byteLength),
                        e = i(n(e, this.byteLength), this.byteLength),
                        r ? new o(this.getBytes(e - t, t, !0, !0),(void 0),(void 0),this._littleEndian) : new o(this.buffer,this.byteOffset + t,e - t,this._littleEndian)
                    },
                    alignBy: function(t) {
                        return this._bitOffset = 0,
                        1 !== n(t, 1) ? this.skip(t - (this._offset % t || t)) : this._offset
                    },
                    _getFloat64: function(t, e) {
                        var r = this._getBytes(8, t, e)
                          , i = 1 - 2 * (r[7] >> 7)
                          , n = ((r[7] << 1 & 255) << 3 | r[6] >> 4) - 1023
                          , o = (15 & r[6]) * s(48) + r[5] * s(40) + r[4] * s(32) + r[3] * s(24) + r[2] * s(16) + r[1] * s(8) + r[0];
                        return 1024 === n ? 0 !== o ? NaN : 1 / 0 * i : -1023 === n ? i * o * s(-1074) : i * (1 + o * s(-52)) * s(n)
                    },
                    _getFloat32: function(t, e) {
                        var r = this._getBytes(4, t, e)
                          , i = 1 - 2 * (r[3] >> 7)
                          , n = (r[3] << 1 & 255 | r[2] >> 7) - 127
                          , o = (127 & r[2]) << 16 | r[1] << 8 | r[0];
                        return 128 === n ? 0 !== o ? NaN : 1 / 0 * i : -127 === n ? i * o * s(-149) : i * (1 + o * s(-23)) * s(n)
                    },
                    _get64: function(t, e, r) {
                        r = n(r, this._littleEndian),
                        e = n(e, this._offset);
                        for (var i = r ? [0, 4] : [4, 0], o = 0; 2 > o; o++)
                            i[o] = this.getUint32(e + i[o], r);
                        return this._offset = e + 8,
                        new t(i[0],i[1])
                    },
                    getInt64: function(t, e) {
                        return this._get64(c, t, e)
                    },
                    getUint64: function(t, e) {
                        return this._get64(h, t, e);
                    },
                    _getInt32: function(t, e) {
                        var r = this._getBytes(4, t, e);
                        return r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0]
                    },
                    _getUint32: function(t, e) {
                        return this._getInt32(t, e) >>> 0
                    },
                    _getInt16: function(t, e) {
                        return this._getUint16(t, e) << 16 >> 16
                    },
                    _getUint16: function(t, e) {
                        var r = this._getBytes(2, t, e);
                        return r[1] << 8 | r[0]
                    },
                    _getInt8: function(t) {
                        return this._getUint8(t) << 24 >> 24
                    },
                    _getUint8: function(t) {
                        return this._getBytes(1, t)[0]
                    },
                    _getBitRangeData: function(t, e) {
                        var r = (n(e, this._offset) << 3) + this._bitOffset
                          , i = r + t
                          , o = r >>> 3
                          , a = i + 7 >>> 3
                          , s = this._getBytes(a - o, o, !0)
                          , h = 0;
                        (this._bitOffset = 7 & i) && (this._bitOffset -= 8);
                        for (var c = 0, l = s.length; l > c; c++)
                            h = h << 8 | s[c];
                        return {
                            start: o,
                            bytes: s,
                            wideValue: h
                        }
                    },
                    getSigned: function(t, e) {
                        var r = 32 - t;
                        return this.getUnsigned(t, e) << r >> r
                    },
                    getUnsigned: function(t, e) {
                        var r = this._getBitRangeData(t, e).wideValue >>> -this._bitOffset;
                        return 32 > t ? r & ~(-1 << t) : r
                    },
                    _setBinaryFloat: function(t, e, r, i, n) {
                        var o, a, h = 0 > e ? 1 : 0, c = ~(-1 << i - 1), l = 1 - c;
                        0 > e && (e = -e),
                        0 === e ? (o = 0,
                        a = 0) : isNaN(e) ? (o = 2 * c + 1,
                        a = 1) : 1 / 0 === e ? (o = 2 * c + 1,
                        a = 0) : (o = Math.floor(Math.log(e) / Math.LN2),
                        o >= l && c >= o ? (a = Math.floor((e * s(-o) - 1) * s(r)),
                        o += c) : (a = Math.floor(e / s(l - r)),
                        o = 0));
                        for (var u = []; r >= 8; )
                            u.push(a % 256),
                            a = Math.floor(a / 256),
                            r -= 8;
                        for (o = o << r | a,
                        i += r; i >= 8; )
                            u.push(255 & o),
                            o >>>= 8,
                            i -= 8;
                        u.push(h << i | o),
                        this._setBytes(t, u, n)
                    },
                    _setFloat32: function(t, e, r) {
                        this._setBinaryFloat(t, e, 23, 8, r)
                    },
                    _setFloat64: function(t, e, r) {
                        this._setBinaryFloat(t, e, 52, 11, r)
                    },
                    _set64: function(t, e, r, i) {
                        "object" != typeof r && (r = t.fromNumber(r)),
                        i = n(i, this._littleEndian),
                        e = n(e, this._offset);
                        var o = i ? {
                            lo: 0,
                            hi: 4
                        } : {
                            lo: 4,
                            hi: 0
                        };
                        for (var a in o)
                            this.setUint32(e + o[a], r[a], i);
                        this._offset = e + 8
                    },
                    setInt64: function(t, e, r) {
                        this._set64(c, t, e, r)
                    },
                    setUint64: function(t, e, r) {
                        this._set64(h, t, e, r)
                    },
                    _setUint32: function(t, e, r) {
                        this._setBytes(t, [255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24], r)
                    },
                    _setUint16: function(t, e, r) {
                        this._setBytes(t, [255 & e, e >>> 8 & 255], r)
                    },
                    _setUint8: function(t, e) {
                        this._setBytes(t, [255 & e])
                    },
                    setUnsigned: function(t, e, r) {
                        var i = this._getBitRangeData(r, t)
                          , n = i.wideValue
                          , o = i.bytes;
                        n &= ~(~(-1 << r) << -this._bitOffset),
                        n |= (32 > r ? e & ~(-1 << r) : e) << -this._bitOffset;
                        for (var a = o.length - 1; a >= 0; a--)
                            o[a] = 255 & n,
                            n >>>= 8;
                        this._setBytes(i.start, o, !0)
                    }
                }
                  , m = {
                    Int8: "Int8",
                    Int16: "Int16",
                    Int32: "Int32",
                    Uint8: "UInt8",
                    Uint16: "UInt16",
                    Uint32: "UInt32",
                    Float32: "Float",
                    Float64: "Double"
                };
                f._nodeBufferAction = function(t, e, r, i, n) {
                    this._offset = r + d[t];
                    var o = m[t] + ("Int8" === t || "Uint8" === t ? "" : i ? "LE" : "BE");
                    return r += this.byteOffset,
                    e ? this.buffer["read" + o](r) : this.buffer["write" + o](n, r)
                }
                ;
                for (var g in d)
                    !function(t) {
                        f["get" + t] = function(e, r) {
                            return this._action(t, !0, e, r)
                        }
                        ,
                        f["set" + t] = function(e, r, i) {
                            this._action(t, !1, e, i, r)
                        }
                    }(g);
                f._setInt32 = f._setUint32,
                f._setInt16 = f._setUint16,
                f._setInt8 = f._setUint8,
                f.setSigned = f.setUnsigned;
                for (var v in f)
                    "set" === v.slice(0, 3) && !function(t) {
                        f["write" + t] = function() {
                            Array.prototype.unshift.call(arguments, void 0),
                            this["set" + t].apply(this, arguments)
                        }
                    }(v.slice(3));
                return o
            })
        }
        ).call(this, t("buffer").Buffer)
    }
    , {
        buffer: 2
    }],
    7: [function(t, e, r) {
        var i = window.THREE || t("three");
        e.exports = TrackballControls = function(t, e) {
            function r(t) {
                d.enabled !== !1 && (window.removeEventListener("keydown", r),
                y = v,
                v === f.NONE && (t.keyCode !== d.keys[f.ROTATE] || d.noRotate ? t.keyCode !== d.keys[f.ZOOM] || d.noZoom ? t.keyCode !== d.keys[f.PAN] || d.noPan || (v = f.PAN) : v = f.ZOOM : v = f.ROTATE))
            }
            function n(t) {
                d.enabled !== !1 && (v = y,
                window.addEventListener("keydown", r, !1))
            }
            function o(t) {
                d.enabled !== !1 && (t.preventDefault(),
                t.stopPropagation(),
                v === f.NONE && (v = t.button),
                v !== f.ROTATE || d.noRotate ? v !== f.ZOOM || d.noZoom ? v !== f.PAN || d.noPan || (L.copy(I(t.pageX, t.pageY)),
                C.copy(L)) : (S.copy(I(t.pageX, t.pageY)),
                E.copy(S)) : (w.copy(D(t.pageX, t.pageY)),
                b.copy(w)),
                document.addEventListener("mousemove", a, !1),
                document.addEventListener("mouseup", s, !1),
                d.dispatchEvent(P))
            }
            function a(t) {
                d.enabled !== !1 && (t.preventDefault(),
                t.stopPropagation(),
                v !== f.ROTATE || d.noRotate ? v !== f.ZOOM || d.noZoom ? v !== f.PAN || d.noPan || C.copy(I(t.pageX, t.pageY)) : E.copy(I(t.pageX, t.pageY)) : (b.copy(w),
                w.copy(D(t.pageX, t.pageY))))
            }
            function s(t) {
                d.enabled !== !1 && (t.preventDefault(),
                t.stopPropagation(),
                v = f.NONE,
                document.removeEventListener("mousemove", a),
                document.removeEventListener("mouseup", s),
                d.dispatchEvent(U))
            }
            function h(t) {
                if (d.enabled !== !1) {
                    t.preventDefault(),
                    t.stopPropagation();
                    var e = 0;
                    t.wheelDelta ? e = t.wheelDelta / 40 : t.detail && (e = -t.detail / 3),
                    S.y += .01 * e,
                    d.dispatchEvent(P),
                    d.dispatchEvent(U)
                }
            }
            function c(t) {
                if (d.enabled !== !1) {
                    switch (t.touches.length) {
                    case 1:
                        v = f.TOUCH_ROTATE,
                        w.copy(D(t.touches[0].pageX, t.touches[0].pageY)),
                        b.copy(w);
                        break;
                    case 2:
                        v = f.TOUCH_ZOOM_PAN;
                        var e = t.touches[0].pageX - t.touches[1].pageX
                          , r = t.touches[0].pageY - t.touches[1].pageY;
                        A = T = Math.sqrt(e * e + r * r);
                        var i = (t.touches[0].pageX + t.touches[1].pageX) / 2
                          , n = (t.touches[0].pageY + t.touches[1].pageY) / 2;
                        L.copy(I(i, n)),
                        C.copy(L);
                        break;
                    default:
                        v = f.NONE
                    }
                    d.dispatchEvent(P)
                }
            }
            function l(t) {
                if (d.enabled !== !1)
                    switch (t.preventDefault(),
                    t.stopPropagation(),
                    t.touches.length) {
                    case 1:
                        b.copy(w),
                        w.copy(D(t.touches[0].pageX, t.touches[0].pageY));
                        break;
                    case 2:
                        var e = t.touches[0].pageX - t.touches[1].pageX
                          , r = t.touches[0].pageY - t.touches[1].pageY;
                        A = Math.sqrt(e * e + r * r);
                        var i = (t.touches[0].pageX + t.touches[1].pageX) / 2
                          , n = (t.touches[0].pageY + t.touches[1].pageY) / 2;
                        C.copy(I(i, n));
                        break;
                    default:
                        v = f.NONE
                    }
            }
            function u(t) {
                if (d.enabled !== !1) {
                    switch (t.touches.length) {
                    case 1:
                        b.copy(w),
                        w.copy(D(t.touches[0].pageX, t.touches[0].pageY));
                        break;
                    case 2:
                        T = A = 0;
                        var e = (t.touches[0].pageX + t.touches[1].pageX) / 2
                          , r = (t.touches[0].pageY + t.touches[1].pageY) / 2;
                        C.copy(I(e, r)),
                        L.copy(C)
                    }
                    v = f.NONE,
                    d.dispatchEvent(U)
                }
            }
            function p(t) {
                t.preventDefault()
            }
            var d = this
              , f = {
                NONE: -1,
                ROTATE: 0,
                ZOOM: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_ZOOM_PAN: 4
            };
            this.object = t,
            this.domElement = void 0 !== e ? e : document,
            this.enabled = !0,
            this.screen = {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            },
            this.rotateSpeed = 1,
            this.zoomSpeed = 1.2,
            this.panSpeed = .3,
            this.noRotate = !1,
            this.noZoom = !1,
            this.noPan = !1,
            this.staticMoving = !1,
            this.dynamicDampingFactor = .2,
            this.minDistance = 0,
            this.maxDistance = 1 / 0,
            this.keys = [65, 83, 68],
            this.target = new i.Vector3;
            var m = 1e-6
              , g = new i.Vector3
              , v = f.NONE
              , y = f.NONE
              , x = new i.Vector3
              , b = new i.Vector2
              , w = new i.Vector2
              , _ = new i.Vector3
              , M = 0
              , S = new i.Vector2
              , E = new i.Vector2
              , T = 0
              , A = 0
              , L = new i.Vector2
              , C = new i.Vector2;
            this.target0 = this.target.clone(),
            this.position0 = this.object.position.clone(),
            this.up0 = this.object.up.clone();
            var R = {
                type: "change"
            }
              , P = {
                type: "start"
            }
              , U = {
                type: "end"
            };
            this.handleResize = function() {
                if (this.domElement === document)
                    this.screen.left = 0,
                    this.screen.top = 0,
                    this.screen.width = window.innerWidth,
                    this.screen.height = window.innerHeight;
                else {
                    var t = this.domElement.getBoundingClientRect()
                      , e = this.domElement.ownerDocument.documentElement;
                    this.screen.left = t.left + window.pageXOffset - e.clientLeft,
                    this.screen.top = t.top + window.pageYOffset - e.clientTop,
                    this.screen.width = t.width,
                    this.screen.height = t.height
                }
            }
            ,
            this.handleEvent = function(t) {
                "function" == typeof this[t.type] && this[t.type](t)
            }
            ;
            var I = function() {
                var t = new i.Vector2;
                return function(e, r) {
                    return t.set((e - d.screen.left) / d.screen.width, (r - d.screen.top) / d.screen.height),
                    t
                }
            }()
              , D = function() {
                var t = new i.Vector2;
                return function(e, r) {
                    return t.set((e - .5 * d.screen.width - d.screen.left) / (.5 * d.screen.width), (d.screen.height + 2 * (d.screen.top - r)) / d.screen.width),
                    t
                }
            }();
            this.rotateCamera = function() {
                var t, e = new i.Vector3, r = new i.Quaternion, n = new i.Vector3, o = new i.Vector3, a = new i.Vector3, s = new i.Vector3;
                return function() {
                    s.set(w.x - b.x, w.y - b.y, 0),
                    t = s.length(),
                    t ? (x.copy(d.object.position).sub(d.target),
                    n.copy(x).normalize(),
                    o.copy(d.object.up).normalize(),
                    a.crossVectors(o, n).normalize(),
                    o.setLength(w.y - b.y),
                    a.setLength(w.x - b.x),
                    s.copy(o.add(a)),
                    e.crossVectors(s, x).normalize(),
                    t *= d.rotateSpeed,
                    r.setFromAxisAngle(e, t),
                    x.applyQuaternion(r),
                    d.object.up.applyQuaternion(r),
                    _.copy(e),
                    M = t) : !d.staticMoving && M && (M *= Math.sqrt(1 - d.dynamicDampingFactor),
                    x.copy(d.object.position).sub(d.target),
                    r.setFromAxisAngle(_, M),
                    x.applyQuaternion(r),
                    d.object.up.applyQuaternion(r)),
                    b.copy(w)
                }
            }(),
            this.zoomCamera = function() {
                var t;
                v === f.TOUCH_ZOOM_PAN ? (t = T / A,
                T = A,
                x.multiplyScalar(t)) : (t = 1 + (E.y - S.y) * d.zoomSpeed,
                1 !== t && t > 0 && (x.multiplyScalar(t),
                d.staticMoving ? S.copy(E) : S.y += (E.y - S.y) * this.dynamicDampingFactor))
            }
            ,
            this.panCamera = function() {
                var t = new i.Vector2
                  , e = new i.Vector3
                  , r = new i.Vector3;
                return function() {
                    t.copy(C).sub(L),
                    t.lengthSq() && (t.multiplyScalar(x.length() * d.panSpeed),
                    r.copy(x).cross(d.object.up).setLength(t.x),
                    r.add(e.copy(d.object.up).setLength(t.y)),
                    d.object.position.add(r),
                    d.target.add(r),
                    d.staticMoving ? L.copy(C) : L.add(t.subVectors(C, L).multiplyScalar(d.dynamicDampingFactor)))
                }
            }(),
            this.checkDistances = function() {
                d.noZoom && d.noPan || (x.lengthSq() > d.maxDistance * d.maxDistance && (d.object.position.addVectors(d.target, x.setLength(d.maxDistance)),
                S.copy(E)),
                x.lengthSq() < d.minDistance * d.minDistance && (d.object.position.addVectors(d.target, x.setLength(d.minDistance)),
                S.copy(E)))
            }
            ,
            this.update = function() {
                x.subVectors(d.object.position, d.target),
                d.noRotate || d.rotateCamera(),
                d.noZoom || d.zoomCamera(),
                d.noPan || d.panCamera(),
                d.object.position.addVectors(d.target, x),
                d.checkDistances(),
                d.object.lookAt(d.target),
                g.distanceToSquared(d.object.position) > m && (d.dispatchEvent(R),
                g.copy(d.object.position))
            }
            ,
            this.reset = function() {
                v = f.NONE,
                y = f.NONE,
                d.target.copy(d.target0),
                d.object.position.copy(d.position0),
                d.object.up.copy(d.up0),
                x.subVectors(d.object.position, d.target),
                d.object.lookAt(d.target),
                d.dispatchEvent(R),
                g.copy(d.object.position)
            }
            ,
            this.dispose = function() {
                this.domElement.removeEventListener("contextmenu", p, !1),
                this.domElement.removeEventListener("mousedown", o, !1),
                this.domElement.removeEventListener("mousewheel", h, !1),
                this.domElement.removeEventListener("MozMousePixelScroll", h, !1),
                this.domElement.removeEventListener("touchstart", c, !1),
                this.domElement.removeEventListener("touchend", u, !1),
                this.domElement.removeEventListener("touchmove", l, !1),
                document.removeEventListener("mousemove", a, !1),
                document.removeEventListener("mouseup", s, !1),
                window.removeEventListener("keydown", r, !1),
                window.removeEventListener("keyup", n, !1)
            }
            ,
            this.domElement.addEventListener("contextmenu", p, !1),
            this.domElement.addEventListener("mousedown", o, !1),
            this.domElement.addEventListener("mousewheel", h, !1),
            this.domElement.addEventListener("MozMousePixelScroll", h, !1),
            this.domElement.addEventListener("touchstart", c, !1),
            this.domElement.addEventListener("touchend", u, !1),
            this.domElement.addEventListener("touchmove", l, !1),
            window.addEventListener("keydown", r, !1),
            window.addEventListener("keyup", n, !1),
            this.handleResize(),
            this.update()
        }
        ,
        TrackballControls.prototype = Object.create(i.EventDispatcher.prototype)
    }
    , {
        three: 8
    }],
    8: [function(t, e, r) {
        var i = {
            REVISION: "74"
        };
        "function" == typeof define && define.amd ? define("three", i) : "undefined" != typeof r && "undefined" != typeof e && (e.exports = i),
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
        void 0 === Math.sign && (Math.sign = function(t) {
            return t < 0 ? -1 : t > 0 ? 1 : +t
        }
        ),
        void 0 === Function.prototype.name && void 0 !== Object.defineProperty && Object.defineProperty(Function.prototype, "name", {
            get: function() {
                return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
            }
        }),
        void 0 === Object.assign && Object.defineProperty(Object, "assign", {
            writable: !0,
            configurable: !0,
            value: function(t) {
                "use strict";
                if (void 0 === t || null === t)
                    throw new TypeError("Cannot convert first argument to object");
                for (var e = Object(t), r = 1, i = arguments.length; r !== i; ++r) {
                    var n = arguments[r];
                    if (void 0 !== n && null !== n) {
                        n = Object(n);
                        for (var o = Object.keys(n), a = 0, s = o.length; a !== s; ++a) {
                            var h = o[a]
                              , c = Object.getOwnPropertyDescriptor(n, h);
                            void 0 !== c && c.enumerable && (e[h] = n[h])
                        }
                    }
                }
                return e
            }
        }),
        i.MOUSE = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        },
        i.CullFaceNone = 0,
        i.CullFaceBack = 1,
        i.CullFaceFront = 2,
        i.CullFaceFrontBack = 3,
        i.FrontFaceDirectionCW = 0,
        i.FrontFaceDirectionCCW = 1,
        i.BasicShadowMap = 0,
        i.PCFShadowMap = 1,
        i.PCFSoftShadowMap = 2,
        i.FrontSide = 0,
        i.BackSide = 1,
        i.DoubleSide = 2,
        i.FlatShading = 1,
        i.SmoothShading = 2,
        i.NoColors = 0,
        i.FaceColors = 1,
        i.VertexColors = 2,
        i.NoBlending = 0,
        i.NormalBlending = 1,
        i.AdditiveBlending = 2,
        i.SubtractiveBlending = 3,
        i.MultiplyBlending = 4,
        i.CustomBlending = 5,
        i.AddEquation = 100,
        i.SubtractEquation = 101,
        i.ReverseSubtractEquation = 102,
        i.MinEquation = 103,
        i.MaxEquation = 104,
        i.ZeroFactor = 200,
        i.OneFactor = 201,
        i.SrcColorFactor = 202,
        i.OneMinusSrcColorFactor = 203,
        i.SrcAlphaFactor = 204,
        i.OneMinusSrcAlphaFactor = 205,
        i.DstAlphaFactor = 206,
        i.OneMinusDstAlphaFactor = 207,
        i.DstColorFactor = 208,
        i.OneMinusDstColorFactor = 209,
        i.SrcAlphaSaturateFactor = 210,
        i.NeverDepth = 0,
        i.AlwaysDepth = 1,
        i.LessDepth = 2,
        i.LessEqualDepth = 3,
        i.EqualDepth = 4,
        i.GreaterEqualDepth = 5,
        i.GreaterDepth = 6,
        i.NotEqualDepth = 7,
        i.MultiplyOperation = 0,
        i.MixOperation = 1,
        i.AddOperation = 2,
        i.UVMapping = 300,
        i.CubeReflectionMapping = 301,
        i.CubeRefractionMapping = 302,
        i.EquirectangularReflectionMapping = 303,
        i.EquirectangularRefractionMapping = 304,
        i.SphericalReflectionMapping = 305,
        i.RepeatWrapping = 1e3,
        i.ClampToEdgeWrapping = 1001,
        i.MirroredRepeatWrapping = 1002,
        i.NearestFilter = 1003,
        i.NearestMipMapNearestFilter = 1004,
        i.NearestMipMapLinearFilter = 1005,
        i.LinearFilter = 1006,
        i.LinearMipMapNearestFilter = 1007,
        i.LinearMipMapLinearFilter = 1008,
        i.UnsignedByteType = 1009,
        i.ByteType = 1010,
        i.ShortType = 1011,
        i.UnsignedShortType = 1012,
        i.IntType = 1013,
        i.UnsignedIntType = 1014,
        i.FloatType = 1015,
        i.HalfFloatType = 1025,
        i.UnsignedShort4444Type = 1016,
        i.UnsignedShort5551Type = 1017,
        i.UnsignedShort565Type = 1018,
        i.AlphaFormat = 1019,
        i.RGBFormat = 1020,
        i.RGBAFormat = 1021,
        i.LuminanceFormat = 1022,
        i.LuminanceAlphaFormat = 1023,
        i.RGBEFormat = i.RGBAFormat,
        i.RGB_S3TC_DXT1_Format = 2001,
        i.RGBA_S3TC_DXT1_Format = 2002,
        i.RGBA_S3TC_DXT3_Format = 2003,
        i.RGBA_S3TC_DXT5_Format = 2004,
        i.RGB_PVRTC_4BPPV1_Format = 2100,
        i.RGB_PVRTC_2BPPV1_Format = 2101,
        i.RGBA_PVRTC_4BPPV1_Format = 2102,
        i.RGBA_PVRTC_2BPPV1_Format = 2103,
        i.RGB_ETC1_Format = 2151,
        i.LoopOnce = 2200,
        i.LoopRepeat = 2201,
        i.LoopPingPong = 2202,
        i.InterpolateDiscrete = 2300,
        i.InterpolateLinear = 2301,
        i.InterpolateSmooth = 2302,
        i.ZeroCurvatureEnding = 2400,
        i.ZeroSlopeEnding = 2401,
        i.WrapAroundEnding = 2402,
        i.TrianglesDrawMode = 0,
        i.TriangleStripDrawMode = 1,
        i.TriangleFanDrawMode = 2,
        i.Color = function(t) {
            return 3 === arguments.length ? this.fromArray(arguments) : this.set(t)
        }
        ,
        i.Color.prototype = {
            constructor: i.Color,
            r: 1,
            g: 1,
            b: 1,
            set: function(t) {
                return t instanceof i.Color ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
                this
            },
            setScalar: function(t) {
                this.r = t,
                this.g = t,
                this.b = t
            },
            setHex: function(t) {
                return t = Math.floor(t),
                this.r = (t >> 16 & 255) / 255,
                this.g = (t >> 8 & 255) / 255,
                this.b = (255 & t) / 255,
                this
            },
            setRGB: function(t, e, r) {
                return this.r = t,
                this.g = e,
                this.b = r,
                this
            },
            setHSL: function() {
                function t(t, e, r) {
                    return r < 0 && (r += 1),
                    r > 1 && (r -= 1),
                    r < 1 / 6 ? t + 6 * (e - t) * r : r < .5 ? e : r < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - r) : t
                }
                return function(e, r, n) {
                    if (e = i.Math.euclideanModulo(e, 1),
                    r = i.Math.clamp(r, 0, 1),
                    n = i.Math.clamp(n, 0, 1),
                    0 === r)
                        this.r = this.g = this.b = n;
                    else {
                        var o = n <= .5 ? n * (1 + r) : n + r - n * r
                          , a = 2 * n - o;
                        this.r = t(a, o, e + 1 / 3),
                        this.g = t(a, o, e),
                        this.b = t(a, o, e - 1 / 3)
                    }
                    return this
                }
            }(),
            setStyle: function(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                var r;
                if (r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var n, o = r[1], a = r[2];
                    switch (o) {
                    case "rgb":
                    case "rgba":
                        if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
                            return this.r = Math.min(255, parseInt(n[1], 10)) / 255,
                            this.g = Math.min(255, parseInt(n[2], 10)) / 255,
                            this.b = Math.min(255, parseInt(n[3], 10)) / 255,
                            e(n[5]),
                            this;
                        if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
                            return this.r = Math.min(100, parseInt(n[1], 10)) / 100,
                            this.g = Math.min(100, parseInt(n[2], 10)) / 100,
                            this.b = Math.min(100, parseInt(n[3], 10)) / 100,
                            e(n[5]),
                            this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                            var s = parseFloat(n[1]) / 360
                              , h = parseInt(n[2], 10) / 100
                              , c = parseInt(n[3], 10) / 100;
                            return e(n[5]),
                            this.setHSL(s, h, c)
                        }
                    }
                } else if (r = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    var l = r[1]
                      , u = l.length;
                    if (3 === u)
                        return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255,
                        this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255,
                        this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255,
                        this;
                    if (6 === u)
                        return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255,
                        this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255,
                        this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255,
                        this
                }
                if (t && t.length > 0) {
                    var l = i.ColorKeywords[t];
                    void 0 !== l ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t)
                }
                return this
            },
            clone: function() {
                return new this.constructor(this.r,this.g,this.b)
            },
            copy: function(t) {
                return this.r = t.r,
                this.g = t.g,
                this.b = t.b,
                this
            },
            copyGammaToLinear: function(t, e) {
                return void 0 === e && (e = 2),
                this.r = Math.pow(t.r, e),
                this.g = Math.pow(t.g, e),
                this.b = Math.pow(t.b, e),
                this
            },
            copyLinearToGamma: function(t, e) {
                void 0 === e && (e = 2);
                var r = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, r),
                this.g = Math.pow(t.g, r),
                this.b = Math.pow(t.b, r),
                this
            },
            convertGammaToLinear: function() {
                var t = this.r
                  , e = this.g
                  , r = this.b;
                return this.r = t * t,
                this.g = e * e,
                this.b = r * r,
                this
            },
            convertLinearToGamma: function() {
                return this.r = Math.sqrt(this.r),
                this.g = Math.sqrt(this.g),
                this.b = Math.sqrt(this.b),
                this
            },
            getHex: function() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function(t) {
                var e, r, i = t || {
                    h: 0,
                    s: 0,
                    l: 0
                }, n = this.r, o = this.g, a = this.b, s = Math.max(n, o, a), h = Math.min(n, o, a), c = (h + s) / 2;
                if (h === s)
                    e = 0,
                    r = 0;
                else {
                    var l = s - h;
                    switch (r = c <= .5 ? l / (s + h) : l / (2 - s - h),
                    s) {
                    case n:
                        e = (o - a) / l + (o < a ? 6 : 0);
                        break;
                    case o:
                        e = (a - n) / l + 2;
                        break;
                    case a:
                        e = (n - o) / l + 4
                    }
                    e /= 6
                }
                return i.h = e,
                i.s = r,
                i.l = c,
                i
            },
            getStyle: function() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function(t, e, r) {
                var i = this.getHSL();
                return i.h += t,
                i.s += e,
                i.l += r,
                this.setHSL(i.h, i.s, i.l),
                this
            },
            add: function(t) {
                return this.r += t.r,
                this.g += t.g,
                this.b += t.b,
                this
            },
            addColors: function(t, e) {
                return this.r = t.r + e.r,
                this.g = t.g + e.g,
                this.b = t.b + e.b,
                this
            },
            addScalar: function(t) {
                return this.r += t,
                this.g += t,
                this.b += t,
                this
            },
            multiply: function(t) {
                return this.r *= t.r,
                this.g *= t.g,
                this.b *= t.b,
                this
            },
            multiplyScalar: function(t) {
                return this.r *= t,
                this.g *= t,
                this.b *= t,
                this
            },
            lerp: function(t, e) {
                return this.r += (t.r - this.r) * e,
                this.g += (t.g - this.g) * e,
                this.b += (t.b - this.b) * e,
                this
            },
            equals: function(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0),
                this.r = t[e],
                this.g = t[e + 1],
                this.b = t[e + 2],
                this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []),
                void 0 === e && (e = 0),
                t[e] = this.r,
                t[e + 1] = this.g,
                t[e + 2] = this.b,
                t
            }
        },
        i.ColorKeywords = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        i.Quaternion = function(t, e, r, i) {
            this._x = t || 0,
            this._y = e || 0,
            this._z = r || 0,
            this._w = void 0 !== i ? i : 1
        }
        ,
        i.Quaternion.prototype = {
            constructor: i.Quaternion,
            get x() {
                return this._x
            },
            set x(t) {
                this._x = t,
                this.onChangeCallback()
            },
            get y() {
                return this._y
            },
            set y(t) {
                this._y = t,
                this.onChangeCallback()
            },
            get z() {
                return this._z
            },
            set z(t) {
                this._z = t,
                this.onChangeCallback()
            },
            get w() {
                return this._w
            },
            set w(t) {
                this._w = t,
                this.onChangeCallback()
            },
            set: function(t, e, r, i) {
                return this._x = t,
                this._y = e,
                this._z = r,
                this._w = i,
                this.onChangeCallback(),
                this
            },
            clone: function() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            },
            copy: function(t) {
                return this._x = t.x,
                this._y = t.y,
                this._z = t.z,
                this._w = t.w,
                this.onChangeCallback(),
                this
            },
            setFromEuler: function(t, e) {
                if (t instanceof i.Euler == !1)
                    throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var r = Math.cos(t._x / 2)
                  , n = Math.cos(t._y / 2)
                  , o = Math.cos(t._z / 2)
                  , a = Math.sin(t._x / 2)
                  , s = Math.sin(t._y / 2)
                  , h = Math.sin(t._z / 2)
                  , c = t.order;
                return "XYZ" === c ? (this._x = a * n * o + r * s * h,
                this._y = r * s * o - a * n * h,
                this._z = r * n * h + a * s * o,
                this._w = r * n * o - a * s * h) : "YXZ" === c ? (this._x = a * n * o + r * s * h,
                this._y = r * s * o - a * n * h,
                this._z = r * n * h - a * s * o,
                this._w = r * n * o + a * s * h) : "ZXY" === c ? (this._x = a * n * o - r * s * h,
                this._y = r * s * o + a * n * h,
                this._z = r * n * h + a * s * o,
                this._w = r * n * o - a * s * h) : "ZYX" === c ? (this._x = a * n * o - r * s * h,
                this._y = r * s * o + a * n * h,
                this._z = r * n * h - a * s * o,
                this._w = r * n * o + a * s * h) : "YZX" === c ? (this._x = a * n * o + r * s * h,
                this._y = r * s * o + a * n * h,
                this._z = r * n * h - a * s * o,
                this._w = r * n * o - a * s * h) : "XZY" === c && (this._x = a * n * o - r * s * h,
                this._y = r * s * o - a * n * h,
                this._z = r * n * h + a * s * o,
                this._w = r * n * o + a * s * h),
                e !== !1 && this.onChangeCallback(),
                this
            },
            setFromAxisAngle: function(t, e) {
                var r = e / 2
                  , i = Math.sin(r);
                return this._x = t.x * i,
                this._y = t.y * i,
                this._z = t.z * i,
                this._w = Math.cos(r),
                this.onChangeCallback(),
                this
            },
            setFromRotationMatrix: function(t) {
                var e, r = t.elements, i = r[0], n = r[4], o = r[8], a = r[1], s = r[5], h = r[9], c = r[2], l = r[6], u = r[10], p = i + s + u;
                return p > 0 ? (e = .5 / Math.sqrt(p + 1),
                this._w = .25 / e,
                this._x = (l - h) * e,
                this._y = (o - c) * e,
                this._z = (a - n) * e) : i > s && i > u ? (e = 2 * Math.sqrt(1 + i - s - u),
                this._w = (l - h) / e,
                this._x = .25 * e,
                this._y = (n + a) / e,
                this._z = (o + c) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - i - u),
                this._w = (o - c) / e,
                this._x = (n + a) / e,
                this._y = .25 * e,
                this._z = (h + l) / e) : (e = 2 * Math.sqrt(1 + u - i - s),
                this._w = (a - n) / e,
                this._x = (o + c) / e,
                this._y = (h + l) / e,
                this._z = .25 * e),
                this.onChangeCallback(),
                this
            },
            setFromUnitVectors: function() {
                var t, e, r = 1e-6;
                return function(n, o) {
                    return void 0 === t && (t = new i.Vector3),
                    e = n.dot(o) + 1,
                    e < r ? (e = 0,
                    Math.abs(n.x) > Math.abs(n.z) ? t.set(-n.y, n.x, 0) : t.set(0, -n.z, n.y)) : t.crossVectors(n, o),
                    this._x = t.x,
                    this._y = t.y,
                    this._z = t.z,
                    this._w = e,
                    this.normalize(),
                    this
                }
            }(),
            inverse: function() {
                return this.conjugate().normalize(),
                this
            },
            conjugate: function() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this.onChangeCallback(),
                this
            },
            dot: function(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            },
            lengthSq: function() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function() {
                var t = this.length();
                return 0 === t ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (t = 1 / t,
                this._x = this._x * t,
                this._y = this._y * t,
                this._z = this._z * t,
                this._w = this._w * t),
                this.onChangeCallback(),
                this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            },
            multiplyQuaternions: function(t, e) {
                var r = t._x
                  , i = t._y
                  , n = t._z
                  , o = t._w
                  , a = e._x
                  , s = e._y
                  , h = e._z
                  , c = e._w;
                return this._x = r * c + o * a + i * h - n * s,
                this._y = i * c + o * s + n * a - r * h,
                this._z = n * c + o * h + r * s - i * a,
                this._w = o * c - r * a - i * s - n * h,
                this.onChangeCallback(),
                this
            },
            slerp: function(t, e) {
                if (0 === e)
                    return this;
                if (1 === e)
                    return this.copy(t);
                var r = this._x
                  , i = this._y
                  , n = this._z
                  , o = this._w
                  , a = o * t._w + r * t._x + i * t._y + n * t._z;
                if (a < 0 ? (this._w = -t._w,
                this._x = -t._x,
                this._y = -t._y,
                this._z = -t._z,
                a = -a) : this.copy(t),
                a >= 1)
                    return this._w = o,
                    this._x = r,
                    this._y = i,
                    this._z = n,
                    this;
                var s = Math.sqrt(1 - a * a);
                if (Math.abs(s) < .001)
                    return this._w = .5 * (o + this._w),
                    this._x = .5 * (r + this._x),
                    this._y = .5 * (i + this._y),
                    this._z = .5 * (n + this._z),
                    this;
                var h = Math.atan2(s, a)
                  , c = Math.sin((1 - e) * h) / s
                  , l = Math.sin(e * h) / s;
                return this._w = o * c + this._w * l,
                this._x = r * c + this._x * l,
                this._y = i * c + this._y * l,
                this._z = n * c + this._z * l,
                this.onChangeCallback(),
                this
            },
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0),
                this._x = t[e],
                this._y = t[e + 1],
                this._z = t[e + 2],
                this._w = t[e + 3],
                this.onChangeCallback(),
                this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []),
                void 0 === e && (e = 0),
                t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._w,
                t
            },
            onChange: function(t) {
                return this.onChangeCallback = t,
                this
            },
            onChangeCallback: function() {}
        },
        Object.assign(i.Quaternion, {
            slerp: function(t, e, r, i) {
                return r.copy(t).slerp(e, i)
            },
            slerpFlat: function(t, e, r, i, n, o, a) {
                var s = r[i + 0]
                  , h = r[i + 1]
                  , c = r[i + 2]
                  , l = r[i + 3]
                  , u = n[o + 0]
                  , p = n[o + 1]
                  , d = n[o + 2]
                  , f = n[o + 3];
                if (l !== f || s !== u || h !== p || c !== d) {
                    var m = 1 - a
                      , g = s * u + h * p + c * d + l * f
                      , v = g >= 0 ? 1 : -1
                      , y = 1 - g * g;
                    if (y > Number.EPSILON) {
                        var x = Math.sqrt(y)
                          , b = Math.atan2(x, g * v);
                        m = Math.sin(m * b) / x,
                        a = Math.sin(a * b) / x
                    }
                    var w = a * v;
                    if (s = s * m + u * w,
                    h = h * m + p * w,
                    c = c * m + d * w,
                    l = l * m + f * w,
                    m === 1 - a) {
                        var _ = 1 / Math.sqrt(s * s + h * h + c * c + l * l);
                        s *= _,
                        h *= _,
                        c *= _,
                        l *= _
                    }
                }
                t[e] = s,
                t[e + 1] = h,
                t[e + 2] = c,
                t[e + 3] = l
            }
        }),
        i.Vector2 = function(t, e) {
            this.x = t || 0,
            this.y = e || 0
        }
        ,
        i.Vector2.prototype = {
            constructor: i.Vector2,
            get width() {
                return this.x
            },
            set width(t) {
                this.x = t
            },
            get height() {
                return this.y
            },
            set height(t) {
                this.y = t
            },
            set: function(t, e) {
                return this.x = t,
                this.y = e,
                this
            },
            setScalar: function(t) {
                return this.x = t,
                this.y = t,
                this
            },
            setX: function(t) {
                return this.x = t,
                this
            },
            setY: function(t) {
                return this.y = t,
                this
            },
            setComponent: function(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
            },
            getComponent: function(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x,this.y)
            },
            copy: function(t) {
                return this.x = t.x,
                this.y = t.y,
                this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this)
            },
            addScalar: function(t) {
                return this.x += t,
                this.y += t,
                this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this)
            },
            subScalar: function(t) {
                return this.x -= t,
                this.y -= t,
                this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this
            },
            multiply: function(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this
            },
            multiplyScalar: function(t) {
                return isFinite(t) ? (this.x *= t,
                this.y *= t) : (this.x = 0,
                this.y = 0),
                this
            },
            divide: function(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this
            },
            clampScalar: function() {
                var t, e;
                return function(r, n) {
                    return void 0 === t && (t = new i.Vector2,
                    e = new i.Vector2),
                    t.set(r, r),
                    e.set(n, n),
                    this.clamp(t, e)
                }
            }(),
            clampLength: function(t, e) {
                var r = this.length();
                return this.multiplyScalar(Math.max(t, Math.min(e, r)) / r),
                this
            },
            floor: function() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            },
            round: function() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this
            },
            negate: function() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            lengthManhattan: function() {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function() {
                return this.divideScalar(this.length())
            },
            angle: function() {
                var t = Math.atan2(this.y, this.x);
                return t < 0 && (t += 2 * Math.PI),
                t
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x
                  , r = this.y - t.y;
                return e * e + r * r
            },
            setLength: function(t) {
                return this.multiplyScalar(t / this.length())
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this
            },
            lerpVectors: function(t, e, r) {
                return this.subVectors(e, t).multiplyScalar(r).add(t),
                this
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0),
                this.x = t[e],
                this.y = t[e + 1],
                this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []),
                void 0 === e && (e = 0),
                t[e] = this.x,
                t[e + 1] = this.y,
                t
            },
            fromAttribute: function(t, e, r) {
                return void 0 === r && (r = 0),
                e = e * t.itemSize + r,
                this.x = t.array[e],
                this.y = t.array[e + 1],
                this
            },
            rotateAround: function(t, e) {
                var r = Math.cos(e)
                  , i = Math.sin(e)
                  , n = this.x - t.x
                  , o = this.y - t.y;
                return this.x = n * r - o * i + t.x,
                this.y = n * i + o * r + t.y,
                this
            }
        },
        i.Vector3 = function(t, e, r) {
            this.x = t || 0,
            this.y = e || 0,
            this.z = r || 0
        }
        ,
        i.Vector3.prototype = {
            constructor: i.Vector3,
            set: function(t, e, r) {
                return this.x = t,
                this.y = e,
                this.z = r,
                this
            },
            setScalar: function(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this
            },
            setX: function(t) {
                return this.x = t,
                this
            },
            setY: function(t) {
                return this.y = t,
                this
            },
            setZ: function(t) {
                return this.z = t,
                this
            },
            setComponent: function(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
            },
            getComponent: function(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x,this.y,this.z)
            },
            copy: function(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this)
            },
            addScalar: function(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this)
            },
            subScalar: function(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                this.multiplyVectors(t, e)) : (this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this)
            },
            multiplyScalar: function(t) {
                return isFinite(t) ? (this.x *= t,
                this.y *= t,
                this.z *= t) : (this.x = 0,
                this.y = 0,
                this.z = 0),
                this
            },
            multiplyVectors: function(t, e) {
                return this.x = t.x * e.x,
                this.y = t.y * e.y,
                this.z = t.z * e.z,
                this
            },
            applyEuler: function() {
                var t;
                return function(e) {
                    return e instanceof i.Euler == !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                    void 0 === t && (t = new i.Quaternion),
                    this.applyQuaternion(t.setFromEuler(e)),
                    this
                }
            }(),
            applyAxisAngle: function() {
                var t;
                return function(e, r) {
                    return void 0 === t && (t = new i.Quaternion),
                    this.applyQuaternion(t.setFromAxisAngle(e, r)),
                    this
                }
            }(),
            applyMatrix3: function(t) {
                var e = this.x
                  , r = this.y
                  , i = this.z
                  , n = t.elements;
                return this.x = n[0] * e + n[3] * r + n[6] * i,
                this.y = n[1] * e + n[4] * r + n[7] * i,
                this.z = n[2] * e + n[5] * r + n[8] * i,
                this
            },
            applyMatrix4: function(t) {
                var e = this.x
                  , r = this.y
                  , i = this.z
                  , n = t.elements;
                return this.x = n[0] * e + n[4] * r + n[8] * i + n[12],
                this.y = n[1] * e + n[5] * r + n[9] * i + n[13],
                this.z = n[2] * e + n[6] * r + n[10] * i + n[14],
                this
            },
            applyProjection: function(t) {
                var e = this.x
                  , r = this.y
                  , i = this.z
                  , n = t.elements
                  , o = 1 / (n[3] * e + n[7] * r + n[11] * i + n[15]);
                return this.x = (n[0] * e + n[4] * r + n[8] * i + n[12]) * o,
                this.y = (n[1] * e + n[5] * r + n[9] * i + n[13]) * o,
                this.z = (n[2] * e + n[6] * r + n[10] * i + n[14]) * o,
                this
            },
            applyQuaternion: function(t) {
                var e = this.x
                  , r = this.y
                  , i = this.z
                  , n = t.x
                  , o = t.y
                  , a = t.z
                  , s = t.w
                  , h = s * e + o * i - a * r
                  , c = s * r + a * e - n * i
                  , l = s * i + n * r - o * e
                  , u = -n * e - o * r - a * i;
                return this.x = h * s + u * -n + c * -a - l * -o,
                this.y = c * s + u * -o + l * -n - h * -a,
                this.z = l * s + u * -a + h * -o - c * -n,
                this
            },
            project: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)),
                    this.applyProjection(t)
                }
            }(),
            unproject: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)),
                    this.applyProjection(t)
                }
            }(),
            transformDirection: function(t) {
                var e = this.x
                  , r = this.y
                  , i = this.z
                  , n = t.elements;
                return this.x = n[0] * e + n[4] * r + n[8] * i,
                this.y = n[1] * e + n[5] * r + n[9] * i,
                this.z = n[2] * e + n[6] * r + n[10] * i,
                this.normalize(),
                this
            },
            divide: function(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this.z /= t.z,
                this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this
            },
            clampScalar: function() {
                var t, e;
                return function(r, n) {
                    return void 0 === t && (t = new i.Vector3,
                    e = new i.Vector3),
                    t.set(r, r, r),
                    e.set(n, n, n),
                    this.clamp(t, e)
                }
            }(),
            clampLength: function(t, e) {
                var r = this.length();
                return this.multiplyScalar(Math.max(t, Math.min(e, r)) / r),
                this
            },
            floor: function() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            },
            round: function() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this
            },
            negate: function() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            lengthManhattan: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function() {
                return this.divideScalar(this.length())
            },
            setLength: function(t) {
                return this.multiplyScalar(t / this.length())
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this
            },
            lerpVectors: function(t, e, r) {
                return this.subVectors(e, t).multiplyScalar(r).add(t),
                this
            },
            cross: function(t, e) {
                if (void 0 !== e)
                    return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                    this.crossVectors(t, e);
                var r = this.x
                  , i = this.y
                  , n = this.z;
                return this.x = i * t.z - n * t.y,
                this.y = n * t.x - r * t.z,
                this.z = r * t.y - i * t.x,
                this
            },
            crossVectors: function(t, e) {
                var r = t.x
                  , i = t.y
                  , n = t.z
                  , o = e.x
                  , a = e.y
                  , s = e.z;
                return this.x = i * s - n * a,
                this.y = n * o - r * s,
                this.z = r * a - i * o,
                this
            },
            projectOnVector: function() {
                var t, e;
                return function(r) {
                    return void 0 === t && (t = new i.Vector3),
                    t.copy(r).normalize(),
                    e = this.dot(t),
                    this.copy(t).multiplyScalar(e)
                }
            }(),
            projectOnPlane: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Vector3),
                    t.copy(this).projectOnVector(e),
                    this.sub(t)
                }
            }(),
            reflect: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Vector3),
                    this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                }
            }(),
            angleTo: function(t) {
                var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                return Math.acos(i.Math.clamp(e, -1, 1))
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x
                  , r = this.y - t.y
                  , i = this.z - t.z;
                return e * e + r * r + i * i
            },
            setFromMatrixPosition: function(t) {
                return this.x = t.elements[12],
                this.y = t.elements[13],
                this.z = t.elements[14],
                this
            },
            setFromMatrixScale: function(t) {
                var e = this.set(t.elements[0], t.elements[1], t.elements[2]).length()
                  , r = this.set(t.elements[4], t.elements[5], t.elements[6]).length()
                  , i = this.set(t.elements[8], t.elements[9], t.elements[10]).length();
                return this.x = e,
                this.y = r,
                this.z = i,
                this
            },
            setFromMatrixColumn: function(t, e) {
                var r = 4 * t
                  , i = e.elements;
                return this.x = i[r],
                this.y = i[r + 1],
                this.z = i[r + 2],
                this
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0),
                this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []),
                void 0 === e && (e = 0),
                t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t
            },
            fromAttribute: function(t, e, r) {
                return void 0 === r && (r = 0),
                e = e * t.itemSize + r,
                this.x = t.array[e],
                this.y = t.array[e + 1],
                this.z = t.array[e + 2],
                this
            }
        },
        i.Vector4 = function(t, e, r, i) {
            this.x = t || 0,
            this.y = e || 0,
            this.z = r || 0,
            this.w = void 0 !== i ? i : 1
        }
        ,
        i.Vector4.prototype = {
            constructor: i.Vector4,
            set: function(t, e, r, i) {
                return this.x = t,
                this.y = e,
                this.z = r,
                this.w = i,
                this
            },
            setScalar: function(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this.w = t,
                this
            },
            setX: function(t) {
                return this.x = t,
                this
            },
            setY: function(t) {
                return this.y = t,
                this
            },
            setZ: function(t) {
                return this.z = t,
                this
            },
            setW: function(t) {
                return this.w = t,
                this
            },
            setComponent: function(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
            },
            getComponent: function(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            },
            copy: function(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this.w = void 0 !== t.w ? t.w : 1,
                this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this.w += t.w,
                this)
            },
            addScalar: function(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this.w += t,
                this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this.w = t.w + e.w,
                this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this.w += t.w * e,
                this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this.w -= t.w,
                this)
            },
            subScalar: function(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this.w -= t,
                this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this.w = t.w - e.w,
                this
            },
            multiplyScalar: function(t) {
                return isFinite(t) ? (this.x *= t,
                this.y *= t,
                this.z *= t,
                this.w *= t) : (this.x = 0,
                this.y = 0,
                this.z = 0,
                this.w = 0),
                this
            },
            applyMatrix4: function(t) {
                var e = this.x
                  , r = this.y
                  , i = this.z
                  , n = this.w
                  , o = t.elements;
                return this.x = o[0] * e + o[4] * r + o[8] * i + o[12] * n,
                this.y = o[1] * e + o[5] * r + o[9] * i + o[13] * n,
                this.z = o[2] * e + o[6] * r + o[10] * i + o[14] * n,
                this.w = o[3] * e + o[7] * r + o[11] * i + o[15] * n,
                this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            setAxisAngleFromQuaternion: function(t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = t.x / e,
                this.y = t.y / e,
                this.z = t.z / e),
                this
            },
            setAxisAngleFromRotationMatrix: function(t) {
                var e, r, i, n, o = .01, a = .1, s = t.elements, h = s[0], c = s[4], l = s[8], u = s[1], p = s[5], d = s[9], f = s[2], m = s[6], g = s[10];
                if (Math.abs(c - u) < o && Math.abs(l - f) < o && Math.abs(d - m) < o) {
                    if (Math.abs(c + u) < a && Math.abs(l + f) < a && Math.abs(d + m) < a && Math.abs(h + p + g - 3) < a)
                        return this.set(1, 0, 0, 0),
                        this;
                    e = Math.PI;
                    var v = (h + 1) / 2
                      , y = (p + 1) / 2
                      , x = (g + 1) / 2
                      , b = (c + u) / 4
                      , w = (l + f) / 4
                      , _ = (d + m) / 4;
                    return v > y && v > x ? v < o ? (r = 0,
                    i = .707106781,
                    n = .707106781) : (r = Math.sqrt(v),
                    i = b / r,
                    n = w / r) : y > x ? y < o ? (r = .707106781,
                    i = 0,
                    n = .707106781) : (i = Math.sqrt(y),
                    r = b / i,
                    n = _ / i) : x < o ? (r = .707106781,
                    i = .707106781,
                    n = 0) : (n = Math.sqrt(x),
                    r = w / n,
                    i = _ / n),
                    this.set(r, i, n, e),
                    this
                }
                var M = Math.sqrt((m - d) * (m - d) + (l - f) * (l - f) + (u - c) * (u - c));
                return Math.abs(M) < .001 && (M = 1),
                this.x = (m - d) / M,
                this.y = (l - f) / M,
                this.z = (u - c) / M,
                this.w = Math.acos((h + p + g - 1) / 2),
                this
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this.w = Math.min(this.w, t.w),
                this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this.w = Math.max(this.w, t.w),
                this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this.w = Math.max(t.w, Math.min(e.w, this.w)),
                this
            },
            clampScalar: function() {
                var t, e;
                return function(r, n) {
                    return void 0 === t && (t = new i.Vector4,
                    e = new i.Vector4),
                    t.set(r, r, r, r),
                    e.set(n, n, n, n),
                    this.clamp(t, e)
                }
            }(),
            floor: function() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            },
            round: function() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            },
            roundToZero: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                this
            },
            negate: function() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            lengthManhattan: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function() {
                return this.divideScalar(this.length())
            },
            setLength: function(t) {
                return this.multiplyScalar(t / this.length())
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this.w += (t.w - this.w) * e,
                this
            },
            lerpVectors: function(t, e, r) {
                return this.subVectors(e, t).multiplyScalar(r).add(t),
                this
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0),
                this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this.w = t[e + 3],
                this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []),
                void 0 === e && (e = 0),
                t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t[e + 3] = this.w,
                t
            },
            fromAttribute: function(t, e, r) {
                return void 0 === r && (r = 0),
                e = e * t.itemSize + r,
                this.x = t.array[e],
                this.y = t.array[e + 1],
                this.z = t.array[e + 2],
                this.w = t.array[e + 3],
                this
            }
        },
        i.Euler = function(t, e, r, n) {
            this._x = t || 0,
            this._y = e || 0,
            this._z = r || 0,
            this._order = n || i.Euler.DefaultOrder
        }
        ,
        i.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
        i.Euler.DefaultOrder = "XYZ",
        i.Euler.prototype = {
            constructor: i.Euler,
            get x() {
                return this._x
            },
            set x(t) {
                this._x = t,
                this.onChangeCallback()
            },
            get y() {
                return this._y
            },
            set y(t) {
                this._y = t,
                this.onChangeCallback()
            },
            get z() {
                return this._z
            },
            set z(t) {
                this._z = t,
                this.onChangeCallback()
            },
            get order() {
                return this._order
            },
            set order(t) {
                this._order = t,
                this.onChangeCallback()
            },
            set: function(t, e, r, i) {
                return this._x = t,
                this._y = e,
                this._z = r,
                this._order = i || this._order,
                this.onChangeCallback(),
                this
            },
            clone: function() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            },
            copy: function(t) {
                return this._x = t._x,
                this._y = t._y,
                this._z = t._z,
                this._order = t._order,
                this.onChangeCallback(),
                this
            },
            setFromRotationMatrix: function(t, e, r) {
                var n = i.Math.clamp
                  , o = t.elements
                  , a = o[0]
                  , s = o[4]
                  , h = o[8]
                  , c = o[1]
                  , l = o[5]
                  , u = o[9]
                  , p = o[2]
                  , d = o[6]
                  , f = o[10];
                return e = e || this._order,
                "XYZ" === e ? (this._y = Math.asin(n(h, -1, 1)),
                Math.abs(h) < .99999 ? (this._x = Math.atan2(-u, f),
                this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(d, l),
                this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(u, -1, 1)),
                Math.abs(u) < .99999 ? (this._y = Math.atan2(h, f),
                this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-p, a),
                this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(d, -1, 1)),
                Math.abs(d) < .99999 ? (this._y = Math.atan2(-p, f),
                this._z = Math.atan2(-s, l)) : (this._y = 0,
                this._z = Math.atan2(c, a))) : "ZYX" === e ? (this._y = Math.asin(-n(p, -1, 1)),
                Math.abs(p) < .99999 ? (this._x = Math.atan2(d, f),
                this._z = Math.atan2(c, a)) : (this._x = 0,
                this._z = Math.atan2(-s, l))) : "YZX" === e ? (this._z = Math.asin(n(c, -1, 1)),
                Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, l),
                this._y = Math.atan2(-p, a)) : (this._x = 0,
                this._y = Math.atan2(h, f))) : "XZY" === e ? (this._z = Math.asin(-n(s, -1, 1)),
                Math.abs(s) < .99999 ? (this._x = Math.atan2(d, l),
                this._y = Math.atan2(h, a)) : (this._x = Math.atan2(-u, f),
                this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e),
                this._order = e,
                r !== !1 && this.onChangeCallback(),
                this
            },
            setFromQuaternion: function() {
                var t;
                return function(e, r, n) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeRotationFromQuaternion(e),
                    this.setFromRotationMatrix(t, r, n),
                    this
                }
            }(),
            setFromVector3: function(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            },
            reorder: function() {
                var t = new i.Quaternion;
                return function(e) {
                    t.setFromEuler(this),
                    this.setFromQuaternion(t, e)
                }
            }(),
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            },
            fromArray: function(t) {
                return this._x = t[0],
                this._y = t[1],
                this._z = t[2],
                void 0 !== t[3] && (this._order = t[3]),
                this.onChangeCallback(),
                this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []),
                void 0 === e && (e = 0),
                t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._order,
                t
            },
            toVector3: function(t) {
                return t ? t.set(this._x, this._y, this._z) : new i.Vector3(this._x,this._y,this._z)
            },
            onChange: function(t) {
                return this.onChangeCallback = t,
                this
            },
            onChangeCallback: function() {}
        },
        i.Line3 = function(t, e) {
            this.start = void 0 !== t ? t : new i.Vector3,
            this.end = void 0 !== e ? e : new i.Vector3
        }
        ,
        i.Line3.prototype = {
            constructor: i.Line3,
            set: function(t, e) {
                return this.start.copy(t),
                this.end.copy(e),
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.start.copy(t.start),
                this.end.copy(t.end),
                this
            },
            center: function(t) {
                var e = t || new i.Vector3;
                return e.addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function(t) {
                var e = t || new i.Vector3;
                return e.subVectors(this.end, this.start)
            },
            distanceSq: function() {
                return this.start.distanceToSquared(this.end)
            },
            distance: function() {
                return this.start.distanceTo(this.end)
            },
            at: function(t, e) {
                var r = e || new i.Vector3;
                return this.delta(r).multiplyScalar(t).add(this.start)
            },
            closestPointToPointParameter: function() {
                var t = new i.Vector3
                  , e = new i.Vector3;
                return function(r, n) {
                    t.subVectors(r, this.start),
                    e.subVectors(this.end, this.start);
                    var o = e.dot(e)
                      , a = e.dot(t)
                      , s = a / o;
                    return n && (s = i.Math.clamp(s, 0, 1)),
                    s
                }
            }(),
            closestPointToPoint: function(t, e, r) {
                var n = this.closestPointToPointParameter(t, e)
                  , o = r || new i.Vector3;
                return this.delta(o).multiplyScalar(n).add(this.start)
            },
            applyMatrix4: function(t) {
                return this.start.applyMatrix4(t),
                this.end.applyMatrix4(t),
                this
            },
            equals: function(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        },
        i.Box2 = function(t, e) {
            this.min = void 0 !== t ? t : new i.Vector2((+(1 / 0)),(+(1 / 0))),
            this.max = void 0 !== e ? e : new i.Vector2((-(1 / 0)),(-(1 / 0)))
        }
        ,
        i.Box2.prototype = {
            constructor: i.Box2,
            set: function(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, r = t.length; e < r; e++)
                    this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function() {
                var t = new i.Vector2;
                return function(e, r) {
                    var i = t.copy(r).multiplyScalar(.5);
                    return this.min.copy(e).sub(i),
                    this.max.copy(e).add(i),
                    this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = +(1 / 0),
                this.max.x = this.max.y = -(1 / 0),
                this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            center: function(t) {
                var e = t || new i.Vector2;
                return e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            size: function(t) {
                var e = t || new i.Vector2;
                return e.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            },
            expandByVector: function(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            },
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            },
            getParameter: function(t, e) {
                var r = e || new i.Vector2;
                return r.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            },
            clampPoint: function(t, e) {
                var r = e || new i.Vector2;
                return r.copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var t = new i.Vector2;
                return function(e) {
                    var r = t.copy(e).clamp(this.min, this.max);
                    return r.sub(e).length()
                }
            }(),
            intersect: function(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this
            },
            union: function(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            },
            translate: function(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        },
        i.Box3 = function(t, e) {
            this.min = void 0 !== t ? t : new i.Vector3((+(1 / 0)),(+(1 / 0)),(+(1 / 0))),
            this.max = void 0 !== e ? e : new i.Vector3((-(1 / 0)),(-(1 / 0)),(-(1 / 0)))
        }
        ,
        i.Box3.prototype = {
            constructor: i.Box3,
            set: function(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            },
            setFromArray: function(t) {
                this.makeEmpty();
                for (var e = +(1 / 0), r = +(1 / 0), i = +(1 / 0), n = -(1 / 0), o = -(1 / 0), a = -(1 / 0), s = 0, h = t.length; s < h; s += 3) {
                    var c = t[s]
                      , l = t[s + 1]
                      , u = t[s + 2];
                    c < e && (e = c),
                    l < r && (r = l),
                    u < i && (i = u),
                    c > n && (n = c),
                    l > o && (o = l),
                    u > a && (a = u)
                }
                this.min.set(e, r, i),
                this.max.set(n, o, a)
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, r = t.length; e < r; e++)
                    this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function() {
                var t = new i.Vector3;
                return function(e, r) {
                    var i = t.copy(r).multiplyScalar(.5);
                    return this.min.copy(e).sub(i),
                    this.max.copy(e).add(i),
                    this
                }
            }(),
            setFromObject: function() {
                var t;
                return function(e) {
                    void 0 === t && (t = new i.Box3);
                    var r = this;
                    return this.makeEmpty(),
                    e.updateMatrixWorld(!0),
                    e.traverse(function(e) {
                        var i = e.geometry;
                        void 0 !== i && (null === i.boundingBox && i.computeBoundingBox(),
                        t.copy(i.boundingBox),
                        t.applyMatrix4(e.matrixWorld),
                        r.union(t))
                    }),
                    this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = this.min.z = +(1 / 0),
                this.max.x = this.max.y = this.max.z = -(1 / 0),
                this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            center: function(t) {
                var e = t || new i.Vector3;
                return e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            size: function(t) {
                var e = t || new i.Vector3;
                return e.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            },
            expandByVector: function(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            },
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            },
            getParameter: function(t, e) {
                var r = e || new i.Vector3;
                return r.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            },
            intersectsSphere: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Vector3),
                    this.clampPoint(e.center, t),
                    t.distanceToSquared(e.center) <= e.radius * e.radius
                }
            }(),
            intersectsPlane: function(t) {
                var e, r;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                r = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                r = t.normal.x * this.min.x),
                t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                r += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                r += t.normal.y * this.min.y),
                t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                r += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                r += t.normal.z * this.min.z),
                e <= t.constant && r >= t.constant
            },
            clampPoint: function(t, e) {
                var r = e || new i.Vector3;
                return r.copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var t = new i.Vector3;
                return function(e) {
                    var r = t.copy(e).clamp(this.min, this.max);
                    return r.sub(e).length()
                }
            }(),
            getBoundingSphere: function() {
                var t = new i.Vector3;
                return function(e) {
                    var r = e || new i.Sphere;
                    return r.center = this.center(),
                    r.radius = .5 * this.size(t).length(),
                    r
                }
            }(),
            intersect: function(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this
            },
            union: function(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            },
            applyMatrix4: function() {
                var t = [new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3];
                return function(e) {
                    return t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                    t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                    t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                    t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                    t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                    t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                    t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                    t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                    this.makeEmpty(),
                    this.setFromPoints(t),
                    this
                }
            }(),
            translate: function(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        },
        i.Matrix3 = function() {
            this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }
        ,
        i.Matrix3.prototype = {
            constructor: i.Matrix3,
            set: function(t, e, r, i, n, o, a, s, h) {
                var c = this.elements;
                return c[0] = t,
                c[3] = e,
                c[6] = r,
                c[1] = i,
                c[4] = n,
                c[7] = o,
                c[2] = a,
                c[5] = s,
                c[8] = h,
                this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            },
            clone: function() {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function(t) {
                var e = t.elements;
                return this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]),
                this
            },
            applyToVector3Array: function() {
                var t;
                return function(e, r, n) {
                    void 0 === t && (t = new i.Vector3),
                    void 0 === r && (r = 0),
                    void 0 === n && (n = e.length);
                    for (var o = 0, a = r; o < n; o += 3,
                    a += 3)
                        t.fromArray(e, a),
                        t.applyMatrix3(this),
                        t.toArray(e, a);
                    return e
                }
            }(),
            applyToBuffer: function() {
                var t;
                return function(e, r, n) {
                    void 0 === t && (t = new i.Vector3),
                    void 0 === r && (r = 0),
                    void 0 === n && (n = e.length / e.itemSize);
                    for (var o = 0, a = r; o < n; o++,
                    a++)
                        t.x = e.getX(a),
                        t.y = e.getY(a),
                        t.z = e.getZ(a),
                        t.applyMatrix3(this),
                        e.setXYZ(t.x, t.y, t.z);
                    return e
                }
            }(),
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t,
                e[3] *= t,
                e[6] *= t,
                e[1] *= t,
                e[4] *= t,
                e[7] *= t,
                e[2] *= t,
                e[5] *= t,
                e[8] *= t,
                this
            },
            determinant: function() {
                var t = this.elements
                  , e = t[0]
                  , r = t[1]
                  , i = t[2]
                  , n = t[3]
                  , o = t[4]
                  , a = t[5]
                  , s = t[6]
                  , h = t[7]
                  , c = t[8];
                return e * o * c - e * a * h - r * n * c + r * a * s + i * n * h - i * o * s
            },
            getInverse: function(t, e) {
                var r = t.elements
                  , i = this.elements;
                i[0] = r[10] * r[5] - r[6] * r[9],
                i[1] = -r[10] * r[1] + r[2] * r[9],
                i[2] = r[6] * r[1] - r[2] * r[5],
                i[3] = -r[10] * r[4] + r[6] * r[8],
                i[4] = r[10] * r[0] - r[2] * r[8],
                i[5] = -r[6] * r[0] + r[2] * r[4],
                i[6] = r[9] * r[4] - r[5] * r[8],
                i[7] = -r[9] * r[0] + r[1] * r[8],
                i[8] = r[5] * r[0] - r[1] * r[4];
                var n = r[0] * i[0] + r[1] * i[3] + r[2] * i[6];
                if (0 === n) {
                    var o = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                    if (e)
                        throw new Error(o);
                    return console.warn(o),
                    this.identity(),
                    this
                }
                return this.multiplyScalar(1 / n),
                this
            },
            transpose: function() {
                var t, e = this.elements;
                return t = e[1],
                e[1] = e[3],
                e[3] = t,
                t = e[2],
                e[2] = e[6],
                e[6] = t,
                t = e[5],
                e[5] = e[7],
                e[7] = t,
                this
            },
            flattenToArrayOffset: function(t, e) {
                var r = this.elements;
                return t[e] = r[0],
                t[e + 1] = r[1],
                t[e + 2] = r[2],
                t[e + 3] = r[3],
                t[e + 4] = r[4],
                t[e + 5] = r[5],
                t[e + 6] = r[6],
                t[e + 7] = r[7],
                t[e + 8] = r[8],
                t
            },
            getNormalMatrix: function(t) {
                return this.getInverse(t).transpose(),
                this
            },
            transposeIntoArray: function(t) {
                var e = this.elements;
                return t[0] = e[0],
                t[1] = e[3],
                t[2] = e[6],
                t[3] = e[1],
                t[4] = e[4],
                t[5] = e[7],
                t[6] = e[2],
                t[7] = e[5],
                t[8] = e[8],
                this
            },
            fromArray: function(t) {
                return this.elements.set(t),
                this
            },
            toArray: function() {
                var t = this.elements;
                return [t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]]
            }
        },
        i.Matrix4 = function() {
            this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }
        ,
        i.Matrix4.prototype = {
            constructor: i.Matrix4,
            set: function(t, e, r, i, n, o, a, s, h, c, l, u, p, d, f, m) {
                var g = this.elements;
                return g[0] = t,
                g[4] = e,
                g[8] = r,
                g[12] = i,
                g[1] = n,
                g[5] = o,
                g[9] = a,
                g[13] = s,
                g[2] = h,
                g[6] = c,
                g[10] = l,
                g[14] = u,
                g[3] = p,
                g[7] = d,
                g[11] = f,
                g[15] = m,
                this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            },
            clone: function() {
                return (new i.Matrix4).fromArray(this.elements)
            },
            copy: function(t) {
                return this.elements.set(t.elements),
                this
            },
            copyPosition: function(t) {
                var e = this.elements
                  , r = t.elements;
                return e[12] = r[12],
                e[13] = r[13],
                e[14] = r[14],
                this
            },
            extractBasis: function(t, e, r) {
                var i = this.elements;
                return t.set(i[0], i[1], i[2]),
                e.set(i[4], i[5], i[6]),
                r.set(i[8], i[9], i[10]),
                this
            },
            makeBasis: function(t, e, r) {
                return this.set(t.x, e.x, r.x, 0, t.y, e.y, r.y, 0, t.z, e.z, r.z, 0, 0, 0, 0, 1),
                this
            },
            extractRotation: function() {
                var t;
                return function(e) {
                    void 0 === t && (t = new i.Vector3);
                    var r = this.elements
                      , n = e.elements
                      , o = 1 / t.set(n[0], n[1], n[2]).length()
                      , a = 1 / t.set(n[4], n[5], n[6]).length()
                      , s = 1 / t.set(n[8], n[9], n[10]).length();
                    return r[0] = n[0] * o,
                    r[1] = n[1] * o,
                    r[2] = n[2] * o,
                    r[4] = n[4] * a,
                    r[5] = n[5] * a,
                    r[6] = n[6] * a,
                    r[8] = n[8] * s,
                    r[9] = n[9] * s,
                    r[10] = n[10] * s,
                    this
                }
            }(),
            makeRotationFromEuler: function(t) {
                t instanceof i.Euler == !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e = this.elements
                  , r = t.x
                  , n = t.y
                  , o = t.z
                  , a = Math.cos(r)
                  , s = Math.sin(r)
                  , h = Math.cos(n)
                  , c = Math.sin(n)
                  , l = Math.cos(o)
                  , u = Math.sin(o);
                if ("XYZ" === t.order) {
                    var p = a * l
                      , d = a * u
                      , f = s * l
                      , m = s * u;
                    e[0] = h * l,
                    e[4] = -h * u,
                    e[8] = c,
                    e[1] = d + f * c,
                    e[5] = p - m * c,
                    e[9] = -s * h,
                    e[2] = m - p * c,
                    e[6] = f + d * c,
                    e[10] = a * h
                } else if ("YXZ" === t.order) {
                    var g = h * l
                      , v = h * u
                      , y = c * l
                      , x = c * u;
                    e[0] = g + x * s,
                    e[4] = y * s - v,
                    e[8] = a * c,
                    e[1] = a * u,
                    e[5] = a * l,
                    e[9] = -s,
                    e[2] = v * s - y,
                    e[6] = x + g * s,
                    e[10] = a * h
                } else if ("ZXY" === t.order) {
                    var g = h * l
                      , v = h * u
                      , y = c * l
                      , x = c * u;
                    e[0] = g - x * s,
                    e[4] = -a * u,
                    e[8] = y + v * s,
                    e[1] = v + y * s,
                    e[5] = a * l,
                    e[9] = x - g * s,
                    e[2] = -a * c,
                    e[6] = s,
                    e[10] = a * h
                } else if ("ZYX" === t.order) {
                    var p = a * l
                      , d = a * u
                      , f = s * l
                      , m = s * u;
                    e[0] = h * l,
                    e[4] = f * c - d,
                    e[8] = p * c + m,
                    e[1] = h * u,
                    e[5] = m * c + p,
                    e[9] = d * c - f,
                    e[2] = -c,
                    e[6] = s * h,
                    e[10] = a * h
                } else if ("YZX" === t.order) {
                    var b = a * h
                      , w = a * c
                      , _ = s * h
                      , M = s * c;
                    e[0] = h * l,
                    e[4] = M - b * u,
                    e[8] = _ * u + w,
                    e[1] = u,
                    e[5] = a * l,
                    e[9] = -s * l,
                    e[2] = -c * l,
                    e[6] = w * u + _,
                    e[10] = b - M * u
                } else if ("XZY" === t.order) {
                    var b = a * h
                      , w = a * c
                      , _ = s * h
                      , M = s * c;
                    e[0] = h * l,
                    e[4] = -u,
                    e[8] = c * l,
                    e[1] = b * u + M,
                    e[5] = a * l,
                    e[9] = w * u - _,
                    e[2] = _ * u - w,
                    e[6] = s * l,
                    e[10] = M * u + b
                }
                return e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            },
            makeRotationFromQuaternion: function(t) {
                var e = this.elements
                  , r = t.x
                  , i = t.y
                  , n = t.z
                  , o = t.w
                  , a = r + r
                  , s = i + i
                  , h = n + n
                  , c = r * a
                  , l = r * s
                  , u = r * h
                  , p = i * s
                  , d = i * h
                  , f = n * h
                  , m = o * a
                  , g = o * s
                  , v = o * h;
                return e[0] = 1 - (p + f),
                e[4] = l - v,
                e[8] = u + g,
                e[1] = l + v,
                e[5] = 1 - (c + f),
                e[9] = d - m,
                e[2] = u - g,
                e[6] = d + m,
                e[10] = 1 - (c + p),
                e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            },
            lookAt: function() {
                var t, e, r;
                return function(n, o, a) {
                    void 0 === t && (t = new i.Vector3),
                    void 0 === e && (e = new i.Vector3),
                    void 0 === r && (r = new i.Vector3);
                    var s = this.elements;
                    return r.subVectors(n, o).normalize(),
                    0 === r.lengthSq() && (r.z = 1),
                    t.crossVectors(a, r).normalize(),
                    0 === t.lengthSq() && (r.x += 1e-4,
                    t.crossVectors(a, r).normalize()),
                    e.crossVectors(r, t),
                    s[0] = t.x,
                    s[4] = e.x,
                    s[8] = r.x,
                    s[1] = t.y,
                    s[5] = e.y,
                    s[9] = r.y,
                    s[2] = t.z,
                    s[6] = e.z,
                    s[10] = r.z,
                    this
                }
            }(),
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            },
            multiplyMatrices: function(t, e) {
                var r = t.elements
                  , i = e.elements
                  , n = this.elements
                  , o = r[0]
                  , a = r[4]
                  , s = r[8]
                  , h = r[12]
                  , c = r[1]
                  , l = r[5]
                  , u = r[9]
                  , p = r[13]
                  , d = r[2]
                  , f = r[6]
                  , m = r[10]
                  , g = r[14]
                  , v = r[3]
                  , y = r[7]
                  , x = r[11]
                  , b = r[15]
                  , w = i[0]
                  , _ = i[4]
                  , M = i[8]
                  , S = i[12]
                  , E = i[1]
                  , T = i[5]
                  , A = i[9]
                  , L = i[13]
                  , C = i[2]
                  , R = i[6]
                  , P = i[10]
                  , U = i[14]
                  , I = i[3]
                  , D = i[7]
                  , O = i[11]
                  , N = i[15];
                return n[0] = o * w + a * E + s * C + h * I,
                n[4] = o * _ + a * T + s * R + h * D,
                n[8] = o * M + a * A + s * P + h * O,
                n[12] = o * S + a * L + s * U + h * N,
                n[1] = c * w + l * E + u * C + p * I,
                n[5] = c * _ + l * T + u * R + p * D,
                n[9] = c * M + l * A + u * P + p * O,
                n[13] = c * S + l * L + u * U + p * N,
                n[2] = d * w + f * E + m * C + g * I,
                n[6] = d * _ + f * T + m * R + g * D,
                n[10] = d * M + f * A + m * P + g * O,
                n[14] = d * S + f * L + m * U + g * N,
                n[3] = v * w + y * E + x * C + b * I,
                n[7] = v * _ + y * T + x * R + b * D,
                n[11] = v * M + y * A + x * P + b * O,
                n[15] = v * S + y * L + x * U + b * N,
                this
            },
            multiplyToArray: function(t, e, r) {
                var i = this.elements;
                return this.multiplyMatrices(t, e),
                r[0] = i[0],
                r[1] = i[1],
                r[2] = i[2],
                r[3] = i[3],
                r[4] = i[4],
                r[5] = i[5],
                r[6] = i[6],
                r[7] = i[7],
                r[8] = i[8],
                r[9] = i[9],
                r[10] = i[10],
                r[11] = i[11],
                r[12] = i[12],
                r[13] = i[13],
                r[14] = i[14],
                r[15] = i[15],
                this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t,
                e[4] *= t,
                e[8] *= t,
                e[12] *= t,
                e[1] *= t,
                e[5] *= t,
                e[9] *= t,
                e[13] *= t,
                e[2] *= t,
                e[6] *= t,
                e[10] *= t,
                e[14] *= t,
                e[3] *= t,
                e[7] *= t,
                e[11] *= t,
                e[15] *= t,
                this
            },
            applyToVector3Array: function() {
                var t;
                return function(e, r, n) {
                    void 0 === t && (t = new i.Vector3),
                    void 0 === r && (r = 0),
                    void 0 === n && (n = e.length);
                    for (var o = 0, a = r; o < n; o += 3,
                    a += 3)
                        t.fromArray(e, a),
                        t.applyMatrix4(this),
                        t.toArray(e, a);
                    return e
                }
            }(),
            applyToBuffer: function() {
                var t;
                return function(e, r, n) {
                    void 0 === t && (t = new i.Vector3),
                    void 0 === r && (r = 0),
                    void 0 === n && (n = e.length / e.itemSize);
                    for (var o = 0, a = r; o < n; o++,
                    a++)
                        t.x = e.getX(a),
                        t.y = e.getY(a),
                        t.z = e.getZ(a),
                        t.applyMatrix4(this),
                        e.setXYZ(t.x, t.y, t.z);
                    return e
                }
            }(),
            determinant: function() {
                var t = this.elements
                  , e = t[0]
                  , r = t[4]
                  , i = t[8]
                  , n = t[12]
                  , o = t[1]
                  , a = t[5]
                  , s = t[9]
                  , h = t[13]
                  , c = t[2]
                  , l = t[6]
                  , u = t[10]
                  , p = t[14]
                  , d = t[3]
                  , f = t[7]
                  , m = t[11]
                  , g = t[15];
                return d * (+n * s * l - i * h * l - n * a * u + r * h * u + i * a * p - r * s * p) + f * (+e * s * p - e * h * u + n * o * u - i * o * p + i * h * c - n * s * c) + m * (+e * h * l - e * a * p - n * o * l + r * o * p + n * a * c - r * h * c) + g * (-i * a * c - e * s * l + e * a * u + i * o * l - r * o * u + r * s * c)
            },
            transpose: function() {
                var t, e = this.elements;
                return t = e[1],
                e[1] = e[4],
                e[4] = t,
                t = e[2],
                e[2] = e[8],
                e[8] = t,
                t = e[6],
                e[6] = e[9],
                e[9] = t,
                t = e[3],
                e[3] = e[12],
                e[12] = t,
                t = e[7],
                e[7] = e[13],
                e[13] = t,
                t = e[11],
                e[11] = e[14],
                e[14] = t,
                this
            },
            flattenToArrayOffset: function(t, e) {
                var r = this.elements;
                return t[e] = r[0],
                t[e + 1] = r[1],
                t[e + 2] = r[2],
                t[e + 3] = r[3],
                t[e + 4] = r[4],
                t[e + 5] = r[5],
                t[e + 6] = r[6],
                t[e + 7] = r[7],
                t[e + 8] = r[8],
                t[e + 9] = r[9],
                t[e + 10] = r[10],
                t[e + 11] = r[11],
                t[e + 12] = r[12],
                t[e + 13] = r[13],
                t[e + 14] = r[14],
                t[e + 15] = r[15],
                t
            },
            getPosition: function() {
                var t;
                return function() {
                    void 0 === t && (t = new i.Vector3),
                    console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                    var e = this.elements;
                    return t.set(e[12], e[13], e[14])
                }
            }(),
            setPosition: function(t) {
                var e = this.elements;
                return e[12] = t.x,
                e[13] = t.y,
                e[14] = t.z,
                this
            },
            getInverse: function(t, e) {
                var r = this.elements
                  , i = t.elements
                  , n = i[0]
                  , o = i[4]
                  , a = i[8]
                  , s = i[12]
                  , h = i[1]
                  , c = i[5]
                  , l = i[9]
                  , u = i[13]
                  , p = i[2]
                  , d = i[6]
                  , f = i[10]
                  , m = i[14]
                  , g = i[3]
                  , v = i[7]
                  , y = i[11]
                  , x = i[15];
                r[0] = l * m * v - u * f * v + u * d * y - c * m * y - l * d * x + c * f * x,
                r[4] = s * f * v - a * m * v - s * d * y + o * m * y + a * d * x - o * f * x,
                r[8] = a * u * v - s * l * v + s * c * y - o * u * y - a * c * x + o * l * x,
                r[12] = s * l * d - a * u * d - s * c * f + o * u * f + a * c * m - o * l * m,
                r[1] = u * f * g - l * m * g - u * p * y + h * m * y + l * p * x - h * f * x,
                r[5] = a * m * g - s * f * g + s * p * y - n * m * y - a * p * x + n * f * x,
                r[9] = s * l * g - a * u * g - s * h * y + n * u * y + a * h * x - n * l * x,
                r[13] = a * u * p - s * l * p + s * h * f - n * u * f - a * h * m + n * l * m,
                r[2] = c * m * g - u * d * g + u * p * v - h * m * v - c * p * x + h * d * x,
                r[6] = s * d * g - o * m * g - s * p * v + n * m * v + o * p * x - n * d * x,
                r[10] = o * u * g - s * c * g + s * h * v - n * u * v - o * h * x + n * c * x,
                r[14] = s * c * p - o * u * p - s * h * d + n * u * d + o * h * m - n * c * m,
                r[3] = l * d * g - c * f * g - l * p * v + h * f * v + c * p * y - h * d * y,
                r[7] = o * f * g - a * d * g + a * p * v - n * f * v - o * p * y + n * d * y,
                r[11] = a * c * g - o * l * g - a * h * v + n * l * v + o * h * y - n * c * y,
                r[15] = o * l * p - a * c * p + a * h * d - n * l * d - o * h * f + n * c * f;
                var b = n * r[0] + h * r[4] + p * r[8] + g * r[12];
                if (0 === b) {
                    var w = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                    if (e)
                        throw new Error(w);
                    return console.warn(w),
                    this.identity(),
                    this
                }
                return this.multiplyScalar(1 / b),
                this
            },
            scale: function(t) {
                var e = this.elements
                  , r = t.x
                  , i = t.y
                  , n = t.z;
                return e[0] *= r,
                e[4] *= i,
                e[8] *= n,
                e[1] *= r,
                e[5] *= i,
                e[9] *= n,
                e[2] *= r,
                e[6] *= i,
                e[10] *= n,
                e[3] *= r,
                e[7] *= i,
                e[11] *= n,
                this
            },
            getMaxScaleOnAxis: function() {
                var t = this.elements
                  , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                  , r = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                  , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, r, i))
            },
            makeTranslation: function(t, e, r) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, r, 0, 0, 0, 1),
                this
            },
            makeRotationX: function(t) {
                var e = Math.cos(t)
                  , r = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -r, 0, 0, r, e, 0, 0, 0, 0, 1),
                this
            },
            makeRotationY: function(t) {
                var e = Math.cos(t)
                  , r = Math.sin(t);
                return this.set(e, 0, r, 0, 0, 1, 0, 0, -r, 0, e, 0, 0, 0, 0, 1),
                this
            },
            makeRotationZ: function(t) {
                var e = Math.cos(t)
                  , r = Math.sin(t);
                return this.set(e, -r, 0, 0, r, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            },
            makeRotationAxis: function(t, e) {
                var r = Math.cos(e)
                  , i = Math.sin(e)
                  , n = 1 - r
                  , o = t.x
                  , a = t.y
                  , s = t.z
                  , h = n * o
                  , c = n * a;
                return this.set(h * o + r, h * a - i * s, h * s + i * a, 0, h * a + i * s, c * a + r, c * s - i * o, 0, h * s - i * a, c * s + i * o, n * s * s + r, 0, 0, 0, 0, 1),
                this
            },
            makeScale: function(t, e, r) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
                this
            },
            compose: function(t, e, r) {
                return this.makeRotationFromQuaternion(e),
                this.scale(r),
                this.setPosition(t),
                this
            },
            decompose: function() {
                var t, e;
                return function(r, n, o) {
                    void 0 === t && (t = new i.Vector3),
                    void 0 === e && (e = new i.Matrix4);
                    var a = this.elements
                      , s = t.set(a[0], a[1], a[2]).length()
                      , h = t.set(a[4], a[5], a[6]).length()
                      , c = t.set(a[8], a[9], a[10]).length()
                      , l = this.determinant();
                    l < 0 && (s = -s),
                    r.x = a[12],
                    r.y = a[13],
                    r.z = a[14],
                    e.elements.set(this.elements);
                    var u = 1 / s
                      , p = 1 / h
                      , d = 1 / c;
                    return e.elements[0] *= u,
                    e.elements[1] *= u,
                    e.elements[2] *= u,
                    e.elements[4] *= p,
                    e.elements[5] *= p,
                    e.elements[6] *= p,
                    e.elements[8] *= d,
                    e.elements[9] *= d,
                    e.elements[10] *= d,
                    n.setFromRotationMatrix(e),
                    o.x = s,
                    o.y = h,
                    o.z = c,
                    this
                }
            }(),
            makeFrustum: function(t, e, r, i, n, o) {
                var a = this.elements
                  , s = 2 * n / (e - t)
                  , h = 2 * n / (i - r)
                  , c = (e + t) / (e - t)
                  , l = (i + r) / (i - r)
                  , u = -(o + n) / (o - n)
                  , p = -2 * o * n / (o - n);
                return a[0] = s,
                a[4] = 0,
                a[8] = c,
                a[12] = 0,
                a[1] = 0,
                a[5] = h,
                a[9] = l,
                a[13] = 0,
                a[2] = 0,
                a[6] = 0,
                a[10] = u,
                a[14] = p,
                a[3] = 0,
                a[7] = 0,
                a[11] = -1,
                a[15] = 0,
                this
            },
            makePerspective: function(t, e, r, n) {
                var o = r * Math.tan(i.Math.degToRad(.5 * t))
                  , a = -o
                  , s = a * e
                  , h = o * e;
                return this.makeFrustum(s, h, a, o, r, n)
            },
            makeOrthographic: function(t, e, r, i, n, o) {
                var a = this.elements
                  , s = e - t
                  , h = r - i
                  , c = o - n
                  , l = (e + t) / s
                  , u = (r + i) / h
                  , p = (o + n) / c;
                return a[0] = 2 / s,
                a[4] = 0,
                a[8] = 0,
                a[12] = -l,
                a[1] = 0,
                a[5] = 2 / h,
                a[9] = 0,
                a[13] = -u,
                a[2] = 0,
                a[6] = 0,
                a[10] = -2 / c,
                a[14] = -p,
                a[3] = 0,
                a[7] = 0,
                a[11] = 0,
                a[15] = 1,
                this
            },
            equals: function(t) {
                for (var e = this.elements, r = t.elements, i = 0; i < 16; i++)
                    if (e[i] !== r[i])
                        return !1;
                return !0
            },
            fromArray: function(t) {
                return this.elements.set(t),
                this
            },
            toArray: function() {
                var t = this.elements;
                return [t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]]
            }
        },
        i.Ray = function(t, e) {
            this.origin = void 0 !== t ? t : new i.Vector3,
            this.direction = void 0 !== e ? e : new i.Vector3
        }
        ,
        i.Ray.prototype = {
            constructor: i.Ray,
            set: function(t, e) {
                return this.origin.copy(t),
                this.direction.copy(e),
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.origin.copy(t.origin),
                this.direction.copy(t.direction),
                this
            },
            at: function(t, e) {
                var r = e || new i.Vector3;
                return r.copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            lookAt: function(t) {
                this.direction.copy(t).sub(this.origin).normalize()
            },
            recast: function() {
                var t = new i.Vector3;
                return function(e) {
                    return this.origin.copy(this.at(e, t)),
                    this
                }
            }(),
            closestPointToPoint: function(t, e) {
                var r = e || new i.Vector3;
                r.subVectors(t, this.origin);
                var n = r.dot(this.direction);
                return n < 0 ? r.copy(this.origin) : r.copy(this.direction).multiplyScalar(n).add(this.origin)
            },
            distanceToPoint: function(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            },
            distanceSqToPoint: function() {
                var t = new i.Vector3;
                return function(e) {
                    var r = t.subVectors(e, this.origin).dot(this.direction);
                    return r < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(r).add(this.origin),
                    t.distanceToSquared(e))
                }
            }(),
            distanceSqToSegment: function() {
                var t = new i.Vector3
                  , e = new i.Vector3
                  , r = new i.Vector3;
                return function(i, n, o, a) {
                    t.copy(i).add(n).multiplyScalar(.5),
                    e.copy(n).sub(i).normalize(),
                    r.copy(this.origin).sub(t);
                    var s, h, c, l, u = .5 * i.distanceTo(n), p = -this.direction.dot(e), d = r.dot(this.direction), f = -r.dot(e), m = r.lengthSq(), g = Math.abs(1 - p * p);
                    if (g > 0)
                        if (s = p * f - d,
                        h = p * d - f,
                        l = u * g,
                        s >= 0)
                            if (h >= -l)
                                if (h <= l) {
                                    var v = 1 / g;
                                    s *= v,
                                    h *= v,
                                    c = s * (s + p * h + 2 * d) + h * (p * s + h + 2 * f) + m
                                } else
                                    h = u,
                                    s = Math.max(0, -(p * h + d)),
                                    c = -s * s + h * (h + 2 * f) + m;
                            else
                                h = -u,
                                s = Math.max(0, -(p * h + d)),
                                c = -s * s + h * (h + 2 * f) + m;
                        else
                            h <= -l ? (s = Math.max(0, -(-p * u + d)),
                            h = s > 0 ? -u : Math.min(Math.max(-u, -f), u),
                            c = -s * s + h * (h + 2 * f) + m) : h <= l ? (s = 0,
                            h = Math.min(Math.max(-u, -f), u),
                            c = h * (h + 2 * f) + m) : (s = Math.max(0, -(p * u + d)),
                            h = s > 0 ? u : Math.min(Math.max(-u, -f), u),
                            c = -s * s + h * (h + 2 * f) + m);
                    else
                        h = p > 0 ? -u : u,
                        s = Math.max(0, -(p * h + d)),
                        c = -s * s + h * (h + 2 * f) + m;
                    return o && o.copy(this.direction).multiplyScalar(s).add(this.origin),
                    a && a.copy(e).multiplyScalar(h).add(t),
                    c
                }
            }(),
            intersectSphere: function() {
                var t = new i.Vector3;
                return function(e, r) {
                    t.subVectors(e.center, this.origin);
                    var i = t.dot(this.direction)
                      , n = t.dot(t) - i * i
                      , o = e.radius * e.radius;
                    if (n > o)
                        return null;
                    var a = Math.sqrt(o - n)
                      , s = i - a
                      , h = i + a;
                    return s < 0 && h < 0 ? null : s < 0 ? this.at(h, r) : this.at(s, r)
                }
            }(),
            intersectsSphere: function(t) {
                return this.distanceToPoint(t.center) <= t.radius
            },
            distanceToPlane: function(t) {
                var e = t.normal.dot(this.direction);
                if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                var r = -(this.origin.dot(t.normal) + t.constant) / e;
                return r >= 0 ? r : null
            },
            intersectPlane: function(t, e) {
                var r = this.distanceToPlane(t);
                return null === r ? null : this.at(r, e)
            },
            intersectsPlane: function(t) {
                var e = t.distanceToPoint(this.origin);
                if (0 === e)
                    return !0;
                var r = t.normal.dot(this.direction);
                return r * e < 0
            },
            intersectBox: function(t, e) {
                var r, i, n, o, a, s, h = 1 / this.direction.x, c = 1 / this.direction.y, l = 1 / this.direction.z, u = this.origin;
                return h >= 0 ? (r = (t.min.x - u.x) * h,
                i = (t.max.x - u.x) * h) : (r = (t.max.x - u.x) * h,
                i = (t.min.x - u.x) * h),
                c >= 0 ? (n = (t.min.y - u.y) * c,
                o = (t.max.y - u.y) * c) : (n = (t.max.y - u.y) * c,
                o = (t.min.y - u.y) * c),
                r > o || n > i ? null : ((n > r || r !== r) && (r = n),
                (o < i || i !== i) && (i = o),
                l >= 0 ? (a = (t.min.z - u.z) * l,
                s = (t.max.z - u.z) * l) : (a = (t.max.z - u.z) * l,
                s = (t.min.z - u.z) * l),
                r > s || a > i ? null : ((a > r || r !== r) && (r = a),
                (s < i || i !== i) && (i = s),
                i < 0 ? null : this.at(r >= 0 ? r : i, e)))
            },
            intersectsBox: function() {
                var t = new i.Vector3;
                return function(e) {
                    return null !== this.intersectBox(e, t)
                }
            }(),
            intersectTriangle: function() {
                var t = new i.Vector3
                  , e = new i.Vector3
                  , r = new i.Vector3
                  , n = new i.Vector3;
                return function(i, o, a, s, h) {
                    e.subVectors(o, i),
                    r.subVectors(a, i),
                    n.crossVectors(e, r);
                    var c, l = this.direction.dot(n);
                    if (l > 0) {
                        if (s)
                            return null;
                        c = 1
                    } else {
                        if (!(l < 0))
                            return null;
                        c = -1,
                        l = -l
                    }
                    t.subVectors(this.origin, i);
                    var u = c * this.direction.dot(r.crossVectors(t, r));
                    if (u < 0)
                        return null;
                    var p = c * this.direction.dot(e.cross(t));
                    if (p < 0)
                        return null;
                    if (u + p > l)
                        return null;
                    var d = -c * t.dot(n);
                    return d < 0 ? null : this.at(d / l, h)
                }
            }(),
            applyMatrix4: function(t) {
                return this.direction.add(this.origin).applyMatrix4(t),
                this.origin.applyMatrix4(t),
                this.direction.sub(this.origin),
                this.direction.normalize(),
                this
            },
            equals: function(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        },
        i.Sphere = function(t, e) {
            this.center = void 0 !== t ? t : new i.Vector3,
            this.radius = void 0 !== e ? e : 0
        }
        ,
        i.Sphere.prototype = {
            constructor: i.Sphere,
            set: function(t, e) {
                return this.center.copy(t),
                this.radius = e,
                this
            },
            setFromPoints: function() {
                var t = new i.Box3;
                return function(e, r) {
                    var i = this.center;
                    void 0 !== r ? i.copy(r) : t.setFromPoints(e).center(i);
                    for (var n = 0, o = 0, a = e.length; o < a; o++)
                        n = Math.max(n, i.distanceToSquared(e[o]));
                    return this.radius = Math.sqrt(n),
                    this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.center.copy(t.center),
                this.radius = t.radius,
                this
            },
            empty: function() {
                return this.radius <= 0
            },
            containsPoint: function(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function(t) {
                return t.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function(t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            },
            intersectsBox: function(t) {
                return t.intersectsSphere(this)
            },
            intersectsPlane: function(t) {
                return Math.abs(this.center.dot(t.normal) - t.constant) <= this.radius
            },
            clampPoint: function(t, e) {
                var r = this.center.distanceToSquared(t)
                  , n = e || new i.Vector3;
                return n.copy(t),
                r > this.radius * this.radius && (n.sub(this.center).normalize(),
                n.multiplyScalar(this.radius).add(this.center)),
                n
            },
            getBoundingBox: function(t) {
                var e = t || new i.Box3;
                return e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e
            },
            applyMatrix4: function(t) {
                return this.center.applyMatrix4(t),
                this.radius = this.radius * t.getMaxScaleOnAxis(),
                this
            },
            translate: function(t) {
                return this.center.add(t),
                this
            },
            equals: function(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        },
        i.Frustum = function(t, e, r, n, o, a) {
            this.planes = [void 0 !== t ? t : new i.Plane, void 0 !== e ? e : new i.Plane, void 0 !== r ? r : new i.Plane, void 0 !== n ? n : new i.Plane, void 0 !== o ? o : new i.Plane, void 0 !== a ? a : new i.Plane]
        }
        ,
        i.Frustum.prototype = {
            constructor: i.Frustum,
            set: function(t, e, r, i, n, o) {
                var a = this.planes;
                return a[0].copy(t),
                a[1].copy(e),
                a[2].copy(r),
                a[3].copy(i),
                a[4].copy(n),
                a[5].copy(o),
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                for (var e = this.planes, r = 0; r < 6; r++)
                    e[r].copy(t.planes[r]);
                return this
            },
            setFromMatrix: function(t) {
                var e = this.planes
                  , r = t.elements
                  , i = r[0]
                  , n = r[1]
                  , o = r[2]
                  , a = r[3]
                  , s = r[4]
                  , h = r[5]
                  , c = r[6]
                  , l = r[7]
                  , u = r[8]
                  , p = r[9]
                  , d = r[10]
                  , f = r[11]
                  , m = r[12]
                  , g = r[13]
                  , v = r[14]
                  , y = r[15];
                return e[0].setComponents(a - i, l - s, f - u, y - m).normalize(),
                e[1].setComponents(a + i, l + s, f + u, y + m).normalize(),
                e[2].setComponents(a + n, l + h, f + p, y + g).normalize(),
                e[3].setComponents(a - n, l - h, f - p, y - g).normalize(),
                e[4].setComponents(a - o, l - c, f - d, y - v).normalize(),
                e[5].setComponents(a + o, l + c, f + d, y + v).normalize(),
                this
            },
            intersectsObject: function() {
                var t = new i.Sphere;
                return function(e) {
                    var r = e.geometry;
                    return null === r.boundingSphere && r.computeBoundingSphere(),
                    t.copy(r.boundingSphere),
                    t.applyMatrix4(e.matrixWorld),
                    this.intersectsSphere(t)
                }
            }(),
            intersectsSphere: function(t) {
                for (var e = this.planes, r = t.center, i = -t.radius, n = 0; n < 6; n++) {
                    var o = e[n].distanceToPoint(r);
                    if (o < i)
                        return !1
                }
                return !0
            },
            intersectsBox: function() {
                var t = new i.Vector3
                  , e = new i.Vector3;
                return function(r) {
                    for (var i = this.planes, n = 0; n < 6; n++) {
                        var o = i[n];
                        t.x = o.normal.x > 0 ? r.min.x : r.max.x,
                        e.x = o.normal.x > 0 ? r.max.x : r.min.x,
                        t.y = o.normal.y > 0 ? r.min.y : r.max.y,
                        e.y = o.normal.y > 0 ? r.max.y : r.min.y,
                        t.z = o.normal.z > 0 ? r.min.z : r.max.z,
                        e.z = o.normal.z > 0 ? r.max.z : r.min.z;
                        var a = o.distanceToPoint(t)
                          , s = o.distanceToPoint(e);
                        if (a < 0 && s < 0)
                            return !1
                    }
                    return !0
                }
            }(),
            containsPoint: function(t) {
                for (var e = this.planes, r = 0; r < 6; r++)
                    if (e[r].distanceToPoint(t) < 0)
                        return !1;
                return !0
            }
        },
        i.Plane = function(t, e) {
            this.normal = void 0 !== t ? t : new i.Vector3(1,0,0),
            this.constant = void 0 !== e ? e : 0
        }
        ,
        i.Plane.prototype = {
            constructor: i.Plane,
            set: function(t, e) {
                return this.normal.copy(t),
                this.constant = e,
                this
            },
            setComponents: function(t, e, r, i) {
                return this.normal.set(t, e, r),
                this.constant = i,
                this
            },
            setFromNormalAndCoplanarPoint: function(t, e) {
                return this.normal.copy(t),
                this.constant = -e.dot(this.normal),
                this
            },
            setFromCoplanarPoints: function() {
                var t = new i.Vector3
                  , e = new i.Vector3;
                return function(r, i, n) {
                    var o = t.subVectors(n, i).cross(e.subVectors(r, i)).normalize();
                    return this.setFromNormalAndCoplanarPoint(o, r),
                    this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.normal.copy(t.normal),
                this.constant = t.constant,
                this
            },
            normalize: function() {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t),
                this.constant *= t,
                this
            },
            negate: function() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            },
            distanceToPoint: function(t) {
                return this.normal.dot(t) + this.constant
            },
            distanceToSphere: function(t) {
                return this.distanceToPoint(t.center) - t.radius
            },
            projectPoint: function(t, e) {
                return this.orthoPoint(t, e).sub(t).negate()
            },
            orthoPoint: function(t, e) {
                var r = this.distanceToPoint(t)
                  , n = e || new i.Vector3;
                return n.copy(this.normal).multiplyScalar(r)
            },
            intersectLine: function() {
                var t = new i.Vector3;
                return function(e, r) {
                    var n = r || new i.Vector3
                      , o = e.delta(t)
                      , a = this.normal.dot(o);
                    if (0 !== a) {
                        var s = -(e.start.dot(this.normal) + this.constant) / a;
                        if (!(s < 0 || s > 1))
                            return n.copy(o).multiplyScalar(s).add(e.start)
                    } else if (0 === this.distanceToPoint(e.start))
                        return n.copy(e.start)
                }
            }(),
            intersectsLine: function(t) {
                var e = this.distanceToPoint(t.start)
                  , r = this.distanceToPoint(t.end);
                return e < 0 && r > 0 || r < 0 && e > 0
            },
            intersectsBox: function(t) {
                return t.intersectsPlane(this)
            },
            intersectsSphere: function(t) {
                return t.intersectsPlane(this)
            },
            coplanarPoint: function(t) {
                var e = t || new i.Vector3;
                return e.copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: function() {
                var t = new i.Vector3
                  , e = new i.Vector3
                  , r = new i.Matrix3;
                return function(i, n) {
                    var o = n || r.getNormalMatrix(i)
                      , a = t.copy(this.normal).applyMatrix3(o)
                      , s = this.coplanarPoint(e);
                    return s.applyMatrix4(i),
                    this.setFromNormalAndCoplanarPoint(a, s),
                    this
                }
            }(),
            translate: function(t) {
                return this.constant = this.constant - t.dot(this.normal),
                this
            },
            equals: function(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        },
        i.Math = {
            generateUUID: function() {
                var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), r = new Array(36), i = 0;
                return function() {
                    for (var n = 0; n < 36; n++)
                        8 === n || 13 === n || 18 === n || 23 === n ? r[n] = "-" : 14 === n ? r[n] = "4" : (i <= 2 && (i = 33554432 + 16777216 * Math.random() | 0),
                        t = 15 & i,
                        i >>= 4,
                        r[n] = e[19 === n ? 3 & t | 8 : t]);
                    return r.join("")
                }
            }(),
            clamp: function(t, e, r) {
                return Math.max(e, Math.min(r, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, r, i, n) {
                return i + (t - e) * (n - i) / (r - e)
            },
            smoothstep: function(t, e, r) {
                return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e),
                t * t * (3 - 2 * t))
            },
            smootherstep: function(t, e, r) {
                return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e),
                t * t * t * (t * (6 * t - 15) + 10))
            },
            random16: function() {
                return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."),
                Math.random()
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            degToRad: function() {
                var t = Math.PI / 180;
                return function(e) {
                    return e * t
                }
            }(),
            radToDeg: function() {
                var t = 180 / Math.PI;
                return function(e) {
                    return e * t
                }
            }(),
            isPowerOfTwo: function(t) {
                return 0 === (t & t - 1) && 0 !== t
            },
            nearestPowerOfTwo: function(t) {
                return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
            },
            nextPowerOfTwo: function(t) {
                return t--,
                t |= t >> 1,
                t |= t >> 2,
                t |= t >> 4,
                t |= t >> 8,
                t |= t >> 16,
                t++,
                t
            }
        },
        i.Spline = function(t) {
            function e(t, e, r, i, n, o, a) {
                var s = .5 * (r - t)
                  , h = .5 * (i - e);
                return (2 * (e - r) + s + h) * a + (-3 * (e - r) - 2 * s - h) * o + s * n + e
            }
            this.points = t;
            var r, n, o, a, s, h, c, l, u, p = [], d = {
                x: 0,
                y: 0,
                z: 0
            };
            this.initFromArray = function(t) {
                this.points = [];
                for (var e = 0; e < t.length; e++)
                    this.points[e] = {
                        x: t[e][0],
                        y: t[e][1],
                        z: t[e][2]
                    }
            }
            ,
            this.getPoint = function(t) {
                return r = (this.points.length - 1) * t,
                n = Math.floor(r),
                o = r - n,
                p[0] = 0 === n ? n : n - 1,
                p[1] = n,
                p[2] = n > this.points.length - 2 ? this.points.length - 1 : n + 1,
                p[3] = n > this.points.length - 3 ? this.points.length - 1 : n + 2,
                h = this.points[p[0]],
                c = this.points[p[1]],
                l = this.points[p[2]],
                u = this.points[p[3]],
                a = o * o,
                s = o * a,
                d.x = e(h.x, c.x, l.x, u.x, o, a, s),
                d.y = e(h.y, c.y, l.y, u.y, o, a, s),
                d.z = e(h.z, c.z, l.z, u.z, o, a, s),
                d
            }
            ,
            this.getControlPointsArray = function() {
                var t, e, r = this.points.length, i = [];
                for (t = 0; t < r; t++)
                    e = this.points[t],
                    i[t] = [e.x, e.y, e.z];
                return i
            }
            ,
            this.getLength = function(t) {
                var e, r, n, o, a = 0, s = 0, h = 0, c = new i.Vector3, l = new i.Vector3, u = [], p = 0;
                for (u[0] = 0,
                t || (t = 100),
                n = this.points.length * t,
                c.copy(this.points[0]),
                e = 1; e < n; e++)
                    r = e / n,
                    o = this.getPoint(r),
                    l.copy(o),
                    p += l.distanceTo(c),
                    c.copy(o),
                    a = (this.points.length - 1) * r,
                    s = Math.floor(a),
                    s !== h && (u[s] = p,
                    h = s);
                return u[u.length] = p,
                {
                    chunks: u,
                    total: p
                }
            }
            ,
            this.reparametrizeByArcLength = function(t) {
                var e, r, n, o, a, s, h, c, l = [], u = new i.Vector3, p = this.getLength();
                for (l.push(u.copy(this.points[0]).clone()),
                e = 1; e < this.points.length; e++) {
                    for (s = p.chunks[e] - p.chunks[e - 1],
                    h = Math.ceil(t * s / p.total),
                    o = (e - 1) / (this.points.length - 1),
                    a = e / (this.points.length - 1),
                    r = 1; r < h - 1; r++)
                        n = o + r * (1 / h) * (a - o),
                        c = this.getPoint(n),
                        l.push(u.copy(c).clone());
                    l.push(u.copy(this.points[e]).clone())
                }
                this.points = l
            }
        }
        ,
        i.Triangle = function(t, e, r) {
            this.a = void 0 !== t ? t : new i.Vector3,
            this.b = void 0 !== e ? e : new i.Vector3,
            this.c = void 0 !== r ? r : new i.Vector3
        }
        ,
        i.Triangle.normal = function() {
            var t = new i.Vector3;
            return function(e, r, n, o) {
                var a = o || new i.Vector3;
                a.subVectors(n, r),
                t.subVectors(e, r),
                a.cross(t);
                var s = a.lengthSq();
                return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0)
            }
        }(),
        i.Triangle.barycoordFromPoint = function() {
            var t = new i.Vector3
              , e = new i.Vector3
              , r = new i.Vector3;
            return function(n, o, a, s, h) {
                t.subVectors(s, o),
                e.subVectors(a, o),
                r.subVectors(n, o);
                var c = t.dot(t)
                  , l = t.dot(e)
                  , u = t.dot(r)
                  , p = e.dot(e)
                  , d = e.dot(r)
                  , f = c * p - l * l
                  , m = h || new i.Vector3;
                if (0 === f)
                    return m.set(-2, -1, -1);
                var g = 1 / f
                  , v = (p * u - l * d) * g
                  , y = (c * d - l * u) * g;
                return m.set(1 - v - y, y, v)
            }
        }(),
        i.Triangle.containsPoint = function() {
            var t = new i.Vector3;
            return function(e, r, n, o) {
                var a = i.Triangle.barycoordFromPoint(e, r, n, o, t);
                return a.x >= 0 && a.y >= 0 && a.x + a.y <= 1
            }
        }(),
        i.Triangle.prototype = {
            constructor: i.Triangle,
            set: function(t, e, r) {
                return this.a.copy(t),
                this.b.copy(e),
                this.c.copy(r),
                this
            },
            setFromPointsAndIndices: function(t, e, r, i) {
                return this.a.copy(t[e]),
                this.b.copy(t[r]),
                this.c.copy(t[i]),
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.a.copy(t.a),
                this.b.copy(t.b),
                this.c.copy(t.c),
                this
            },
            area: function() {
                var t = new i.Vector3
                  , e = new i.Vector3;
                return function() {
                    return t.subVectors(this.c, this.b),
                    e.subVectors(this.a, this.b),
                    .5 * t.cross(e).length()
                }
            }(),
            midpoint: function(t) {
                var e = t || new i.Vector3;
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            normal: function(t) {
                return i.Triangle.normal(this.a, this.b, this.c, t)
            },
            plane: function(t) {
                var e = t || new i.Plane;
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            },
            barycoordFromPoint: function(t, e) {
                return i.Triangle.barycoordFromPoint(t, this.a, this.b, this.c, e)
            },
            containsPoint: function(t) {
                return i.Triangle.containsPoint(t, this.a, this.b, this.c)
            },
            equals: function(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        },
        i.Interpolant = function(t, e, r, i) {
            this.parameterPositions = t,
            this._cachedIndex = 0,
            this.resultBuffer = void 0 !== i ? i : new e.constructor(r),
            this.sampleValues = e,
            this.valueSize = r
        }
        ,
        i.Interpolant.prototype = {
            constructor: i.Interpolant,
            evaluate: function(t) {
                var e = this.parameterPositions
                  , r = this._cachedIndex
                  , i = e[r]
                  , n = e[r - 1];
                t: {
                    e: {
                        var o;
                        r: {
                            i: if (!(t < i)) {
                                for (var a = r + 2; ; ) {
                                    if (void 0 === i) {
                                        if (t < n)
                                            break i;
                                        return r = e.length,
                                        this._cachedIndex = r,
                                        this.afterEnd_(r - 1, t, n)
                                    }
                                    if (r === a)
                                        break;
                                    if (n = i,
                                    i = e[++r],
                                    t < i)
                                        break e
                                }
                                o = e.length;
                                break r
                            }
                            {
                                if (t >= n)
                                    break t;
                                var s = e[1];
                                t < s && (r = 2,
                                n = s);
                                for (var a = r - 2; ; ) {
                                    if (void 0 === n)
                                        return this._cachedIndex = 0,
                                        this.beforeStart_(0, t, i);
                                    if (r === a)
                                        break;
                                    if (i = n,
                                    n = e[--r - 1],
                                    t >= n)
                                        break e
                                }
                                o = r,
                                r = 0
                            }
                        }
                        for (; r < o; ) {
                            var h = r + o >>> 1;
                            t < e[h] ? o = h : r = h + 1
                        }
                        if (i = e[r],
                        n = e[r - 1],
                        void 0 === n)
                            return this._cachedIndex = 0,
                            this.beforeStart_(0, t, i);
                        if (void 0 === i)
                            return r = e.length,
                            this._cachedIndex = r,
                            this.afterEnd_(r - 1, n, t)
                    }
                    this._cachedIndex = r,
                    this.intervalChanged_(r, n, i)
                }
                return this.interpolate_(r, n, t, i)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                for (var e = this.resultBuffer, r = this.sampleValues, i = this.valueSize, n = t * i, o = 0; o !== i; ++o)
                    e[o] = r[n + o];
                return e
            },
            interpolate_: function(t, e, r, i) {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function(t, e, r) {}
        },
        Object.assign(i.Interpolant.prototype, {
            beforeStart_: i.Interpolant.prototype.copySampleValue_,
            afterEnd_: i.Interpolant.prototype.copySampleValue_
        }),
        i.CubicInterpolant = function(t, e, r, n) {
            i.Interpolant.call(this, t, e, r, n),
            this._weightPrev = -0,
            this._offsetPrev = -0,
            this._weightNext = -0,
            this._offsetNext = -0
        }
        ,
        i.CubicInterpolant.prototype = Object.assign(Object.create(i.Interpolant.prototype), {
            constructor: i.CubicInterpolant,
            DefaultSettings_: {
                endingStart: i.ZeroCurvatureEnding,
                endingEnd: i.ZeroCurvatureEnding
            },
            intervalChanged_: function(t, e, r) {
                var n = this.parameterPositions
                  , o = t - 2
                  , a = t + 1
                  , s = n[o]
                  , h = n[a];
                if (void 0 === s)
                    switch (this.getSettings_().endingStart) {
                    case i.ZeroSlopeEnding:
                        o = t,
                        s = 2 * e - r;
                        break;
                    case i.WrapAroundEnding:
                        o = n.length - 2,
                        s = e + n[o] - n[o + 1];
                        break;
                    default:
                        o = t,
                        s = r
                    }
                if (void 0 === h)
                    switch (this.getSettings_().endingEnd) {
                    case i.ZeroSlopeEnding:
                        a = t,
                        h = 2 * r - e;
                        break;
                    case i.WrapAroundEnding:
                        a = 1,
                        h = r + n[1] - n[0];
                        break;
                    default:
                        a = t - 1,
                        h = e
                    }
                var c = .5 * (r - e)
                  , l = this.valueSize;
                this._weightPrev = c / (e - s),
                this._weightNext = c / (h - r),
                this._offsetPrev = o * l,
                this._offsetNext = a * l
            },
            interpolate_: function(t, e, r, i) {
                for (var n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, h = s - a, c = this._offsetPrev, l = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (r - e) / (i - e), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p * m - p * f, b = 0; b !== a; ++b)
                    n[b] = g * o[c + b] + v * o[h + b] + y * o[s + b] + x * o[l + b];
                return n
            }
        }),
        i.DiscreteInterpolant = function(t, e, r, n) {
            i.Interpolant.call(this, t, e, r, n)
        }
        ,
        i.DiscreteInterpolant.prototype = Object.assign(Object.create(i.Interpolant.prototype), {
            constructor: i.DiscreteInterpolant,
            interpolate_: function(t, e, r, i) {
                return this.copySampleValue_(t - 1)
            }
        }),
        i.LinearInterpolant = function(t, e, r, n) {
            i.Interpolant.call(this, t, e, r, n)
        }
        ,
        i.LinearInterpolant.prototype = Object.assign(Object.create(i.Interpolant.prototype), {
            constructor: i.LinearInterpolant,
            interpolate_: function(t, e, r, i) {
                for (var n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, h = s - a, c = (r - e) / (i - e), l = 1 - c, u = 0; u !== a; ++u)
                    n[u] = o[h + u] * l + o[s + u] * c;
                return n
            }
        }),
        i.QuaternionLinearInterpolant = function(t, e, r, n) {
            i.Interpolant.call(this, t, e, r, n)
        }
        ,
        i.QuaternionLinearInterpolant.prototype = Object.assign(Object.create(i.Interpolant.prototype), {
            constructor: i.QuaternionLinearInterpolant,
            interpolate_: function(t, e, r, n) {
                for (var o = this.resultBuffer, a = this.sampleValues, s = this.valueSize, h = t * s, c = (r - e) / (n - e), l = h + s; h !== l; h += 4)
                    i.Quaternion.slerpFlat(o, 0, a, h - s, a, h, c);
                return o
            }
        }),
        i.Clock = function(t) {
            this.autoStart = void 0 === t || t,
            this.startTime = 0,
            this.oldTime = 0,
            this.elapsedTime = 0,
            this.running = !1
        }
        ,
        i.Clock.prototype = {
            constructor: i.Clock,
            start: function() {
                this.startTime = performance.now(),
                this.oldTime = this.startTime,
                this.running = !0
            },
            stop: function() {
                this.getElapsedTime(),
                this.running = !1
            },
            getElapsedTime: function() {
                return this.getDelta(),
                this.elapsedTime
            },
            getDelta: function() {
                var t = 0;
                if (this.autoStart && !this.running && this.start(),
                this.running) {
                    var e = performance.now();
                    t = .001 * (e - this.oldTime),
                    this.oldTime = e,
                    this.elapsedTime += t
                }
                return t
            }
        },
        i.EventDispatcher = function() {}
        ,
        i.EventDispatcher.prototype = {
            constructor: i.EventDispatcher,
            apply: function(t) {
                t.addEventListener = i.EventDispatcher.prototype.addEventListener,
                t.hasEventListener = i.EventDispatcher.prototype.hasEventListener,
                t.removeEventListener = i.EventDispatcher.prototype.removeEventListener,
                t.dispatchEvent = i.EventDispatcher.prototype.dispatchEvent
            },
            addEventListener: function(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var r = this._listeners;
                void 0 === r[t] && (r[t] = []),
                r[t].indexOf(e) === -1 && r[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (void 0 === this._listeners)
                    return !1;
                var r = this._listeners;
                return void 0 !== r[t] && r[t].indexOf(e) !== -1
            },
            removeEventListener: function(t, e) {
                if (void 0 !== this._listeners) {
                    var r = this._listeners
                      , i = r[t];
                    if (void 0 !== i) {
                        var n = i.indexOf(e);
                        n !== -1 && i.splice(n, 1)
                    }
                }
            },
            dispatchEvent: function(t) {
                if (void 0 !== this._listeners) {
                    var e = this._listeners
                      , r = e[t.type];
                    if (void 0 !== r) {
                        t.target = this;
                        for (var i = [], n = r.length, o = 0; o < n; o++)
                            i[o] = r[o];
                        for (var o = 0; o < n; o++)
                            i[o].call(this, t)
                    }
                }
            }
        },
        i.Layers = function() {
            this.mask = 1
        }
        ,
        i.Layers.prototype = {
            constructor: i.Layers,
            set: function(t) {
                this.mask = 1 << t
            },
            enable: function(t) {
                this.mask |= 1 << t
            },
            toggle: function(t) {
                this.mask ^= 1 << t
            },
            disable: function(t) {
                this.mask &= ~(1 << t)
            },
            test: function(t) {
                return 0 !== (this.mask & t.mask)
            }
        },
        function(t) {
            function e(t, e) {
                return t.distance - e.distance
            }
            function r(t, e, i, n) {
                if (t.visible !== !1 && (t.raycast(e, i),
                n === !0))
                    for (var o = t.children, a = 0, s = o.length; a < s; a++)
                        r(o[a], e, i, !0)
            }
            t.Raycaster = function(e, r, i, n) {
                this.ray = new t.Ray(e,r),
                this.near = i || 0,
                this.far = n || 1 / 0,
                this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                },
                Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                            this.Points
                        }
                    }
                })
            }
            ,
            t.Raycaster.prototype = {
                constructor: t.Raycaster,
                linePrecision: 1,
                set: function(t, e) {
                    this.ray.set(t, e)
                },
                setFromCamera: function(e, r) {
                    r instanceof t.PerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(r.matrixWorld),
                    this.ray.direction.set(e.x, e.y, .5).unproject(r).sub(this.ray.origin).normalize()) : r instanceof t.OrthographicCamera ? (this.ray.origin.set(e.x, e.y, -1).unproject(r),
                    this.ray.direction.set(0, 0, -1).transformDirection(r.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function(t, i) {
                    var n = [];
                    return r(t, this, n, i),
                    n.sort(e),
                    n
                },
                intersectObjects: function(t, i) {
                    var n = [];
                    if (Array.isArray(t) === !1)
                        return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                        n;
                    for (var o = 0, a = t.length; o < a; o++)
                        r(t[o], this, n, i);
                    return n.sort(e),
                    n
                }
            }
        }(i),
        i.Object3D = function() {
            function t() {
                o.setFromEuler(n, !1)
            }
            function e() {
                n.setFromQuaternion(o, void 0, !1)
            }
            Object.defineProperty(this, "id", {
                value: i.Object3DIdCount++
            }),
            this.uuid = i.Math.generateUUID(),
            this.name = "",
            this.type = "Object3D",
            this.parent = null,
            this.children = [],
            this.up = i.Object3D.DefaultUp.clone();
            var r = new i.Vector3
              , n = new i.Euler
              , o = new i.Quaternion
              , a = new i.Vector3(1,1,1);
            n.onChange(t),
            o.onChange(e),
            Object.defineProperties(this, {
                position: {
                    enumerable: !0,
                    value: r
                },
                rotation: {
                    enumerable: !0,
                    value: n
                },
                quaternion: {
                    enumerable: !0,
                    value: o
                },
                scale: {
                    enumerable: !0,
                    value: a
                },
                modelViewMatrix: {
                    value: new i.Matrix4
                },
                normalMatrix: {
                    value: new i.Matrix3
                }
            }),
            this.rotationAutoUpdate = !0,
            this.matrix = new i.Matrix4,
            this.matrixWorld = new i.Matrix4,
            this.matrixAutoUpdate = i.Object3D.DefaultMatrixAutoUpdate,
            this.matrixWorldNeedsUpdate = !1,
            this.layers = new i.Layers,
            this.visible = !0,
            this.castShadow = !1,
            this.receiveShadow = !1,
            this.frustumCulled = !0,
            this.renderOrder = 0,
            this.userData = {}
        }
        ,
        i.Object3D.DefaultUp = new i.Vector3(0,1,0),
        i.Object3D.DefaultMatrixAutoUpdate = !0,
        i.Object3D.prototype = {
            constructor: i.Object3D,
            applyMatrix: function(t) {
                this.matrix.multiplyMatrices(t, this.matrix),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            setRotationFromAxisAngle: function(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function(t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function(t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function(t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function() {
                var t = new i.Quaternion;
                return function(e, r) {
                    return t.setFromAxisAngle(e, r),
                    this.quaternion.multiply(t),
                    this
                }
            }(),
            rotateX: function() {
                var t = new i.Vector3(1,0,0);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateY: function() {
                var t = new i.Vector3(0,1,0);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateZ: function() {
                var t = new i.Vector3(0,0,1);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            translateOnAxis: function() {
                var t = new i.Vector3;
                return function(e, r) {
                    return t.copy(e).applyQuaternion(this.quaternion),
                    this.position.add(t.multiplyScalar(r)),
                    this
                }
            }(),
            translateX: function() {
                var t = new i.Vector3(1,0,0);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateY: function() {
                var t = new i.Vector3(0,1,0);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateZ: function() {
                var t = new i.Vector3(0,0,1);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            localToWorld: function(t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function() {
                var t = new i.Matrix4;
                return function(e) {
                    return e.applyMatrix4(t.getInverse(this.matrixWorld))
                }
            }(),
            lookAt: function() {
                var t = new i.Matrix4;
                return function(e) {
                    t.lookAt(e, this.position, this.up),
                    this.quaternion.setFromRotationMatrix(t)
                }
            }(),
            add: function(t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++)
                        this.add(arguments[e]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                this) : (t instanceof i.Object3D ? (null !== t.parent && t.parent.remove(t),
                t.parent = this,
                t.dispatchEvent({
                    type: "added"
                }),
                this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                this)
            },
            remove: function(t) {
                if (arguments.length > 1)
                    for (var e = 0; e < arguments.length; e++)
                        this.remove(arguments[e]);
                var r = this.children.indexOf(t);
                r !== -1 && (t.parent = null,
                t.dispatchEvent({
                    type: "removed"
                }),
                this.children.splice(r, 1))
            },
            getObjectById: function(t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function(t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function(t, e) {
                if (this[t] === e)
                    return this;
                for (var r = 0, i = this.children.length; r < i; r++) {
                    var n = this.children[r]
                      , o = n.getObjectByProperty(t, e);
                    if (void 0 !== o)
                        return o
                }
            },
            getWorldPosition: function(t) {
                var e = t || new i.Vector3;
                return this.updateMatrixWorld(!0),
                e.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function() {
                var t = new i.Vector3
                  , e = new i.Vector3;
                return function(r) {
                    var n = r || new i.Quaternion;
                    return this.updateMatrixWorld(!0),
                    this.matrixWorld.decompose(t, n, e),
                    n
                }
            }(),
            getWorldRotation: function() {
                var t = new i.Quaternion;
                return function(e) {
                    var r = e || new i.Euler;
                    return this.getWorldQuaternion(t),
                    r.setFromQuaternion(t, this.rotation.order, !1)
                }
            }(),
            getWorldScale: function() {
                var t = new i.Vector3
                  , e = new i.Quaternion;
                return function(r) {
                    var n = r || new i.Vector3;
                    return this.updateMatrixWorld(!0),
                    this.matrixWorld.decompose(t, e, n),
                    n
                }
            }(),
            getWorldDirection: function() {
                var t = new i.Quaternion;
                return function(e) {
                    var r = e || new i.Vector3;
                    return this.getWorldQuaternion(t),
                    r.set(0, 0, 1).applyQuaternion(t)
                }
            }(),
            raycast: function() {},
            traverse: function(t) {
                t(this);
                for (var e = this.children, r = 0, i = e.length; r < i; r++)
                    e[r].traverse(t)
            },
            traverseVisible: function(t) {
                if (this.visible !== !1) {
                    t(this);
                    for (var e = this.children, r = 0, i = e.length; r < i; r++)
                        e[r].traverseVisible(t)
                }
            },
            traverseAncestors: function(t) {
                var e = this.parent;
                null !== e && (t(e),
                e.traverseAncestors(t))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(t) {
                this.matrixAutoUpdate === !0 && this.updateMatrix(),
                this.matrixWorldNeedsUpdate !== !0 && t !== !0 || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                t = !0);
                for (var e = 0, r = this.children.length; e < r; e++)
                    this.children[e].updateMatrixWorld(t)
            },
            toJSON: function(t) {
                function e(t) {
                    var e = [];
                    for (var r in t) {
                        var i = t[r];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
                var r = void 0 === t
                  , i = {};
                r && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {}
                },
                i.metadata = {
                    version: 4.4,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var n = {};
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                this.castShadow === !0 && (n.castShadow = !0),
                this.receiveShadow === !0 && (n.receiveShadow = !0),
                this.visible === !1 && (n.visible = !1),
                n.matrix = this.matrix.toArray(),
                void 0 !== this.geometry && (void 0 === t.geometries[this.geometry.uuid] && (t.geometries[this.geometry.uuid] = this.geometry.toJSON(t)),
                n.geometry = this.geometry.uuid),
                void 0 !== this.material && (void 0 === t.materials[this.material.uuid] && (t.materials[this.material.uuid] = this.material.toJSON(t)),
                n.material = this.material.uuid),
                this.children.length > 0) {
                    n.children = [];
                    for (var o = 0; o < this.children.length; o++)
                        n.children.push(this.children[o].toJSON(t).object)
                }
                if (r) {
                    var a = e(t.geometries)
                      , s = e(t.materials)
                      , h = e(t.textures)
                      , c = e(t.images);
                    a.length > 0 && (i.geometries = a),
                    s.length > 0 && (i.materials = s),
                    h.length > 0 && (i.textures = h),
                    c.length > 0 && (i.images = c)
                }
                return i.object = n,
                i
            },
            clone: function(t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function(t, e) {
                if (void 0 === e && (e = !0),
                this.name = t.name,
                this.up.copy(t.up),
                this.position.copy(t.position),
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.rotationAutoUpdate = t.rotationAutoUpdate,
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                this.visible = t.visible,
                this.castShadow = t.castShadow,
                this.receiveShadow = t.receiveShadow,
                this.frustumCulled = t.frustumCulled,
                this.renderOrder = t.renderOrder,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                e === !0)
                    for (var r = 0; r < t.children.length; r++) {
                        var i = t.children[r];
                        this.add(i.clone())
                    }
                return this
            }
        },
        i.EventDispatcher.prototype.apply(i.Object3D.prototype),
        i.Object3DIdCount = 0,
        i.Face3 = function(t, e, r, n, o, a) {
            this.a = t,
            this.b = e,
            this.c = r,
            this.normal = n instanceof i.Vector3 ? n : new i.Vector3,
            this.vertexNormals = Array.isArray(n) ? n : [],
            this.color = o instanceof i.Color ? o : new i.Color,
            this.vertexColors = Array.isArray(o) ? o : [],
            this.materialIndex = void 0 !== a ? a : 0
        }
        ,
        i.Face3.prototype = {
            constructor: i.Face3,
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.a = t.a,
                this.b = t.b,
                this.c = t.c,
                this.normal.copy(t.normal),
                this.color.copy(t.color),
                this.materialIndex = t.materialIndex;
                for (var e = 0, r = t.vertexNormals.length; e < r; e++)
                    this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (var e = 0, r = t.vertexColors.length; e < r; e++)
                    this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        },
        i.BufferAttribute = function(t, e) {
            this.uuid = i.Math.generateUUID(),
            this.array = t,
            this.itemSize = e,
            this.dynamic = !1,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.version = 0
        }
        ,
        i.BufferAttribute.prototype = {
            constructor: i.BufferAttribute,
            get count() {
                return this.array.length / this.itemSize
            },
            set needsUpdate(t) {
                t === !0 && this.version++
            },
            setDynamic: function(t) {
                return this.dynamic = t,
                this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array),
                this.itemSize = t.itemSize,
                this.dynamic = t.dynamic,
                this
            },
            copyAt: function(t, e, r) {
                t *= this.itemSize,
                r *= e.itemSize;
                for (var i = 0, n = this.itemSize; i < n; i++)
                    this.array[t + i] = e.array[r + i];
                return this
            },
            copyArray: function(t) {
                return this.array.set(t),
                this
            },
            copyColorsArray: function(t) {
                for (var e = this.array, r = 0, n = 0, o = t.length; n < o; n++) {
                    var a = t[n];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n),
                    a = new i.Color),
                    e[r++] = a.r,
                    e[r++] = a.g,
                    e[r++] = a.b
                }
                return this
            },
            copyIndicesArray: function(t) {
                for (var e = this.array, r = 0, i = 0, n = t.length; i < n; i++) {
                    var o = t[i];
                    e[r++] = o.a,
                    e[r++] = o.b,
                    e[r++] = o.c
                }
                return this
            },
            copyVector2sArray: function(t) {
                for (var e = this.array, r = 0, n = 0, o = t.length; n < o; n++) {
                    var a = t[n];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n),
                    a = new i.Vector2),
                    e[r++] = a.x,
                    e[r++] = a.y
                }
                return this
            },
            copyVector3sArray: function(t) {
                for (var e = this.array, r = 0, n = 0, o = t.length; n < o; n++) {
                    var a = t[n];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n),
                    a = new i.Vector3),
                    e[r++] = a.x,
                    e[r++] = a.y,
                    e[r++] = a.z
                }
                return this
            },
            copyVector4sArray: function(t) {
                for (var e = this.array, r = 0, n = 0, o = t.length; n < o; n++) {
                    var a = t[n];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n),
                    a = new i.Vector4),
                    e[r++] = a.x,
                    e[r++] = a.y,
                    e[r++] = a.z,
                    e[r++] = a.w
                }
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0),
                this.array.set(t, e),
                this
            },
            getX: function(t) {
                return this.array[t * this.itemSize]
            },
            setX: function(t, e) {
                return this.array[t * this.itemSize] = e,
                this
            },
            getY: function(t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function(t, e) {
                return this.array[t * this.itemSize + 1] = e,
                this
            },
            getZ: function(t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function(t, e) {
                return this.array[t * this.itemSize + 2] = e,
                this
            },
            getW: function(t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function(t, e) {
                return this.array[t * this.itemSize + 3] = e,
                this
            },
            setXY: function(t, e, r) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = r,
                this
            },
            setXYZ: function(t, e, r, i) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = r,
                this.array[t + 2] = i,
                this
            },
            setXYZW: function(t, e, r, i, n) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = r,
                this.array[t + 2] = i,
                this.array[t + 3] = n,
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        },
        i.Int8Attribute = function(t, e) {
            return new i.BufferAttribute(new Int8Array(t),e)
        }
        ,
        i.Uint8Attribute = function(t, e) {
            return new i.BufferAttribute(new Uint8Array(t),e)
        }
        ,
        i.Uint8ClampedAttribute = function(t, e) {
            return new i.BufferAttribute(new Uint8ClampedArray(t),e)
        }
        ,
        i.Int16Attribute = function(t, e) {
            return new i.BufferAttribute(new Int16Array(t),e)
        }
        ,
        i.Uint16Attribute = function(t, e) {
            return new i.BufferAttribute(new Uint16Array(t),e)
        }
        ,
        i.Int32Attribute = function(t, e) {
            return new i.BufferAttribute(new Int32Array(t),e)
        }
        ,
        i.Uint32Attribute = function(t, e) {
            return new i.BufferAttribute(new Uint32Array(t),e)
        }
        ,
        i.Float32Attribute = function(t, e) {
            return new i.BufferAttribute(new Float32Array(t),e)
        }
        ,
        i.Float64Attribute = function(t, e) {
            return new i.BufferAttribute(new Float64Array(t),e)
        }
        ,
        i.DynamicBufferAttribute = function(t, e) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
            new i.BufferAttribute(t,e).setDynamic(!0)
        }
        ,
        i.InstancedBufferAttribute = function(t, e, r) {
            i.BufferAttribute.call(this, t, e),
            this.meshPerAttribute = r || 1
        }
        ,
        i.InstancedBufferAttribute.prototype = Object.create(i.BufferAttribute.prototype),
        i.InstancedBufferAttribute.prototype.constructor = i.InstancedBufferAttribute,
        i.InstancedBufferAttribute.prototype.copy = function(t) {
            return i.BufferAttribute.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
        ,
        i.InterleavedBuffer = function(t, e) {
            this.uuid = i.Math.generateUUID(),
            this.array = t,
            this.stride = e,
            this.dynamic = !1,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.version = 0
        }
        ,
        i.InterleavedBuffer.prototype = {
            constructor: i.InterleavedBuffer,
            get length() {
                return this.array.length
            },
            get count() {
                return this.array.length / this.stride
            },
            set needsUpdate(t) {
                t === !0 && this.version++
            },
            setDynamic: function(t) {
                return this.dynamic = t,
                this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array),
                this.stride = t.stride,
                this.dynamic = t.dynamic,
                this
            },
            copyAt: function(t, e, r) {
                t *= this.stride,
                r *= e.stride;
                for (var i = 0, n = this.stride; i < n; i++)
                    this.array[t + i] = e.array[r + i];
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0),
                this.array.set(t, e),
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        },
        i.InstancedInterleavedBuffer = function(t, e, r) {
            i.InterleavedBuffer.call(this, t, e),
            this.meshPerAttribute = r || 1
        }
        ,
        i.InstancedInterleavedBuffer.prototype = Object.create(i.InterleavedBuffer.prototype),
        i.InstancedInterleavedBuffer.prototype.constructor = i.InstancedInterleavedBuffer,
        i.InstancedInterleavedBuffer.prototype.copy = function(t) {
            return i.InterleavedBuffer.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
        ,
        i.InterleavedBufferAttribute = function(t, e, r) {
            this.uuid = i.Math.generateUUID(),
            this.data = t,
            this.itemSize = e,
            this.offset = r
        }
        ,
        i.InterleavedBufferAttribute.prototype = {
            constructor: i.InterleavedBufferAttribute,
            get length() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
                this.array.length
            },
            get count() {
                return this.data.count
            },
            setX: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e,
                this
            },
            setY: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e,
                this
            },
            setZ: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e,
                this
            },
            setW: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e,
                this
            },
            getX: function(t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function(t, e, r) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = r,
                this
            },
            setXYZ: function(t, e, r, i) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = r,
                this.data.array[t + 2] = i,
                this
            },
            setXYZW: function(t, e, r, i, n) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = r,
                this.data.array[t + 2] = i,
                this.data.array[t + 3] = n,
                this
            }
        };
        i.Geometry = function() {
            Object.defineProperty(this, "id", {
                value: i.GeometryIdCount++
            }),
            this.uuid = i.Math.generateUUID(),
            this.name = "",
            this.type = "Geometry",
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.verticesNeedUpdate = !1,
            this.elementsNeedUpdate = !1,
            this.uvsNeedUpdate = !1,
            this.normalsNeedUpdate = !1,
            this.colorsNeedUpdate = !1,
            this.lineDistancesNeedUpdate = !1,
            this.groupsNeedUpdate = !1
        }
        ;
        i.Geometry.prototype = {
            constructor: i.Geometry,
            applyMatrix: function(t) {
                for (var e = (new i.Matrix3).getNormalMatrix(t), r = 0, n = this.vertices.length; r < n; r++) {
                    var o = this.vertices[r];
                    o.applyMatrix4(t)
                }
                for (var r = 0, n = this.faces.length; r < n; r++) {
                    var a = this.faces[r];
                    a.normal.applyMatrix3(e).normalize();
                    for (var s = 0, h = a.vertexNormals.length; s < h; s++)
                        a.vertexNormals[s].applyMatrix3(e).normalize()
                }
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this.verticesNeedUpdate = !0,
                this.normalsNeedUpdate = !0
            },
            rotateX: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeRotationX(e),
                    this.applyMatrix(t),
                    this
                }
            }(),
            rotateY: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeRotationY(e),
                    this.applyMatrix(t),
                    this
                }
            }(),
            rotateZ: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeRotationZ(e),
                    this.applyMatrix(t),
                    this
                }
            }(),
            translate: function() {
                var t;
                return function(e, r, n) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeTranslation(e, r, n),
                    this.applyMatrix(t),
                    this
                }
            }(),
            scale: function() {
                var t;
                return function(e, r, n) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeScale(e, r, n),
                    this.applyMatrix(t),
                    this
                }
            }(),
            lookAt: function() {
                var t;
                return function(e) {
                    void 0 === t && (t = new i.Object3D),
                    t.lookAt(e),
                    t.updateMatrix(),
                    this.applyMatrix(t.matrix)
                }
            }(),
            fromBufferGeometry: function(t) {
                function e(t, e, n) {
                    var o = void 0 !== s ? [u[t].clone(), u[e].clone(), u[n].clone()] : []
                      , a = void 0 !== h ? [r.colors[t].clone(), r.colors[e].clone(), r.colors[n].clone()] : []
                      , f = new i.Face3(t,e,n,o,a);
                    r.faces.push(f),
                    void 0 !== c && r.faceVertexUvs[0].push([p[t].clone(), p[e].clone(), p[n].clone()]),
                    void 0 !== l && r.faceVertexUvs[1].push([d[t].clone(), d[e].clone(), d[n].clone()])
                }
                var r = this
                  , n = null !== t.index ? t.index.array : void 0
                  , o = t.attributes
                  , a = o.position.array
                  , s = void 0 !== o.normal ? o.normal.array : void 0
                  , h = void 0 !== o.color ? o.color.array : void 0
                  , c = void 0 !== o.uv ? o.uv.array : void 0
                  , l = void 0 !== o.uv2 ? o.uv2.array : void 0;
                void 0 !== l && (this.faceVertexUvs[1] = []);
                for (var u = [], p = [], d = [], f = 0, m = 0; f < a.length; f += 3,
                m += 2)
                    r.vertices.push(new i.Vector3(a[f],a[f + 1],a[f + 2])),
                    void 0 !== s && u.push(new i.Vector3(s[f],s[f + 1],s[f + 2])),
                    void 0 !== h && r.colors.push(new i.Color(h[f],h[f + 1],h[f + 2])),
                    void 0 !== c && p.push(new i.Vector2(c[m],c[m + 1])),
                    void 0 !== l && d.push(new i.Vector2(l[m],l[m + 1]));
                if (void 0 !== n) {
                    var g = t.groups;
                    if (g.length > 0)
                        for (var f = 0; f < g.length; f++)
                            for (var v = g[f], y = v.start, x = v.count, m = y, b = y + x; m < b; m += 3)
                                e(n[m], n[m + 1], n[m + 2]);
                    else
                        for (var f = 0; f < n.length; f += 3)
                            e(n[f], n[f + 1], n[f + 2])
                } else
                    for (var f = 0; f < a.length / 3; f += 3)
                        e(f, f + 1, f + 2);
                return this.computeFaceNormals(),
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                this
            },
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.center().negate();
                return this.translate(t.x, t.y, t.z),
                t
            },
            normalize: function() {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center
                  , e = this.boundingSphere.radius
                  , r = 0 === e ? 1 : 1 / e
                  , n = new i.Matrix4;
                return n.set(r, 0, 0, -r * t.x, 0, r, 0, -r * t.y, 0, 0, r, -r * t.z, 0, 0, 0, 1),
                this.applyMatrix(n),
                this
            },
            computeFaceNormals: function() {
                for (var t = new i.Vector3, e = new i.Vector3, r = 0, n = this.faces.length; r < n; r++) {
                    var o = this.faces[r]
                      , a = this.vertices[o.a]
                      , s = this.vertices[o.b]
                      , h = this.vertices[o.c];
                    t.subVectors(h, s),
                    e.subVectors(a, s),
                    t.cross(e),
                    t.normalize(),
                    o.normal.copy(t)
                }
            },
            computeVertexNormals: function(t) {
                void 0 === t && (t = !0);
                var e, r, n, o, a, s;
                for (s = new Array(this.vertices.length),
                e = 0,
                r = this.vertices.length; e < r; e++)
                    s[e] = new i.Vector3;
                if (t) {
                    var h, c, l, u = new i.Vector3, p = new i.Vector3;
                    for (n = 0,
                    o = this.faces.length; n < o; n++)
                        a = this.faces[n],
                        h = this.vertices[a.a],
                        c = this.vertices[a.b],
                        l = this.vertices[a.c],
                        u.subVectors(l, c),
                        p.subVectors(h, c),
                        u.cross(p),
                        s[a.a].add(u),
                        s[a.b].add(u),
                        s[a.c].add(u)
                } else
                    for (n = 0,
                    o = this.faces.length; n < o; n++)
                        a = this.faces[n],
                        s[a.a].add(a.normal),
                        s[a.b].add(a.normal),
                        s[a.c].add(a.normal);
                for (e = 0,
                r = this.vertices.length; e < r; e++)
                    s[e].normalize();
                for (n = 0,
                o = this.faces.length; n < o; n++) {
                    a = this.faces[n];
                    var d = a.vertexNormals;
                    3 === d.length ? (d[0].copy(s[a.a]),
                    d[1].copy(s[a.b]),
                    d[2].copy(s[a.c])) : (d[0] = s[a.a].clone(),
                    d[1] = s[a.b].clone(),
                    d[2] = s[a.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function() {
                var t, e, r, n, o;
                for (r = 0,
                n = this.faces.length; r < n; r++)
                    for (o = this.faces[r],
                    o.__originalFaceNormal ? o.__originalFaceNormal.copy(o.normal) : o.__originalFaceNormal = o.normal.clone(),
                    o.__originalVertexNormals || (o.__originalVertexNormals = []),
                    t = 0,
                    e = o.vertexNormals.length; t < e; t++)
                        o.__originalVertexNormals[t] ? o.__originalVertexNormals[t].copy(o.vertexNormals[t]) : o.__originalVertexNormals[t] = o.vertexNormals[t].clone();
                var a = new i.Geometry;
                for (a.faces = this.faces,
                t = 0,
                e = this.morphTargets.length; t < e; t++) {
                    if (!this.morphNormals[t]) {
                        this.morphNormals[t] = {},
                        this.morphNormals[t].faceNormals = [],
                        this.morphNormals[t].vertexNormals = [];
                        var s, h, c = this.morphNormals[t].faceNormals, l = this.morphNormals[t].vertexNormals;
                        for (r = 0,
                        n = this.faces.length; r < n; r++)
                            s = new i.Vector3,
                            h = {
                                a: new i.Vector3,
                                b: new i.Vector3,
                                c: new i.Vector3
                            },
                            c.push(s),
                            l.push(h)
                    }
                    var u = this.morphNormals[t];
                    a.vertices = this.morphTargets[t].vertices,
                    a.computeFaceNormals(),
                    a.computeVertexNormals();
                    var s, h;
                    for (r = 0,
                    n = this.faces.length; r < n; r++)
                        o = this.faces[r],
                        s = u.faceNormals[r],
                        h = u.vertexNormals[r],
                        s.copy(o.normal),
                        h.a.copy(o.vertexNormals[0]),
                        h.b.copy(o.vertexNormals[1]),
                        h.c.copy(o.vertexNormals[2])
                }
                for (r = 0,
                n = this.faces.length; r < n; r++)
                    o = this.faces[r],
                    o.normal = o.__originalFaceNormal,
                    o.vertexNormals = o.__originalVertexNormals
            },
            computeTangents: function() {
                console.warn("THREE.Geometry: .computeTangents() has been removed.")
            },
            computeLineDistances: function() {
                for (var t = 0, e = this.vertices, r = 0, i = e.length; r < i; r++)
                    r > 0 && (t += e[r].distanceTo(e[r - 1])),
                    this.lineDistances[r] = t
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new i.Box3),
                this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new i.Sphere),
                this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function(t, e, r) {
                if (t instanceof i.Geometry == !1)
                    return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                var n, o = this.vertices.length, a = this.vertices, s = t.vertices, h = this.faces, c = t.faces, l = this.faceVertexUvs[0], u = t.faceVertexUvs[0];
                void 0 === r && (r = 0),
                void 0 !== e && (n = (new i.Matrix3).getNormalMatrix(e));
                for (var p = 0, d = s.length; p < d; p++) {
                    var f = s[p]
                      , m = f.clone();
                    void 0 !== e && m.applyMatrix4(e),
                    a.push(m)
                }
                for (p = 0,
                d = c.length; p < d; p++) {
                    var g, v, y, x = c[p], b = x.vertexNormals, w = x.vertexColors;
                    g = new i.Face3(x.a + o,x.b + o,x.c + o),
                    g.normal.copy(x.normal),
                    void 0 !== n && g.normal.applyMatrix3(n).normalize();
                    for (var _ = 0, M = b.length; _ < M; _++)
                        v = b[_].clone(),
                        void 0 !== n && v.applyMatrix3(n).normalize(),
                        g.vertexNormals.push(v);
                    g.color.copy(x.color);
                    for (var _ = 0, M = w.length; _ < M; _++)
                        y = w[_],
                        g.vertexColors.push(y.clone());
                    g.materialIndex = x.materialIndex + r,
                    h.push(g)
                }
                for (p = 0,
                d = u.length; p < d; p++) {
                    var S = u[p]
                      , E = [];
                    if (void 0 !== S) {
                        for (var _ = 0, M = S.length; _ < M; _++)
                            E.push(S[_].clone());
                        l.push(E)
                    }
                }
            },
            mergeMesh: function(t) {
                return t instanceof i.Mesh == !1 ? void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) : (t.matrixAutoUpdate && t.updateMatrix(),
                void this.merge(t.geometry, t.matrix))
            },
            mergeVertices: function() {
                var t, e, r, i, n, o, a, s, h = {}, c = [], l = [], u = 4, p = Math.pow(10, u);
                for (r = 0,
                i = this.vertices.length; r < i; r++)
                    t = this.vertices[r],
                    e = Math.round(t.x * p) + "_" + Math.round(t.y * p) + "_" + Math.round(t.z * p),
                    void 0 === h[e] ? (h[e] = r,
                    c.push(this.vertices[r]),
                    l[r] = c.length - 1) : l[r] = l[h[e]];
                var d = [];
                for (r = 0,
                i = this.faces.length; r < i; r++) {
                    n = this.faces[r],
                    n.a = l[n.a],
                    n.b = l[n.b],
                    n.c = l[n.c],
                    o = [n.a, n.b, n.c];
                    for (var f = -1, m = 0; m < 3; m++)
                        if (o[m] === o[(m + 1) % 3]) {
                            f = m,
                            d.push(r);
                            break
                        }
                }
                for (r = d.length - 1; r >= 0; r--) {
                    var g = d[r];
                    for (this.faces.splice(g, 1),
                    a = 0,
                    s = this.faceVertexUvs.length; a < s; a++)
                        this.faceVertexUvs[a].splice(g, 1)
                }
                var v = this.vertices.length - c.length;
                return this.vertices = c,
                v
            },
            sortFacesByMaterialIndex: function() {
                function t(t, e) {
                    return t.materialIndex - e.materialIndex
                }
                for (var e = this.faces, r = e.length, i = 0; i < r; i++)
                    e[i]._id = i;
                e.sort(t);
                var n, o, a = this.faceVertexUvs[0], s = this.faceVertexUvs[1];
                a && a.length === r && (n = []),
                s && s.length === r && (o = []);
                for (var i = 0; i < r; i++) {
                    var h = e[i]._id;
                    n && n.push(a[h]),
                    o && o.push(s[h])
                }
                n && (this.faceVertexUvs[0] = n),
                o && (this.faceVertexUvs[1] = o)
            },
            toJSON: function() {
                function t(t, e, r) {
                    return r ? t | 1 << e : t & ~(1 << e)
                }
                function e(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== p[e] ? p[e] : (p[e] = u.length / 3,
                    u.push(t.x, t.y, t.z),
                    p[e])
                }
                function r(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== f[e] ? f[e] : (f[e] = d.length,
                    d.push(t.getHex()),
                    f[e])
                }
                function i(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== g[e] ? g[e] : (g[e] = m.length / 2,
                    m.push(t.x, t.y),
                    g[e])
                }
                var n = {
                    metadata: {
                        version: 4.4,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                void 0 !== this.parameters) {
                    var o = this.parameters;
                    for (var a in o)
                        void 0 !== o[a] && (n[a] = o[a]);
                    return n
                }
                for (var s = [], h = 0; h < this.vertices.length; h++) {
                    var c = this.vertices[h];
                    s.push(c.x, c.y, c.z)
                }
                for (var l = [], u = [], p = {}, d = [], f = {}, m = [], g = {}, h = 0; h < this.faces.length; h++) {
                    var v = this.faces[h]
                      , y = !0
                      , x = !1
                      , b = void 0 !== this.faceVertexUvs[0][h]
                      , w = v.normal.length() > 0
                      , _ = v.vertexNormals.length > 0
                      , M = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b
                      , S = v.vertexColors.length > 0
                      , E = 0;
                    if (E = t(E, 0, 0),
                    E = t(E, 1, y),
                    E = t(E, 2, x),
                    E = t(E, 3, b),
                    E = t(E, 4, w),
                    E = t(E, 5, _),
                    E = t(E, 6, M),
                    E = t(E, 7, S),
                    l.push(E),
                    l.push(v.a, v.b, v.c),
                    l.push(v.materialIndex),
                    b) {
                        var T = this.faceVertexUvs[0][h];
                        l.push(i(T[0]), i(T[1]), i(T[2]))
                    }
                    if (w && l.push(e(v.normal)),
                    _) {
                        var A = v.vertexNormals;
                        l.push(e(A[0]), e(A[1]), e(A[2]))
                    }
                    if (M && l.push(r(v.color)),
                    S) {
                        var L = v.vertexColors;
                        l.push(r(L[0]), r(L[1]), r(L[2]))
                    }
                }
                return n.data = {},
                n.data.vertices = s,
                n.data.normals = u,
                d.length > 0 && (n.data.colors = d),
                m.length > 0 && (n.data.uvs = [m]),
                n.data.faces = l,
                n
            },
            clone: function() {
                return (new i.Geometry).copy(this)
            },
            copy: function(t) {
                this.vertices = [],
                this.faces = [],
                this.faceVertexUvs = [[]];
                for (var e = t.vertices, r = 0, i = e.length; r < i; r++)
                    this.vertices.push(e[r].clone());
                for (var n = t.faces, r = 0, i = n.length; r < i; r++)
                    this.faces.push(n[r].clone());
                for (var r = 0, i = t.faceVertexUvs.length; r < i; r++) {
                    var o = t.faceVertexUvs[r];
                    void 0 === this.faceVertexUvs[r] && (this.faceVertexUvs[r] = []);
                    for (var a = 0, s = o.length; a < s; a++) {
                        for (var h = o[a], c = [], l = 0, u = h.length; l < u; l++) {
                            var p = h[l];
                            c.push(p.clone())
                        }
                        this.faceVertexUvs[r].push(c)
                    }
                }
                return this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        },
        i.EventDispatcher.prototype.apply(i.Geometry.prototype),
        i.GeometryIdCount = 0,
        i.DirectGeometry = function() {
            Object.defineProperty(this, "id", {
                value: i.GeometryIdCount++
            }),
            this.uuid = i.Math.generateUUID(),
            this.name = "",
            this.type = "DirectGeometry",
            this.indices = [],
            this.vertices = [],
            this.normals = [],
            this.colors = [],
            this.uvs = [],
            this.uvs2 = [],
            this.groups = [],
            this.morphTargets = {},
            this.skinWeights = [],
            this.skinIndices = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.verticesNeedUpdate = !1,
            this.normalsNeedUpdate = !1,
            this.colorsNeedUpdate = !1,
            this.uvsNeedUpdate = !1,
            this.groupsNeedUpdate = !1
        }
        ,
        i.DirectGeometry.prototype = {
            constructor: i.DirectGeometry,
            computeBoundingBox: i.Geometry.prototype.computeBoundingBox,
            computeBoundingSphere: i.Geometry.prototype.computeBoundingSphere,
            computeFaceNormals: function() {
                console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
            },
            computeVertexNormals: function() {
                console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
            },
            computeGroups: function(t) {
                for (var e, r, i = [], n = t.faces, o = 0; o < n.length; o++) {
                    var a = n[o];
                    a.materialIndex !== r && (r = a.materialIndex,
                    void 0 !== e && (e.count = 3 * o - e.start,
                    i.push(e)),
                    e = {
                        start: 3 * o,
                        materialIndex: r
                    })
                }
                void 0 !== e && (e.count = 3 * o - e.start,
                i.push(e)),
                this.groups = i
            },
            fromGeometry: function(t) {
                var e, r = t.faces, n = t.vertices, o = t.faceVertexUvs, a = o[0] && o[0].length > 0, s = o[1] && o[1].length > 0, h = t.morphTargets, c = h.length;
                if (c > 0) {
                    e = [];
                    for (var l = 0; l < c; l++)
                        e[l] = [];
                    this.morphTargets.position = e
                }
                var u, p = t.morphNormals, d = p.length;
                if (d > 0) {
                    u = [];
                    for (var l = 0; l < d; l++)
                        u[l] = [];
                    this.morphTargets.normal = u
                }
                for (var f = t.skinIndices, m = t.skinWeights, g = f.length === n.length, v = m.length === n.length, l = 0; l < r.length; l++) {
                    var y = r[l];
                    this.vertices.push(n[y.a], n[y.b], n[y.c]);
                    var x = y.vertexNormals;
                    if (3 === x.length)
                        this.normals.push(x[0], x[1], x[2]);
                    else {
                        var b = y.normal;
                        this.normals.push(b, b, b)
                    }
                    var w = y.vertexColors;
                    if (3 === w.length)
                        this.colors.push(w[0], w[1], w[2]);
                    else {
                        var _ = y.color;
                        this.colors.push(_, _, _)
                    }
                    if (a === !0) {
                        var M = o[0][l];
                        void 0 !== M ? this.uvs.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l),
                        this.uvs.push(new i.Vector2, new i.Vector2, new i.Vector2))
                    }
                    if (s === !0) {
                        var M = o[1][l];
                        void 0 !== M ? this.uvs2.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l),
                        this.uvs2.push(new i.Vector2, new i.Vector2, new i.Vector2))
                    }
                    for (var S = 0; S < c; S++) {
                        var E = h[S].vertices;
                        e[S].push(E[y.a], E[y.b], E[y.c])
                    }
                    for (var S = 0; S < d; S++) {
                        var T = p[S].vertexNormals[l];
                        u[S].push(T.a, T.b, T.c)
                    }
                    g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]),
                    v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                }
                return this.computeGroups(t),
                this.verticesNeedUpdate = t.verticesNeedUpdate,
                this.normalsNeedUpdate = t.normalsNeedUpdate,
                this.colorsNeedUpdate = t.colorsNeedUpdate,
                this.uvsNeedUpdate = t.uvsNeedUpdate,
                this.groupsNeedUpdate = t.groupsNeedUpdate,
                this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        },
        i.EventDispatcher.prototype.apply(i.DirectGeometry.prototype),
        i.BufferGeometry = function() {
            Object.defineProperty(this, "id", {
                value: i.GeometryIdCount++
            }),
            this.uuid = i.Math.generateUUID(),
            this.name = "",
            this.type = "BufferGeometry",
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.drawRange = {
                start: 0,
                count: 1 / 0
            }
        }
        ,
        i.BufferGeometry.prototype = {
            constructor: i.BufferGeometry,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                this.index = t
            },
            addAttribute: function(t, e) {
                return e instanceof i.BufferAttribute == !1 && e instanceof i.InterleavedBufferAttribute == !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
                void this.addAttribute(t, new i.BufferAttribute(arguments[1],arguments[2]))) : "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
                void this.setIndex(e)) : (this.attributes[t] = e,
                this)
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            removeAttribute: function(t) {
                return delete this.attributes[t],
                this
            },
            addGroup: function(t, e, r) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: void 0 !== r ? r : 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t,
                this.drawRange.count = e
            },
            applyMatrix: function(t) {
                var e = this.attributes.position;
                void 0 !== e && (t.applyToVector3Array(e.array),
                e.needsUpdate = !0);
                var r = this.attributes.normal;
                if (void 0 !== r) {
                    var n = (new i.Matrix3).getNormalMatrix(t);
                    n.applyToVector3Array(r.array),
                    r.needsUpdate = !0
                }
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere()
            },
            rotateX: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeRotationX(e),
                    this.applyMatrix(t),
                    this
                }
            }(),
            rotateY: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeRotationY(e),
                    this.applyMatrix(t),
                    this
                }
            }(),
            rotateZ: function() {
                var t;
                return function(e) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeRotationZ(e),
                    this.applyMatrix(t),
                    this
                }
            }(),
            translate: function() {
                var t;
                return function(e, r, n) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeTranslation(e, r, n),
                    this.applyMatrix(t),
                    this
                }
            }(),
            scale: function() {
                var t;
                return function(e, r, n) {
                    return void 0 === t && (t = new i.Matrix4),
                    t.makeScale(e, r, n),
                    this.applyMatrix(t),
                    this
                }
            }(),
            lookAt: function() {
                var t;
                return function(e) {
                    void 0 === t && (t = new i.Object3D),
                    t.lookAt(e),
                    t.updateMatrix(),
                    this.applyMatrix(t.matrix)
                }
            }(),
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.center().negate();
                return this.translate(t.x, t.y, t.z),
                t
            },
            setFromObject: function(t) {
                var e = t.geometry;
                if (t instanceof i.Points || t instanceof i.Line) {
                    var r = new i.Float32Attribute(3 * e.vertices.length,3)
                      , n = new i.Float32Attribute(3 * e.colors.length,3);
                    if (this.addAttribute("position", r.copyVector3sArray(e.vertices)),
                    this.addAttribute("color", n.copyColorsArray(e.colors)),
                    e.lineDistances && e.lineDistances.length === e.vertices.length) {
                        var o = new i.Float32Attribute(e.lineDistances.length,1);
                        this.addAttribute("lineDistance", o.copyArray(e.lineDistances))
                    }
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                    null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else
                    t instanceof i.Mesh && e instanceof i.Geometry && this.fromGeometry(e);
                return this
            },
            updateFromObject: function(t) {
                var e = t.geometry;
                if (t instanceof i.Mesh) {
                    var r = e.__directGeometry;
                    if (void 0 === r)
                        return this.fromGeometry(e);
                    r.verticesNeedUpdate = e.verticesNeedUpdate,
                    r.normalsNeedUpdate = e.normalsNeedUpdate,
                    r.colorsNeedUpdate = e.colorsNeedUpdate,
                    r.uvsNeedUpdate = e.uvsNeedUpdate,
                    r.groupsNeedUpdate = e.groupsNeedUpdate,
                    e.verticesNeedUpdate = !1,
                    e.normalsNeedUpdate = !1,
                    e.colorsNeedUpdate = !1,
                    e.uvsNeedUpdate = !1,
                    e.groupsNeedUpdate = !1,
                    e = r
                }
                if (e.verticesNeedUpdate === !0) {
                    var n = this.attributes.position;
                    void 0 !== n && (n.copyVector3sArray(e.vertices),
                    n.needsUpdate = !0),
                    e.verticesNeedUpdate = !1
                }
                if (e.normalsNeedUpdate === !0) {
                    var n = this.attributes.normal;
                    void 0 !== n && (n.copyVector3sArray(e.normals),
                    n.needsUpdate = !0),
                    e.normalsNeedUpdate = !1
                }
                if (e.colorsNeedUpdate === !0) {
                    var n = this.attributes.color;
                    void 0 !== n && (n.copyColorsArray(e.colors),
                    n.needsUpdate = !0),
                    e.colorsNeedUpdate = !1
                }
                if (e.uvsNeedUpdate) {
                    var n = this.attributes.uv;
                    void 0 !== n && (n.copyVector2sArray(e.uvs),
                    n.needsUpdate = !0),
                    e.uvsNeedUpdate = !1
                }
                if (e.lineDistancesNeedUpdate) {
                    var n = this.attributes.lineDistance;
                    void 0 !== n && (n.copyArray(e.lineDistances),
                    n.needsUpdate = !0),
                    e.lineDistancesNeedUpdate = !1
                }
                return e.groupsNeedUpdate && (e.computeGroups(t.geometry),
                this.groups = e.groups,
                e.groupsNeedUpdate = !1),
                this
            },
            fromGeometry: function(t) {
                return t.__directGeometry = (new i.DirectGeometry).fromGeometry(t),
                this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function(t) {
                var e = new Float32Array(3 * t.vertices.length);
                if (this.addAttribute("position", new i.BufferAttribute(e,3).copyVector3sArray(t.vertices)),
                t.normals.length > 0) {
                    var r = new Float32Array(3 * t.normals.length);
                    this.addAttribute("normal", new i.BufferAttribute(r,3).copyVector3sArray(t.normals))
                }
                if (t.colors.length > 0) {
                    var n = new Float32Array(3 * t.colors.length);
                    this.addAttribute("color", new i.BufferAttribute(n,3).copyColorsArray(t.colors))
                }
                if (t.uvs.length > 0) {
                    var o = new Float32Array(2 * t.uvs.length);
                    this.addAttribute("uv", new i.BufferAttribute(o,2).copyVector2sArray(t.uvs))
                }
                if (t.uvs2.length > 0) {
                    var a = new Float32Array(2 * t.uvs2.length);
                    this.addAttribute("uv2", new i.BufferAttribute(a,2).copyVector2sArray(t.uvs2))
                }
                if (t.indices.length > 0) {
                    var s = t.vertices.length > 65535 ? Uint32Array : Uint16Array
                      , h = new s(3 * t.indices.length);
                    this.setIndex(new i.BufferAttribute(h,1).copyIndicesArray(t.indices))
                }
                this.groups = t.groups;
                for (var c in t.morphTargets) {
                    for (var l = [], u = t.morphTargets[c], p = 0, d = u.length; p < d; p++) {
                        var f = u[p]
                          , m = new i.Float32Attribute(3 * f.length,3);
                        l.push(m.copyVector3sArray(f))
                    }
                    this.morphAttributes[c] = l
                }
                if (t.skinIndices.length > 0) {
                    var g = new i.Float32Attribute(4 * t.skinIndices.length,4);
                    this.addAttribute("skinIndex", g.copyVector4sArray(t.skinIndices))
                }
                if (t.skinWeights.length > 0) {
                    var v = new i.Float32Attribute(4 * t.skinWeights.length,4);
                    this.addAttribute("skinWeight", v.copyVector4sArray(t.skinWeights))
                }
                return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                this
            },
            computeBoundingBox: function() {
                new i.Vector3;
                return function() {
                    null === this.boundingBox && (this.boundingBox = new i.Box3);
                    var t = this.attributes.position.array;
                    t && this.boundingBox.setFromArray(t),
                    void 0 !== t && 0 !== t.length || (this.boundingBox.min.set(0, 0, 0),
                    this.boundingBox.max.set(0, 0, 0)),
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
            }(),
            computeBoundingSphere: function() {
                var t = new i.Box3
                  , e = new i.Vector3;
                return function() {
                    null === this.boundingSphere && (this.boundingSphere = new i.Sphere);
                    var r = this.attributes.position.array;
                    if (r) {
                        var n = this.boundingSphere.center;
                        t.setFromArray(r),
                        t.center(n);
                        for (var o = 0, a = 0, s = r.length; a < s; a += 3)
                            e.fromArray(r, a),
                            o = Math.max(o, n.distanceToSquared(e));
                        this.boundingSphere.radius = Math.sqrt(o),
                        isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
            }(),
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var t = this.index
                  , e = this.attributes
                  , r = this.groups;
                if (e.position) {
                    var n = e.position.array;
                    if (void 0 === e.normal)
                        this.addAttribute("normal", new i.BufferAttribute(new Float32Array(n.length),3));
                    else
                        for (var o = e.normal.array, a = 0, s = o.length; a < s; a++)
                            o[a] = 0;
                    var h, c, l, u = e.normal.array, p = new i.Vector3, d = new i.Vector3, f = new i.Vector3, m = new i.Vector3, g = new i.Vector3;
                    if (t) {
                        var v = t.array;
                        0 === r.length && this.addGroup(0, v.length);
                        for (var y = 0, x = r.length; y < x; ++y)
                            for (var b = r[y], w = b.start, _ = b.count, a = w, s = w + _; a < s; a += 3)
                                h = 3 * v[a + 0],
                                c = 3 * v[a + 1],
                                l = 3 * v[a + 2],
                                p.fromArray(n, h),
                                d.fromArray(n, c),
                                f.fromArray(n, l),
                                m.subVectors(f, d),
                                g.subVectors(p, d),
                                m.cross(g),
                                u[h] += m.x,
                                u[h + 1] += m.y,
                                u[h + 2] += m.z,
                                u[c] += m.x,
                                u[c + 1] += m.y,
                                u[c + 2] += m.z,
                                u[l] += m.x,
                                u[l + 1] += m.y,
                                u[l + 2] += m.z
                    } else
                        for (var a = 0, s = n.length; a < s; a += 9)
                            p.fromArray(n, a),
                            d.fromArray(n, a + 3),
                            f.fromArray(n, a + 6),
                            m.subVectors(f, d),
                            g.subVectors(p, d),
                            m.cross(g),
                            u[a] = m.x,
                            u[a + 1] = m.y,
                            u[a + 2] = m.z,
                            u[a + 3] = m.x,
                            u[a + 4] = m.y,
                            u[a + 5] = m.z,
                            u[a + 6] = m.x,
                            u[a + 7] = m.y,
                            u[a + 8] = m.z;
                    this.normalizeNormals(),
                    e.normal.needsUpdate = !0
                }
            },
            merge: function(t, e) {
                if (t instanceof i.BufferGeometry == !1)
                    return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0);
                var r = this.attributes;
                for (var n in r)
                    if (void 0 !== t.attributes[n])
                        for (var o = r[n], a = o.array, s = t.attributes[n], h = s.array, c = s.itemSize, l = 0, u = c * e; l < h.length; l++,
                        u++)
                            a[u] = h[l];
                return this
            },
            normalizeNormals: function() {
                for (var t, e, r, i, n = this.attributes.normal.array, o = 0, a = n.length; o < a; o += 3)
                    t = n[o],
                    e = n[o + 1],
                    r = n[o + 2],
                    i = 1 / Math.sqrt(t * t + e * e + r * r),
                    n[o] *= i,
                    n[o + 1] *= i,
                    n[o + 2] *= i
            },
            toNonIndexed: function() {
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                    this;
                var t = new i.BufferGeometry
                  , e = this.index.array
                  , r = this.attributes;
                for (var n in r) {
                    for (var o = r[n], a = o.array, s = o.itemSize, h = new a.constructor(e.length * s), c = 0, l = 0, u = 0, p = e.length; u < p; u++) {
                        c = e[u] * s;
                        for (var d = 0; d < s; d++)
                            h[l++] = a[c++]
                    }
                    t.addAttribute(n, new i.BufferAttribute(h,s))
                }
                return t
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.4,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid,
                t.type = this.type,
                "" !== this.name && (t.name = this.name),
                void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var r in e)
                        void 0 !== e[r] && (t[r] = e[r]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                var i = this.index;
                if (null !== i) {
                    var n = Array.prototype.slice.call(i.array);
                    t.data.index = {
                        type: i.array.constructor.name,
                        array: n
                    }
                }
                var o = this.attributes;
                for (var r in o) {
                    var a = o[r]
                      , n = Array.prototype.slice.call(a.array);
                    t.data.attributes[r] = {
                        itemSize: a.itemSize,
                        type: a.array.constructor.name,
                        array: n
                    }
                }
                var s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                var h = this.boundingSphere;
                return null !== h && (t.data.boundingSphere = {
                    center: h.center.toArray(),
                    radius: h.radius
                }),
                t
            },
            clone: function() {
                return (new i.BufferGeometry).copy(this)
            },
            copy: function(t) {
                var e = t.index;
                null !== e && this.setIndex(e.clone());
                var r = t.attributes;
                for (var i in r) {
                    var n = r[i];
                    this.addAttribute(i, n.clone())
                }
                for (var o = t.groups, a = 0, s = o.length; a < s; a++) {
                    var h = o[a];
                    this.addGroup(h.start, h.count)
                }
                return this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        },
        i.EventDispatcher.prototype.apply(i.BufferGeometry.prototype),
        i.BufferGeometry.MaxIndex = 65535,
        i.InstancedBufferGeometry = function() {
            i.BufferGeometry.call(this),
            this.type = "InstancedBufferGeometry",
            this.maxInstancedCount = void 0;
        }
        ,
        i.InstancedBufferGeometry.prototype = Object.create(i.BufferGeometry.prototype),
        i.InstancedBufferGeometry.prototype.constructor = i.InstancedBufferGeometry,
        i.InstancedBufferGeometry.prototype.addGroup = function(t, e, r) {
            this.groups.push({
                start: t,
                count: e,
                instances: r
            })
        }
        ,
        i.InstancedBufferGeometry.prototype.copy = function(t) {
            var e = t.index;
            null !== e && this.setIndex(e.clone());
            var r = t.attributes;
            for (var i in r) {
                var n = r[i];
                this.addAttribute(i, n.clone())
            }
            for (var o = t.groups, a = 0, s = o.length; a < s; a++) {
                var h = o[a];
                this.addGroup(h.start, h.count, h.instances)
            }
            return this
        }
        ,
        i.EventDispatcher.prototype.apply(i.InstancedBufferGeometry.prototype),
        i.Uniform = function(t, e) {
            this.type = t,
            this.value = e,
            this.dynamic = !1
        }
        ,
        i.Uniform.prototype = {
            constructor: i.Uniform,
            onUpdate: function(t) {
                return this.dynamic = !0,
                this.onUpdateCallback = t,
                this
            }
        },
        i.AnimationClip = function(t, e, r) {
            this.name = t || i.Math.generateUUID(),
            this.tracks = r,
            this.duration = void 0 !== e ? e : -1,
            this.duration < 0 && this.resetDuration(),
            this.trim(),
            this.optimize()
        }
        ,
        i.AnimationClip.prototype = {
            constructor: i.AnimationClip,
            resetDuration: function() {
                for (var t = this.tracks, e = 0, r = 0, i = t.length; r !== i; ++r) {
                    var n = this.tracks[r];
                    e = Math.max(e, n.times[n.times.length - 1])
                }
                this.duration = e
            },
            trim: function() {
                for (var t = 0; t < this.tracks.length; t++)
                    this.tracks[t].trim(0, this.duration);
                return this
            },
            optimize: function() {
                for (var t = 0; t < this.tracks.length; t++)
                    this.tracks[t].optimize();
                return this
            }
        },
        Object.assign(i.AnimationClip, {
            parse: function(t) {
                for (var e = [], r = t.tracks, n = 1 / (t.fps || 1), o = 0, a = r.length; o !== a; ++o)
                    e.push(i.KeyframeTrack.parse(r[o]).scale(n));
                return new i.AnimationClip(t.name,t.duration,e)
            },
            toJSON: function(t) {
                for (var e = [], r = t.tracks, n = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e
                }, o = 0, a = r.length; o !== a; ++o)
                    e.push(i.KeyframeTrack.toJSON(r[o]));
                return n
            },
            CreateFromMorphTargetSequence: function(t, e, r) {
                for (var n = e.length, o = [], a = 0; a < n; a++) {
                    var s = []
                      , h = [];
                    s.push((a + n - 1) % n, a, (a + 1) % n),
                    h.push(0, 1, 0);
                    var c = i.AnimationUtils.getKeyframeOrder(s);
                    s = i.AnimationUtils.sortedArray(s, 1, c),
                    h = i.AnimationUtils.sortedArray(h, 1, c),
                    0 === s[0] && (s.push(n),
                    h.push(h[0])),
                    o.push(new i.NumberKeyframeTrack(".morphTargetInfluences[" + e[a].name + "]",s,h).scale(1 / r))
                }
                return new i.AnimationClip(t,(-1),o)
            },
            findByName: function(t, e) {
                for (var r = 0; r < t.length; r++)
                    if (t[r].name === e)
                        return t[r];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(t, e) {
                for (var r = {}, n = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                    var s = t[o]
                      , h = s.name.match(n);
                    if (h && h.length > 1) {
                        var c = h[1]
                          , l = r[c];
                        l || (r[c] = l = []),
                        l.push(s)
                    }
                }
                var u = [];
                for (var c in r)
                    u.push(i.AnimationClip.CreateFromMorphTargetSequence(c, r[c], e));
                return u
            },
            parseAnimation: function(t, e, r) {
                if (!t)
                    return console.error("  no animation in JSONLoader data"),
                    null;
                for (var n = function(t, e, r, n, o) {
                    if (0 !== r.length) {
                        var a = []
                          , s = [];
                        i.AnimationUtils.flattenJSON(r, a, s, n),
                        0 !== a.length && o.push(new t(e,a,s))
                    }
                }, o = [], a = t.name || "default", s = t.length || -1, h = t.fps || 30, c = t.hierarchy || [], l = 0; l < c.length; l++) {
                    var u = c[l].keys;
                    if (u && 0 != u.length)
                        if (u[0].morphTargets) {
                            for (var p = {}, d = 0; d < u.length; d++)
                                if (u[d].morphTargets)
                                    for (var f = 0; f < u[d].morphTargets.length; f++)
                                        p[u[d].morphTargets[f]] = -1;
                            for (var m in p) {
                                for (var g = [], v = [], f = 0; f !== u[d].morphTargets.length; ++f) {
                                    var y = u[d];
                                    g.push(y.time),
                                    v.push(y.morphTarget === m ? 1 : 0)
                                }
                                o.push(new i.NumberKeyframeTrack(".morphTargetInfluence[" + m + "]",g,v))
                            }
                            s = p.length * (h || 1)
                        } else {
                            var x = ".bones[" + e[l].name + "]";
                            n(i.VectorKeyframeTrack, x + ".position", u, "pos", o),
                            n(i.QuaternionKeyframeTrack, x + ".quaternion", u, "rot", o),
                            n(i.VectorKeyframeTrack, x + ".scale", u, "scl", o)
                        }
                }
                if (0 === o.length)
                    return null;
                var b = new i.AnimationClip(a,s,o);
                return b
            }
        }),
        i.AnimationMixer = function(t) {
            this._root = t,
            this._initMemoryManager(),
            this._accuIndex = 0,
            this.time = 0,
            this.timeScale = 1
        }
        ,
        i.AnimationMixer.prototype = {
            constructor: i.AnimationMixer,
            clipAction: function(t, e) {
                var r, n = e || this._root, o = n.uuid, a = "string" == typeof t ? t : t.name, s = t !== a ? t : null, h = this._actionsByClip[a];
                if (void 0 !== h) {
                    var c = h.actionByRoot[o];
                    if (void 0 !== c)
                        return c;
                    if (r = h.knownActions[0],
                    s = r._clip,
                    t !== a && t !== s)
                        throw new Error("Different clips with the same name detected!")
                }
                if (null === s)
                    return null;
                var l = new i.AnimationMixer._Action(this,s,e);
                return this._bindAction(l, r),
                this._addInactiveAction(l, a, o),
                l
            },
            existingAction: function(t, e) {
                var r = e || this._root
                  , i = r.uuid
                  , n = "string" == typeof t ? t : t.name
                  , o = this._actionsByClip[n];
                return void 0 !== o ? o.actionByRoot[i] || null : null
            },
            stopAllAction: function() {
                var t = this._actions
                  , e = this._nActiveActions
                  , r = this._bindings
                  , i = this._nActiveBindings;
                this._nActiveActions = 0,
                this._nActiveBindings = 0;
                for (var n = 0; n !== e; ++n)
                    t[n].reset();
                for (var n = 0; n !== i; ++n)
                    r[n].useCount = 0;
                return this
            },
            update: function(t) {
                t *= this.timeScale;
                for (var e = this._actions, r = this._nActiveActions, i = this.time += t, n = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== r; ++a) {
                    var s = e[a];
                    s.enabled && s._update(i, t, n, o)
                }
                for (var h = this._bindings, c = this._nActiveBindings, a = 0; a !== c; ++a)
                    h[a].apply(o);
                return this
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(t) {
                var e = this._actions
                  , r = t.name
                  , i = this._actionsByClip
                  , n = i[r];
                if (void 0 !== n) {
                    for (var o = n.knownActions, a = 0, s = o.length; a !== s; ++a) {
                        var h = o[a];
                        this._deactivateAction(h);
                        var c = h._cacheIndex
                          , l = e[e.length - 1];
                        h._cacheIndex = null,
                        h._byClipCacheIndex = null,
                        l._cacheIndex = c,
                        e[c] = l,
                        e.pop(),
                        this._removeInactiveBindingsForAction(h)
                    }
                    delete i[r]
                }
            },
            uncacheRoot: function(t) {
                var e = t.uuid
                  , r = this._actionsByClip;
                for (var i in r) {
                    var n = r[i].actionByRoot
                      , o = n[e];
                    void 0 !== o && (this._deactivateAction(o),
                    this._removeInactiveAction(o))
                }
                var a = this._bindingsByRootAndName
                  , s = a[e];
                if (void 0 !== s)
                    for (var h in s) {
                        var c = s[h];
                        c.restoreOriginalState(),
                        this._removeInactiveBinding(c)
                    }
            },
            uncacheAction: function(t, e) {
                var r = this.existingAction(t, e);
                null !== r && (this._deactivateAction(r),
                this._removeInactiveAction(r))
            }
        },
        i.EventDispatcher.prototype.apply(i.AnimationMixer.prototype),
        i.AnimationMixer._Action = function(t, e, r) {
            this._mixer = t,
            this._clip = e,
            this._localRoot = r || null;
            for (var n = e.tracks, o = n.length, a = new Array(o), s = {
                endingStart: i.ZeroCurvatureEnding,
                endingEnd: i.ZeroCurvatureEnding
            }, h = 0; h !== o; ++h) {
                var c = n[h].createInterpolant(null);
                a[h] = c,
                c.settings = s
            }
            this._interpolantSettings = s,
            this._interpolants = a,
            this._propertyBindings = new Array(o),
            this._cacheIndex = null,
            this._byClipCacheIndex = null,
            this._timeScaleInterpolant = null,
            this._weightInterpolant = null,
            this.loop = i.LoopRepeat,
            this._loopCount = -1,
            this._startTime = null,
            this.time = 0,
            this.timeScale = 1,
            this._effectiveTimeScale = 1,
            this.weight = 1,
            this._effectiveWeight = 1,
            this.repetitions = 1 / 0,
            this.paused = !1,
            this.enabled = !0,
            this.clampWhenFinished = !1,
            this.zeroSlopeAtStart = !0,
            this.zeroSlopeAtEnd = !0
        }
        ,
        i.AnimationMixer._Action.prototype = {
            constructor: i.AnimationMixer._Action,
            play: function() {
                return this._mixer._activateAction(this),
                this
            },
            stop: function() {
                return this._mixer._deactivateAction(this),
                this.reset()
            },
            reset: function() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            },
            isRunning: function() {
                this._startTime;
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(t) {
                return this._startTime = t,
                this
            },
            setLoop: function(t, e) {
                return this.loop = t,
                this.repetitions = e,
                this
            },
            setEffectiveWeight: function(t) {
                return this.weight = t,
                this._effectiveWeight = this.enabled ? t : 0,
                this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(t) {
                return this._scheduleFading(t, 0, 1)
            },
            fadeOut: function(t) {
                return this._scheduleFading(t, 1, 0)
            },
            crossFadeFrom: function(t, e, r) {
                this._mixer;
                if (t.fadeOut(e),
                this.fadeIn(e),
                r) {
                    var i = this._clip.duration
                      , n = t._clip.duration
                      , o = n / i
                      , a = i / n;
                    t.warp(1, o, e),
                    this.warp(a, 1, e)
                }
                return this
            },
            crossFadeTo: function(t, e, r) {
                return t.crossFadeFrom(this, e, r)
            },
            stopFading: function() {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            },
            setEffectiveTimeScale: function(t) {
                return this.timeScale = t,
                this._effectiveTimeScale = this.paused ? 0 : t,
                this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(t) {
                return this.timeScale = this._clip.duration / t,
                this.stopWarping()
            },
            syncWith: function(t) {
                return this.time = t.time,
                this.timeScale = t.timeScale,
                this.stopWarping()
            },
            halt: function(t) {
                return this.warp(this._currentTimeScale, 0, t)
            },
            warp: function(t, e, r) {
                var i = this._mixer
                  , n = i.time
                  , o = this._timeScaleInterpolant
                  , a = this.timeScale;
                null === o && (o = i._lendControlInterpolant(),
                this._timeScaleInterpolant = o);
                var s = o.parameterPositions
                  , h = o.sampleValues;
                return s[0] = n,
                s[1] = n + r,
                h[0] = t / a,
                h[1] = e / a,
                this
            },
            stopWarping: function() {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(t, e, r, i) {
                var n = this._startTime;
                if (null !== n) {
                    var o = (t - n) * r;
                    if (o < 0 || 0 === r)
                        return;
                    this._startTime = null,
                    e = r * o
                }
                e *= this._updateTimeScale(t);
                var a = this._updateTime(e)
                  , s = this._updateWeight(t);
                if (s > 0)
                    for (var h = this._interpolants, c = this._propertyBindings, l = 0, u = h.length; l !== u; ++l)
                        h[l].evaluate(a),
                        c[l].accumulate(i, s)
            },
            _updateWeight: function(t) {
                var e = 0;
                if (this.enabled) {
                    e = this.weight;
                    var r = this._weightInterpolant;
                    if (null !== r) {
                        var i = r.evaluate(t)[0];
                        e *= i,
                        t > r.parameterPositions[1] && (this.stopFading(),
                        0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e,
                e
            },
            _updateTimeScale: function(t) {
                var e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    var r = this._timeScaleInterpolant;
                    if (null !== r) {
                        var i = r.evaluate(t)[0];
                        e *= i,
                        t > r.parameterPositions[1] && (this.stopWarping(),
                        0 === e ? this.pause = !0 : this.timeScale = e)
                    }
                }
                return this._effectiveTimeScale = e,
                e
            },
            _updateTime: function(t) {
                var e = this.time + t;
                if (0 === t)
                    return e;
                var r = this._clip.duration
                  , n = this.loop
                  , o = this._loopCount
                  , a = !1;
                switch (n) {
                case i.LoopOnce:
                    if (o === -1 && (this.loopCount = 0,
                    this._setEndings(!0, !0, !1)),
                    e >= r)
                        e = r;
                    else {
                        if (!(e < 0))
                            break;
                        e = 0
                    }
                    this.clampWhenFinished ? this.pause = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    });
                    break;
                case i.LoopPingPong:
                    a = !0;
                case i.LoopRepeat:
                    if (o === -1 && (t > 0 ? (o = 0,
                    this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)),
                    e >= r || e < 0) {
                        var s = Math.floor(e / r);
                        e -= r * s,
                        o += Math.abs(s);
                        var h = this.repetitions - o;
                        if (h < 0) {
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            e = t > 0 ? r : 0,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                            break
                        }
                        if (0 === h) {
                            var c = t < 0;
                            this._setEndings(c, !c, a)
                        } else
                            this._setEndings(!1, !1, a);
                        this._loopCount = o,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: s
                        })
                    }
                    if (n === i.LoopPingPong && 1 === (1 & o))
                        return this.time = e,
                        r - e
                }
                return this.time = e,
                e
            },
            _setEndings: function(t, e, r) {
                var n = this._interpolantSettings;
                r ? (n.endingStart = i.ZeroSlopeEnding,
                n.endingEnd = i.ZeroSlopeEnding) : (t ? n.endingStart = this.zeroSlopeAtStart ? i.ZeroSlopeEnding : i.ZeroCurvatureEnding : n.endingStart = i.WrapAroundEnding,
                e ? n.endingEnd = this.zeroSlopeAtEnd ? i.ZeroSlopeEnding : i.ZeroCurvatureEnding : n.endingEnd = i.WrapAroundEnding)
            },
            _scheduleFading: function(t, e, r) {
                var i = this._mixer
                  , n = i.time
                  , o = this._weightInterpolant;
                null === o && (o = i._lendControlInterpolant(),
                this._weightInterpolant = o);
                var a = o.parameterPositions
                  , s = o.sampleValues;
                return a[0] = n,
                s[0] = e,
                a[1] = n + t,
                s[1] = r,
                this
            }
        },
        Object.assign(i.AnimationMixer.prototype, {
            _bindAction: function(t, e) {
                var r = t._localRoot || this._root
                  , n = t._clip.tracks
                  , o = n.length
                  , a = t._propertyBindings
                  , s = t._interpolants
                  , h = r.uuid
                  , c = this._bindingsByRootAndName
                  , l = c[h];
                void 0 === l && (l = {},
                c[h] = l);
                for (var u = 0; u !== o; ++u) {
                    var p = n[u]
                      , d = p.name
                      , f = l[d];
                    if (void 0 !== f)
                        a[u] = f;
                    else {
                        if (f = a[u],
                        void 0 !== f) {
                            null === f._cacheIndex && (++f.referenceCount,
                            this._addInactiveBinding(f, h, d));
                            continue
                        }
                        var m = e && e._propertyBindings[u].binding.parsedPath;
                        f = new i.PropertyMixer(i.PropertyBinding.create(r, d, m),p.ValueTypeName,p.getValueSize()),
                        ++f.referenceCount,
                        this._addInactiveBinding(f, h, d),
                        a[u] = f
                    }
                    s[u].resultBuffer = f.buffer
                }
            },
            _activateAction: function(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        var e = (t._localRoot || this._root).uuid
                          , r = t._clip.name
                          , i = this._actionsByClip[r];
                        this._bindAction(t, i && i.knownActions[0]),
                        this._addInactiveAction(t, r, e)
                    }
                    for (var n = t._propertyBindings, o = 0, a = n.length; o !== a; ++o) {
                        var s = n[o];
                        0 === s.useCount++ && (this._lendBinding(s),
                        s.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function(t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, r = 0, i = e.length; r !== i; ++r) {
                        var n = e[r];
                        0 === --n.useCount && (n.restoreOriginalState(),
                        this._takeBackBinding(n))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(t) {
                var e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            },
            _addInactiveAction: function(t, e, r) {
                var i = this._actions
                  , n = this._actionsByClip
                  , o = n[e];
                if (void 0 === o)
                    o = {
                        knownActions: [t],
                        actionByRoot: {}
                    },
                    t._byClipCacheIndex = 0,
                    n[e] = o;
                else {
                    var a = o.knownActions;
                    t._byClipCacheIndex = a.length,
                    a.push(t)
                }
                t._cacheIndex = i.length,
                i.push(t),
                o.actionByRoot[r] = t
            },
            _removeInactiveAction: function(t) {
                var e = this._actions
                  , r = e[e.length - 1]
                  , i = t._cacheIndex;
                r._cacheIndex = i,
                e[i] = r,
                e.pop(),
                t._cacheIndex = null;
                var n = t._clip.name
                  , o = this._actionsByClip
                  , a = o[n]
                  , s = a.knownActions
                  , h = s[s.length - 1]
                  , c = t._byClipCacheIndex;
                h._byClipCacheIndex = c,
                s[c] = h,
                s.pop(),
                t._byClipCacheIndex = null;
                var l = a.actionByRoot
                  , u = (e._localRoot || this._root).uuid;
                delete l[u],
                0 === s.length && delete o[n],
                this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function(t) {
                for (var e = t._propertyBindings, r = 0, i = e.length; r !== i; ++r) {
                    var n = e[r];
                    0 === --n.referenceCount && this._removeInactiveBinding(n)
                }
            },
            _lendAction: function(t) {
                var e = this._actions
                  , r = t._cacheIndex
                  , i = this._nActiveActions++
                  , n = e[i];
                t._cacheIndex = i,
                e[i] = t,
                n._cacheIndex = r,
                e[r] = n
            },
            _takeBackAction: function(t) {
                var e = this._actions
                  , r = t._cacheIndex
                  , i = --this._nActiveActions
                  , n = e[i];
                t._cacheIndex = i,
                e[i] = t,
                n._cacheIndex = r,
                e[r] = n
            },
            _addInactiveBinding: function(t, e, r) {
                var i = this._bindingsByRootAndName
                  , n = i[e]
                  , o = this._bindings;
                void 0 === n && (n = {},
                i[e] = n),
                n[r] = t,
                t._cacheIndex = o.length,
                o.push(t)
            },
            _removeInactiveBinding: function(t) {
                var e = this._bindings
                  , r = t.binding
                  , i = r.rootNode.uuid
                  , n = r.path
                  , o = this._bindingsByRootAndName
                  , a = o[i]
                  , s = e[e.length - 1]
                  , h = t._cacheIndex;
                s._cacheIndex = h,
                e[h] = s,
                e.pop(),
                delete a[n];
                t: {
                    for (var c in a)
                        break t;
                    delete o[i]
                }
            },
            _lendBinding: function(t) {
                var e = this._bindings
                  , r = t._cacheIndex
                  , i = this._nActiveBindings++
                  , n = e[i];
                t._cacheIndex = i,
                e[i] = t,
                n._cacheIndex = r,
                e[r] = n
            },
            _takeBackBinding: function(t) {
                var e = this._bindings
                  , r = t._cacheIndex
                  , i = --this._nActiveBindings
                  , n = e[i];
                t._cacheIndex = i,
                e[i] = t,
                n._cacheIndex = r,
                e[r] = n
            },
            _lendControlInterpolant: function() {
                var t = this._controlInterpolants
                  , e = this._nActiveControlInterpolants++
                  , r = t[e];
                return void 0 === r && (r = new i.LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
                r.__cacheIndex = e,
                t[e] = r),
                r
            },
            _takeBackControlInterpolant: function(t) {
                var e = this._controlInterpolants
                  , r = t.__cacheIndex
                  , i = --this._nActiveControlInterpolants
                  , n = e[i];
                t.__cacheIndex = i,
                e[i] = t,
                n.__cacheIndex = r,
                e[r] = n
            },
            _controlInterpolantsResultBuffer: new Float32Array(1)
        }),
        i.AnimationObjectGroup = function(t) {
            this.uuid = i.Math.generateUUID(),
            this._objects = Array.prototype.slice.call(arguments),
            this.nCachedObjects_ = 0;
            var e = {};
            this._indicesByUUID = e;
            for (var r = 0, n = arguments.length; r !== n; ++r)
                e[arguments[r].uuid] = r;
            this._paths = [],
            this._parsedPaths = [],
            this._bindings = [],
            this._bindingsIndicesByPath = {};
            var o = this;
            this.stats = {
                objects: {
                    get total() {
                        return o._objects.length
                    },
                    get inUse() {
                        return this.total - o.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return o._bindings.length
                }
            }
        }
        ,
        i.AnimationObjectGroup.prototype = {
            constructor: i.AnimationObjectGroup,
            add: function(t) {
                for (var e = this._objects, r = e.length, n = this.nCachedObjects_, o = this._indicesByUUID, a = this._paths, s = this._parsedPaths, h = this._bindings, c = h.length, l = 0, u = arguments.length; l !== u; ++l) {
                    var p = arguments[l]
                      , d = p.uuid
                      , f = o[d];
                    if (void 0 === f) {
                        f = r++,
                        o[d] = f,
                        e.push(p);
                        for (var m = 0, g = c; m !== g; ++m)
                            h[m].push(new i.PropertyBinding(p,a[m],s[m]))
                    } else if (f < n) {
                        var v = e[f]
                          , y = --n
                          , x = e[y];
                        o[x.uuid] = f,
                        e[f] = x,
                        o[d] = y,
                        e[y] = p;
                        for (var m = 0, g = c; m !== g; ++m) {
                            var b = h[m]
                              , w = b[y]
                              , _ = b[f];
                            b[f] = w,
                            void 0 === _ && (_ = new i.PropertyBinding(p,a[m],s[m])),
                            b[y] = _
                        }
                    } else
                        e[f] !== v && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                }
                this.nCachedObjects_ = n
            },
            remove: function(t) {
                for (var e = this._objects, r = (e.length,
                this.nCachedObjects_), i = this._indicesByUUID, n = this._bindings, o = n.length, a = 0, s = arguments.length; a !== s; ++a) {
                    var h = arguments[a]
                      , c = h.uuid
                      , l = i[c];
                    if (void 0 !== l && l >= r) {
                        var u = r++
                          , p = e[u];
                        i[p.uuid] = l,
                        e[l] = p,
                        i[c] = u,
                        e[u] = h;
                        for (var d = 0, f = o; d !== f; ++d) {
                            var m = n[d]
                              , g = m[u]
                              , v = m[l];
                            m[l] = g,
                            m[u] = v
                        }
                    }
                }
                this.nCachedObjects_ = r
            },
            uncache: function(t) {
                for (var e = this._objects, r = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, o = this._bindings, a = o.length, s = 0, h = arguments.length; s !== h; ++s) {
                    var c = arguments[s]
                      , l = c.uuid
                      , u = n[l];
                    if (void 0 !== u)
                        if (delete n[l],
                        u < i) {
                            var p = --i
                              , d = e[p]
                              , f = --r
                              , m = e[f];
                            n[d.uuid] = u,
                            e[u] = d,
                            n[m.uuid] = p,
                            e[p] = m,
                            e.pop();
                            for (var g = 0, v = a; g !== v; ++g) {
                                var y = o[g]
                                  , x = y[p]
                                  , b = y[f];
                                y[u] = x,
                                y[p] = b,
                                y.pop()
                            }
                        } else {
                            var f = --r
                              , m = e[f];
                            n[m.uuid] = u,
                            e[u] = m,
                            e.pop();
                            for (var g = 0, v = a; g !== v; ++g) {
                                var y = o[g];
                                y[u] = y[f],
                                y.pop()
                            }
                        }
                }
                this.nCachedObjects_ = i
            },
            subscribe_: function(t, e) {
                var r = this._bindingsIndicesByPath
                  , n = r[t]
                  , o = this._bindings;
                if (void 0 !== n)
                    return o[n];
                var a = this._paths
                  , s = this._parsedPaths
                  , h = this._objects
                  , c = h.length
                  , l = this.nCachedObjects_
                  , u = new Array(c);
                n = o.length,
                r[t] = n,
                a.push(t),
                s.push(e),
                o.push(u);
                for (var p = l, d = h.length; p !== d; ++p) {
                    var f = h[p];
                    u[p] = new i.PropertyBinding(f,t,e)
                }
                return u
            },
            unsubscribe_: function(t) {
                var e = this._bindingsIndicesByPath
                  , r = e[t];
                if (void 0 !== r) {
                    var i = this._paths
                      , n = this._parsedPaths
                      , o = this._bindings
                      , a = o.length - 1
                      , s = o[a]
                      , h = t[a];
                    e[h] = r,
                    o[r] = s,
                    o.pop(),
                    n[r] = n[a],
                    n.pop(),
                    i[r] = i[a],
                    i.pop()
                }
            }
        },
        i.AnimationUtils = {
            arraySlice: function(t, e, r) {
                return i.AnimationUtils.isTypedArray(t) ? new t.constructor(t.subarray(e, r)) : t.slice(e, r)
            },
            convertArray: function(t, e, r) {
                return !t || !r && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                function e(e, r) {
                    return t[e] - t[r]
                }
                for (var r = t.length, i = new Array(r), n = 0; n !== r; ++n)
                    i[n] = n;
                return i.sort(e),
                i
            },
            sortedArray: function(t, e, r) {
                for (var i = t.length, n = new t.constructor(i), o = 0, a = 0; a !== i; ++o)
                    for (var s = r[o] * e, h = 0; h !== e; ++h)
                        n[a++] = t[s + h];
                return n
            },
            flattenJSON: function(t, e, r, i) {
                for (var n = 1, o = t[0]; void 0 !== o && void 0 === o[i]; )
                    o = t[n++];
                if (void 0 !== o) {
                    var a = o[i];
                    if (void 0 !== a)
                        if (Array.isArray(a)) {
                            do
                                a = o[i],
                                void 0 !== a && (e.push(o.time),
                                r.push.apply(r, a)),
                                o = t[n++];
                            while (void 0 !== o)
                        } else if (void 0 !== a.toArray) {
                            do
                                a = o[i],
                                void 0 !== a && (e.push(o.time),
                                a.toArray(r, r.length)),
                                o = t[n++];
                            while (void 0 !== o)
                        } else
                            do
                                a = o[i],
                                void 0 !== a && (e.push(o.time),
                                r.push(a)),
                                o = t[n++];
                            while (void 0 !== o)
                }
            }
        },
        i.KeyframeTrack = function(t, e, r, n) {
            if (void 0 === t)
                throw new Error("track name is undefined");
            if (void 0 === e || 0 === e.length)
                throw new Error("no keyframes in track named " + t);
            this.name = t,
            this.times = i.AnimationUtils.convertArray(e, this.TimeBufferType),
            this.values = i.AnimationUtils.convertArray(r, this.ValueBufferType),
            this.setInterpolation(n || this.DefaultInterpolation),
            this.validate(),
            this.optimize()
        }
        ,
        i.KeyframeTrack.prototype = {
            constructor: i.KeyframeTrack,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: i.InterpolateLinear,
            InterpolantFactoryMethodDiscrete: function(t) {
                return new i.DiscreteInterpolant(this.times,this.values,this.getValueSize(),t)
            },
            InterpolantFactoryMethodLinear: function(t) {
                return new i.LinearInterpolant(this.times,this.values,this.getValueSize(),t)
            },
            InterpolantFactoryMethodSmooth: function(t) {
                return new i.CubicInterpolant(this.times,this.values,this.getValueSize(),t)
            },
            setInterpolation: function(t) {
                var e = void 0;
                switch (t) {
                case i.InterpolateDiscrete:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case i.InterpolateLinear:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case i.InterpolateSmooth:
                    e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    var r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation)
                            throw new Error(r);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return void console.warn(r)
                }
                this.createInterpolant = e
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return i.InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                    return i.InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                    return i.InterpolateSmooth
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(t) {
                if (0 !== t)
                    for (var e = this.times, r = 0, i = e.length; r !== i; ++r)
                        e[r] += t;
                return this
            },
            scale: function(t) {
                if (1 !== t)
                    for (var e = this.times, r = 0, i = e.length; r !== i; ++r)
                        e[r] *= t;
                return this
            },
            trim: function(t, e) {
                for (var r = this.times, n = r.length, o = 0, a = n - 1; o !== n && r[o] < t; )
                    ++o;
                for (; a !== -1 && r[a] > e; )
                    --a;
                if (++a,
                0 !== o || a !== n) {
                    o >= a && (a = Math.max(a, 1),
                    o = a - 1);
                    var s = this.getValueSize();
                    this.times = i.AnimationUtils.arraySlice(r, o, a),
                    this.values = i.AnimationUtils.arraySlice(this.values, o * s, a * s)
                }
                return this
            },
            validate: function() {
                var t = !0
                  , e = this.getValueSize();
                e - Math.floor(e) !== 0 && (console.error("invalid value size in track", this),
                t = !1);
                var r = this.times
                  , n = this.values
                  , o = r.length;
                0 === o && (console.error("track is empty", this),
                t = !1);
                for (var a = null, s = 0; s !== o; s++) {
                    var h = r[s];
                    if ("number" == typeof h && isNaN(h)) {
                        console.error("time is not a valid number", this, s, h),
                        t = !1;
                        break
                    }
                    if (null !== a && a > h) {
                        console.error("out of order keys", this, s, h, a),
                        t = !1;
                        break
                    }
                    a = h
                }
                if (void 0 !== n && i.AnimationUtils.isTypedArray(n))
                    for (var s = 0, c = n.length; s !== c; ++s) {
                        var l = n[s];
                        if (isNaN(l)) {
                            console.error("value is not a valid number", this, s, l),
                            t = !1;
                            break
                        }
                    }
                return t
            },
            optimize: function() {
                for (var t = this.times, e = this.values, r = this.getValueSize(), n = 1, o = 1, a = t.length - 1; o <= a; ++o) {
                    var s = !1
                      , h = t[o]
                      , c = t[o + 1];
                    if (h !== c && (1 !== o || h !== h[0]))
                        for (var l = o * r, u = l - r, p = l + r, d = 0; d !== r; ++d) {
                            var f = e[l + d];
                            if (f !== e[u + d] || f !== e[p + d]) {
                                s = !0;
                                break
                            }
                        }
                    if (s) {
                        if (o !== n) {
                            t[n] = t[o];
                            for (var m = o * r, g = n * r, d = 0; d !== r; ++d)
                                e[g + d] = e[m + d]
                        }
                        ++n
                    }
                }
                return n !== t.length && (this.times = i.AnimationUtils.arraySlice(t, 0, n),
                this.values = i.AnimationUtils.arraySlice(e, 0, n * r)),
                this
            }
        },
        Object.assign(i.KeyframeTrack, {
            parse: function(t) {
                if (void 0 === t.type)
                    throw new Error("track type undefined, can not parse");
                var e = i.KeyframeTrack._getTrackTypeForValueTypeName(t.type);
                if (void 0 === t.times) {
                    console.warn("legacy JSON format detected, converting");
                    var r = []
                      , n = [];
                    i.AnimationUtils.flattenJSON(t.keys, r, n, "value"),
                    t.times = r,
                    t.values = n
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
            },
            toJSON: function(t) {
                var e, r = t.constructor;
                if (void 0 !== r.toJSON)
                    e = r.toJSON(t);
                else {
                    e = {
                        name: t.name,
                        times: i.AnimationUtils.convertArray(t.times, Array),
                        values: i.AnimationUtils.convertArray(t.values, Array)
                    };
                    var n = t.getInterpolation();
                    n !== t.DefaultInterpolation && (e.interpolation = n)
                }
                return e.type = t.ValueTypeName,
                e
            },
            _getTrackTypeForValueTypeName: function(t) {
                switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return i.NumberKeyframeTrack;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return i.VectorKeyframeTrack;
                case "color":
                    return i.ColorKeyframeTrack;
                case "quaternion":
                    return i.QuaternionKeyframeTrack;
                case "bool":
                case "boolean":
                    return i.BooleanKeyframeTrack;
                case "string":
                    return i.StringKeyframeTrack
                }
                throw new Error("Unsupported typeName: " + t)
            }
        }),
        i.PropertyBinding = function(t, e, r) {
            this.path = e,
            this.parsedPath = r || i.PropertyBinding.parseTrackName(e),
            this.node = i.PropertyBinding.findNode(t, this.parsedPath.nodeName) || t,
            this.rootNode = t
        }
        ,
        i.PropertyBinding.prototype = {
            constructor: i.PropertyBinding,
            getValue: function(t, e) {
                this.bind(),
                this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(),
                this.setValue(t, e)
            },
            bind: function() {
                var t = this.node
                  , e = this.parsedPath
                  , r = e.objectName
                  , n = e.propertyName
                  , o = e.propertyIndex;
                if (t || (t = i.PropertyBinding.findNode(this.rootNode, e.nodeName) || this.rootNode,
                this.node = t),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !t)
                    return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                if (r) {
                    var a = e.objectIndex;
                    switch (r) {
                    case "materials":
                        if (!t.material)
                            return void console.error("  can not bind to material as node does not have a material", this);
                        if (!t.material.materials)
                            return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("  can not bind to bones as node does not have a skeleton", this);
                        t = t.skeleton.bones;
                        for (var s = 0; s < t.length; s++)
                            if (t[s].name === a) {
                                a = s;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[r])
                            return void console.error("  can not bind to objectName of node, undefined", this);
                        t = t[r]
                    }
                    if (void 0 !== a) {
                        if (void 0 === t[a])
                            return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, t);
                        t = t[a]
                    }
                }
                var h = t[n];
                if (!h) {
                    var c = e.nodeName;
                    return void console.error("  trying to update property for track: " + c + "." + n + " but it wasn't found.", t)
                }
                var l = this.Versioning.None;
                void 0 !== t.needsUpdate ? (l = this.Versioning.NeedsUpdate,
                this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate,
                this.targetObject = t);
                var u = this.BindingType.Direct;
                if (void 0 !== o) {
                    if ("morphTargetInfluences" === n) {
                        if (!t.geometry)
                            return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                        if (!t.geometry.morphTargets)
                            return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                        for (var s = 0; s < this.node.geometry.morphTargets.length; s++)
                            if (t.geometry.morphTargets[s].name === o) {
                                o = s;
                                break
                            }
                    }
                    u = this.BindingType.ArrayElement,
                    this.resolvedProperty = h,
                    this.propertyIndex = o
                } else
                    void 0 !== h.fromArray && void 0 !== h.toArray ? (u = this.BindingType.HasFromToArray,
                    this.resolvedProperty = h) : void 0 !== h.length ? (u = this.BindingType.EntireArray,
                    this.resolvedProperty = h) : this.propertyName = n;
                this.getValue = this.GetterByBindingType[u],
                this.setValue = this.SetterByBindingTypeAndVersioning[u][l]
            },
            unbind: function() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        },
        Object.assign(i.PropertyBinding.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            _getValue_unbound: i.PropertyBinding.prototype.getValue,
            _setValue_unbound: i.PropertyBinding.prototype.setValue,
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            }
            , function(t, e) {
                for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                    t[e++] = r[i]
            }
            , function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            , function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            ],
            SetterByBindingTypeAndVersioning: [[function(t, e) {
                this.node[this.propertyName] = t[e]
            }
            , function(t, e) {
                this.node[this.propertyName] = t[e],
                this.targetObject.needsUpdate = !0
            }
            , function(t, e) {
                this.node[this.propertyName] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            ], [function(t, e) {
                for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                    r[i] = t[e++]
            }
            , function(t, e) {
                for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                    r[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            , function(t, e) {
                for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                    r[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            ], [function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            , function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.needsUpdate = !0
            }
            , function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            ], [function(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            , function(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.needsUpdate = !0
            }
            , function(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            ]]
        }),
        i.PropertyBinding.Composite = function(t, e, r) {
            var n = r || i.PropertyBinding.parseTrackName(e);
            this._targetGroup = t,
            this._bindings = t.subscribe_(e, n)
        }
        ,
        i.PropertyBinding.Composite.prototype = {
            constructor: i.PropertyBinding.Composite,
            getValue: function(t, e) {
                this.bind();
                var r = this._targetGroup.nCachedObjects_
                  , i = this._bindings[r];
                void 0 !== i && i.getValue(t, e)
            },
            setValue: function(t, e) {
                for (var r = this._bindings, i = this._targetGroup.nCachedObjects_, n = r.length; i !== n; ++i)
                    r[i].setValue(t, e)
            },
            bind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, r = t.length; e !== r; ++e)
                    t[e].bind()
            },
            unbind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, r = t.length; e !== r; ++e)
                    t[e].unbind()
            }
        },
        i.PropertyBinding.create = function(t, e, r) {
            return t instanceof i.AnimationObjectGroup ? new i.PropertyBinding.Composite(t,e,r) : new i.PropertyBinding(t,e,r)
        }
        ,
        i.PropertyBinding.parseTrackName = function(t) {
            var e = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/
              , r = e.exec(t);
            if (!r)
                throw new Error("cannot parse trackName at all: " + t);
            r.index === e.lastIndex && e.lastIndex++;
            var i = {
                nodeName: r[3],
                objectName: r[5],
                objectIndex: r[7],
                propertyName: r[9],
                propertyIndex: r[11]
            };
            if (null === i.propertyName || 0 === i.propertyName.length)
                throw new Error("can not parse propertyName from trackName: " + t);
            return i
        }
        ,
        i.PropertyBinding.findNode = function(t, e) {
            if (!e || "" === e || "root" === e || "." === e || e === -1 || e === t.name || e === t.uuid)
                return t;
            if (t.skeleton) {
                var r = function(t) {
                    for (var r = 0; r < t.bones.length; r++) {
                        var i = t.bones[r];
                        if (i.name === e)
                            return i
                    }
                    return null
                }
                  , i = r(t.skeleton);
                if (i)
                    return i
            }
            if (t.children) {
                var n = function(t) {
                    for (var r = 0; r < t.length; r++) {
                        var i = t[r];
                        if (i.name === e || i.uuid === e)
                            return i;
                        var o = n(i.children);
                        if (o)
                            return o
                    }
                    return null
                }
                  , o = n(t.children);
                if (o)
                    return o
            }
            return null
        }
        ,
        i.PropertyMixer = function(t, e, r) {
            this.binding = t,
            this.valueSize = r;
            var i, n = Float64Array;
            switch (e) {
            case "quaternion":
                i = this._slerp;
                break;
            case "string":
            case "bool":
                n = Array,
                i = this._select;
                break;
            default:
                i = this._lerp
            }
            this.buffer = new n(4 * r),
            this._mixBufferRegion = i,
            this.cumulativeWeight = 0,
            this.useCount = 0,
            this.referenceCount = 0
        }
        ,
        i.PropertyMixer.prototype = {
            constructor: i.PropertyMixer,
            accumulate: function(t, e) {
                var r = this.buffer
                  , i = this.valueSize
                  , n = t * i + i
                  , o = this.cumulativeWeight;
                if (0 === o) {
                    for (var a = 0; a !== i; ++a)
                        r[n + a] = r[a];
                    o = e
                } else {
                    o += e;
                    var s = e / o;
                    this._mixBufferRegion(r, n, 0, s, i)
                }
                this.cumulativeWeight = o
            },
            apply: function(t) {
                var e = this.valueSize
                  , r = this.buffer
                  , i = t * e + e
                  , n = this.cumulativeWeight
                  , o = this.binding;
                if (this.cumulativeWeight = 0,
                n < 1) {
                    var a = 3 * e;
                    this._mixBufferRegion(r, i, a, 1 - n, e)
                }
                for (var s = e, h = e + e; s !== h; ++s)
                    if (r[s] !== r[s + e]) {
                        o.setValue(r, i);
                        break
                    }
            },
            saveOriginalState: function() {
                var t = this.binding
                  , e = this.buffer
                  , r = this.valueSize
                  , i = 3 * r;
                t.getValue(e, i);
                for (var n = r, o = i; n !== o; ++n)
                    e[n] = e[i + n % r];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                var t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            },
            _select: function(t, e, r, i, n) {
                if (i >= .5)
                    for (var o = 0; o !== n; ++o)
                        t[e + o] = t[r + o]
            },
            _slerp: function(t, e, r, n, o) {
                i.Quaternion.slerpFlat(t, e, t, e, t, r, n)
            },
            _lerp: function(t, e, r, i, n) {
                for (var o = 1 - i, a = 0; a !== n; ++a) {
                    var s = e + a;
                    t[s] = t[s] * o + t[r + a] * i
                }
            }
        },
        i.BooleanKeyframeTrack = function(t, e, r) {
            i.KeyframeTrack.call(this, t, e, r)
        }
        ,
        i.BooleanKeyframeTrack.prototype = Object.assign(Object.create(i.KeyframeTrack.prototype), {
            constructor: i.BooleanKeyframeTrack,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: i.IntepolateDiscrete,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }),
        i.NumberKeyframeTrack = function(t, e, r, n) {
            i.KeyframeTrack.call(this, t, e, r, n)
        }
        ,
        i.NumberKeyframeTrack.prototype = Object.assign(Object.create(i.KeyframeTrack.prototype), {
            constructor: i.NumberKeyframeTrack,
            ValueTypeName: "number"
        }),
        i.QuaternionKeyframeTrack = function(t, e, r, n) {
            i.KeyframeTrack.call(this, t, e, r, n)
        }
        ,
        i.QuaternionKeyframeTrack.prototype = Object.assign(Object.create(i.KeyframeTrack.prototype), {
            constructor: i.QuaternionKeyframeTrack,
            ValueTypeName: "quaternion",
            DefaultInterpolation: i.InterpolateLinear,
            InterpolantFactoryMethodLinear: function(t) {
                return new i.QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }),
        i.StringKeyframeTrack = function(t, e, r, n) {
            i.KeyframeTrack.call(this, t, e, r, n)
        }
        ,
        i.StringKeyframeTrack.prototype = Object.assign(Object.create(i.KeyframeTrack.prototype), {
            constructor: i.StringKeyframeTrack,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: i.IntepolateDiscrete,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }),
        i.VectorKeyframeTrack = function(t, e, r, n) {
            i.KeyframeTrack.call(this, t, e, r, n)
        }
        ,
        i.VectorKeyframeTrack.prototype = Object.assign(Object.create(i.KeyframeTrack.prototype), {
            constructor: i.VectorKeyframeTrack,
            ValueTypeName: "vector"
        }),
        i.Audio = function(t) {
            i.Object3D.call(this),
            this.type = "Audio",
            this.context = t.context,
            this.source = this.context.createBufferSource(),
            this.source.onended = this.onEnded.bind(this),
            this.gain = this.context.createGain(),
            this.gain.connect(t.getInput()),
            this.autoplay = !1,
            this.startTime = 0,
            this.playbackRate = 1,
            this.isPlaying = !1,
            this.hasPlaybackControl = !0,
            this.sourceType = "empty",
            this.filter = null
        }
        ,
        i.Audio.prototype = Object.create(i.Object3D.prototype),
        i.Audio.prototype.constructor = i.Audio,
        i.Audio.prototype.getOutput = function() {
            return this.gain
        }
        ,
        i.Audio.prototype.load = function(t) {
            var e = new i.AudioBuffer(this.context);
            return e.load(t),
            this.setBuffer(e),
            this
        }
        ,
        i.Audio.prototype.setNodeSource = function(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = t,
            this.connect(),
            this
        }
        ,
        i.Audio.prototype.setBuffer = function(t) {
            var e = this;
            return t.onReady(function(t) {
                e.source.buffer = t,
                e.sourceType = "buffer",
                e.autoplay && e.play()
            }),
            this
        }
        ,
        i.Audio.prototype.play = function() {
            if (this.isPlaying === !0)
                return void console.warn("THREE.Audio: Audio is already playing.");
            if (this.hasPlaybackControl === !1)
                return void console.warn("THREE.Audio: this Audio has no playback control.");
            var t = this.context.createBufferSource();
            t.buffer = this.source.buffer,
            t.loop = this.source.loop,
            t.onended = this.source.onended,
            t.start(0, this.startTime),
            t.playbackRate.value = this.playbackRate,
            this.isPlaying = !0,
            this.source = t,
            this.connect()
        }
        ,
        i.Audio.prototype.pause = function() {
            return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
            void (this.startTime = this.context.currentTime))
        }
        ,
        i.Audio.prototype.stop = function() {
            return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
            void (this.startTime = 0))
        }
        ,
        i.Audio.prototype.connect = function() {
            null !== this.filter ? (this.source.connect(this.filter),
            this.filter.connect(this.getOutput())) : this.source.connect(this.getOutput())
        }
        ,
        i.Audio.prototype.disconnect = function() {
            null !== this.filter ? (this.source.disconnect(this.filter),
            this.filter.disconnect(this.getOutput())) : this.source.disconnect(this.getOutput())
        }
        ,
        i.Audio.prototype.getFilter = function() {
            return this.filter
        }
        ,
        i.Audio.prototype.setFilter = function(t) {
            void 0 === t && (t = null),
            this.isPlaying === !0 ? (this.disconnect(),
            this.filter = t,
            this.connect()) : this.filter = t
        }
        ,
        i.Audio.prototype.setPlaybackRate = function(t) {
            return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = t,
            void (this.isPlaying === !0 && (this.source.playbackRate.value = this.playbackRate)))
        }
        ,
        i.Audio.prototype.getPlaybackRate = function() {
            return this.playbackRate
        }
        ,
        i.Audio.prototype.onEnded = function() {
            this.isPlaying = !1
        }
        ,
        i.Audio.prototype.setLoop = function(t) {
            return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : void (this.source.loop = t)
        }
        ,
        i.Audio.prototype.getLoop = function() {
            return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.source.loop
        }
        ,
        i.Audio.prototype.setVolume = function(t) {
            this.gain.gain.value = t
        }
        ,
        i.Audio.prototype.getVolume = function() {
            return this.gain.gain.value
        }
        ,
        i.AudioAnalyser = function(t, e) {
            this.analyser = t.context.createAnalyser(),
            this.analyser.fftSize = void 0 !== e ? e : 2048,
            this.data = new Uint8Array(this.analyser.frequencyBinCount),
            t.getOutput().connect(this.analyser)
        }
        ,
        i.AudioAnalyser.prototype = {
            constructor: i.AudioAnalyser,
            getData: function() {
                return this.analyser.getByteFrequencyData(this.data),
                this.data
            }
        },
        i.AudioBuffer = function(t) {
            this.context = t,
            this.ready = !1,
            this.readyCallbacks = []
        }
        ,
        i.AudioBuffer.prototype.load = function(t) {
            var e = this
              , r = new XMLHttpRequest;
            return r.open("GET", t, !0),
            r.responseType = "arraybuffer",
            r.onload = function(t) {
                e.context.decodeAudioData(this.response, function(t) {
                    e.buffer = t,
                    e.ready = !0;
                    for (var r = 0; r < e.readyCallbacks.length; r++)
                        e.readyCallbacks[r](e.buffer);
                    e.readyCallbacks = []
                })
            }
            ,
            r.send(),
            this
        }
        ,
        i.AudioBuffer.prototype.onReady = function(t) {
            this.ready ? t(this.buffer) : this.readyCallbacks.push(t)
        }
        ,
        i.PositionalAudio = function(t) {
            i.Audio.call(this, t),
            this.panner = this.context.createPanner(),
            this.panner.connect(this.gain)
        }
        ,
        i.PositionalAudio.prototype = Object.create(i.Audio.prototype),
        i.PositionalAudio.prototype.constructor = i.PositionalAudio,
        i.PositionalAudio.prototype.getOutput = function() {
            return this.panner
        }
        ,
        i.PositionalAudio.prototype.setRefDistance = function(t) {
            this.panner.refDistance = t
        }
        ,
        i.PositionalAudio.prototype.getRefDistance = function() {
            return this.panner.refDistance
        }
        ,
        i.PositionalAudio.prototype.setRolloffFactor = function(t) {
            this.panner.rolloffFactor = t
        }
        ,
        i.PositionalAudio.prototype.getRolloffFactor = function() {
            return this.panner.rolloffFactor
        }
        ,
        i.PositionalAudio.prototype.setDistanceModel = function(t) {
            this.panner.distanceModel = t
        }
        ,
        i.PositionalAudio.prototype.getDistanceModel = function() {
            return this.panner.distanceModel
        }
        ,
        i.PositionalAudio.prototype.setMaxDistance = function(t) {
            this.panner.maxDistance = t
        }
        ,
        i.PositionalAudio.prototype.getMaxDistance = function() {
            return this.panner.maxDistance
        }
        ,
        i.PositionalAudio.prototype.updateMatrixWorld = function() {
            var t = new i.Vector3;
            return function(e) {
                i.Object3D.prototype.updateMatrixWorld.call(this, e),
                t.setFromMatrixPosition(this.matrixWorld),
                this.panner.setPosition(t.x, t.y, t.z)
            }
        }(),
        i.AudioListener = function() {
            i.Object3D.call(this),
            this.type = "AudioListener",
            this.context = new (window.AudioContext || window.webkitAudioContext),
            this.gain = this.context.createGain(),
            this.gain.connect(this.context.destination),
            this.filter = null
        }
        ,
        i.AudioListener.prototype = Object.create(i.Object3D.prototype),
        i.AudioListener.prototype.constructor = i.AudioListener,
        i.AudioListener.prototype.getInput = function() {
            return this.gain
        }
        ,
        i.AudioListener.prototype.removeFilter = function() {
            null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null)
        }
        ,
        i.AudioListener.prototype.setFilter = function(t) {
            null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = t,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination)
        }
        ,
        i.AudioListener.prototype.getFilter = function() {
            return this.filter
        }
        ,
        i.AudioListener.prototype.setMasterVolume = function(t) {
            this.gain.gain.value = t
        }
        ,
        i.AudioListener.prototype.getMasterVolume = function() {
            return this.gain.gain.value
        }
        ,
        i.AudioListener.prototype.updateMatrixWorld = function() {
            var t = new i.Vector3
              , e = new i.Quaternion
              , r = new i.Vector3
              , n = new i.Vector3;
            return function(o) {
                i.Object3D.prototype.updateMatrixWorld.call(this, o);
                var a = this.context.listener
                  , s = this.up;
                this.matrixWorld.decompose(t, e, r),
                n.set(0, 0, -1).applyQuaternion(e),
                a.setPosition(t.x, t.y, t.z),
                a.setOrientation(n.x, n.y, n.z, s.x, s.y, s.z)
            }
        }(),
        i.Camera = function() {
            i.Object3D.call(this),
            this.type = "Camera",
            this.matrixWorldInverse = new i.Matrix4,
            this.projectionMatrix = new i.Matrix4
        }
        ,
        i.Camera.prototype = Object.create(i.Object3D.prototype),
        i.Camera.prototype.constructor = i.Camera,
        i.Camera.prototype.getWorldDirection = function() {
            var t = new i.Quaternion;
            return function(e) {
                var r = e || new i.Vector3;
                return this.getWorldQuaternion(t),
                r.set(0, 0, -1).applyQuaternion(t)
            }
        }(),
        i.Camera.prototype.lookAt = function() {
            var t = new i.Matrix4;
            return function(e) {
                t.lookAt(this.position, e, this.up),
                this.quaternion.setFromRotationMatrix(t)
            }
        }(),
        i.Camera.prototype.clone = function() {
            return (new this.constructor).copy(this)
        }
        ,
        i.Camera.prototype.copy = function(t) {
            return i.Object3D.prototype.copy.call(this, t),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this
        }
        ,
        i.CubeCamera = function(t, e, r) {
            i.Object3D.call(this),
            this.type = "CubeCamera";
            var n = 90
              , o = 1
              , a = new i.PerspectiveCamera(n,o,t,e);
            a.up.set(0, -1, 0),
            a.lookAt(new i.Vector3(1,0,0)),
            this.add(a);
            var s = new i.PerspectiveCamera(n,o,t,e);
            s.up.set(0, -1, 0),
            s.lookAt(new i.Vector3((-1),0,0)),
            this.add(s);
            var h = new i.PerspectiveCamera(n,o,t,e);
            h.up.set(0, 0, 1),
            h.lookAt(new i.Vector3(0,1,0)),
            this.add(h);
            var c = new i.PerspectiveCamera(n,o,t,e);
            c.up.set(0, 0, -1),
            c.lookAt(new i.Vector3(0,(-1),0)),
            this.add(c);
            var l = new i.PerspectiveCamera(n,o,t,e);
            l.up.set(0, -1, 0),
            l.lookAt(new i.Vector3(0,0,1)),
            this.add(l);
            var u = new i.PerspectiveCamera(n,o,t,e);
            u.up.set(0, -1, 0),
            u.lookAt(new i.Vector3(0,0,(-1))),
            this.add(u);
            var p = {
                format: i.RGBFormat,
                magFilter: i.LinearFilter,
                minFilter: i.LinearFilter
            };
            this.renderTarget = new i.WebGLRenderTargetCube(r,r,p),
            this.updateCubeMap = function(t, e) {
                null === this.parent && this.updateMatrixWorld();
                var r = this.renderTarget
                  , i = r.texture.generateMipmaps;
                r.texture.generateMipmaps = !1,
                r.activeCubeFace = 0,
                t.render(e, a, r),
                r.activeCubeFace = 1,
                t.render(e, s, r),
                r.activeCubeFace = 2,
                t.render(e, h, r),
                r.activeCubeFace = 3,
                t.render(e, c, r),
                r.activeCubeFace = 4,
                t.render(e, l, r),
                r.texture.generateMipmaps = i,
                r.activeCubeFace = 5,
                t.render(e, u, r),
                t.setRenderTarget(null)
            }
        }
        ,
        i.CubeCamera.prototype = Object.create(i.Object3D.prototype),
        i.CubeCamera.prototype.constructor = i.CubeCamera,
        i.OrthographicCamera = function(t, e, r, n, o, a) {
            i.Camera.call(this),
            this.type = "OrthographicCamera",
            this.zoom = 1,
            this.left = t,
            this.right = e,
            this.top = r,
            this.bottom = n,
            this.near = void 0 !== o ? o : .1,
            this.far = void 0 !== a ? a : 2e3,
            this.updateProjectionMatrix()
        }
        ,
        i.OrthographicCamera.prototype = Object.create(i.Camera.prototype),
        i.OrthographicCamera.prototype.constructor = i.OrthographicCamera,
        i.OrthographicCamera.prototype.updateProjectionMatrix = function() {
            var t = (this.right - this.left) / (2 * this.zoom)
              , e = (this.top - this.bottom) / (2 * this.zoom)
              , r = (this.right + this.left) / 2
              , i = (this.top + this.bottom) / 2;
            this.projectionMatrix.makeOrthographic(r - t, r + t, i + e, i - e, this.near, this.far)
        }
        ,
        i.OrthographicCamera.prototype.copy = function(t) {
            return i.Camera.prototype.copy.call(this, t),
            this.left = t.left,
            this.right = t.right,
            this.top = t.top,
            this.bottom = t.bottom,
            this.near = t.near,
            this.far = t.far,
            this.zoom = t.zoom,
            this
        }
        ,
        i.OrthographicCamera.prototype.toJSON = function(t) {
            var e = i.Object3D.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom,
            e.object.left = this.left,
            e.object.right = this.right,
            e.object.top = this.top,
            e.object.bottom = this.bottom,
            e.object.near = this.near,
            e.object.far = this.far,
            e
        }
        ,
        i.PerspectiveCamera = function(t, e, r, n) {
            i.Camera.call(this),
            this.type = "PerspectiveCamera",
            this.focalLength = 10,
            this.zoom = 1,
            this.fov = void 0 !== t ? t : 50,
            this.aspect = void 0 !== e ? e : 1,
            this.near = void 0 !== r ? r : .1,
            this.far = void 0 !== n ? n : 2e3,
            this.updateProjectionMatrix()
        }
        ,
        i.PerspectiveCamera.prototype = Object.create(i.Camera.prototype),
        i.PerspectiveCamera.prototype.constructor = i.PerspectiveCamera,
        i.PerspectiveCamera.prototype.setLens = function(t, e) {
            void 0 === e && (e = 24),
            this.fov = 2 * i.Math.radToDeg(Math.atan(e / (2 * t))),
            this.updateProjectionMatrix()
        }
        ,
        i.PerspectiveCamera.prototype.setViewOffset = function(t, e, r, i, n, o) {
            this.fullWidth = t,
            this.fullHeight = e,
            this.x = r,
            this.y = i,
            this.width = n,
            this.height = o,
            this.updateProjectionMatrix()
        }
        ,
        i.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
            var t = i.Math.radToDeg(2 * Math.atan(Math.tan(.5 * i.Math.degToRad(this.fov)) / this.zoom));
            if (this.fullWidth) {
                var e = this.fullWidth / this.fullHeight
                  , r = Math.tan(i.Math.degToRad(.5 * t)) * this.near
                  , n = -r
                  , o = e * n
                  , a = e * r
                  , s = Math.abs(a - o)
                  , h = Math.abs(r - n);
                this.projectionMatrix.makeFrustum(o + this.x * s / this.fullWidth, o + (this.x + this.width) * s / this.fullWidth, r - (this.y + this.height) * h / this.fullHeight, r - this.y * h / this.fullHeight, this.near, this.far)
            } else
                this.projectionMatrix.makePerspective(t, this.aspect, this.near, this.far)
        }
        ,
        i.PerspectiveCamera.prototype.copy = function(t) {
            return i.Camera.prototype.copy.call(this, t),
            this.focalLength = t.focalLength,
            this.zoom = t.zoom,
            this.fov = t.fov,
            this.aspect = t.aspect,
            this.near = t.near,
            this.far = t.far,
            this
        }
        ,
        i.PerspectiveCamera.prototype.toJSON = function(t) {
            var e = i.Object3D.prototype.toJSON.call(this, t);
            return e.object.focalLength = this.focalLength,
            e.object.zoom = this.zoom,
            e.object.fov = this.fov,
            e.object.aspect = this.aspect,
            e.object.near = this.near,
            e.object.far = this.far,
            e
        }
        ,
        i.StereoCamera = function() {
            this.type = "StereoCamera",
            this.aspect = 1,
            this.cameraL = new i.PerspectiveCamera,
            this.cameraL.layers.enable(1),
            this.cameraL.matrixAutoUpdate = !1,
            this.cameraR = new i.PerspectiveCamera,
            this.cameraR.layers.enable(2),
            this.cameraR.matrixAutoUpdate = !1
        }
        ,
        i.StereoCamera.prototype = {
            constructor: i.StereoCamera,
            update: function() {
                var t, e, r, n, o, a = new i.Matrix4, s = new i.Matrix4;
                return function(h) {
                    var c = t !== h.focalLength || e !== h.fov || r !== h.aspect * this.aspect || n !== h.near || o !== h.far;
                    if (c) {
                        t = h.focalLength,
                        e = h.fov,
                        r = h.aspect * this.aspect,
                        n = h.near,
                        o = h.far;
                        var l, u, p = h.projectionMatrix.clone(), d = .032, f = d * n / t, m = n * Math.tan(i.Math.degToRad(.5 * e));
                        s.elements[12] = -d,
                        a.elements[12] = d,
                        l = -m * r + f,
                        u = m * r + f,
                        p.elements[0] = 2 * n / (u - l),
                        p.elements[8] = (u + l) / (u - l),
                        this.cameraL.projectionMatrix.copy(p),
                        l = -m * r - f,
                        u = m * r - f,
                        p.elements[0] = 2 * n / (u - l),
                        p.elements[8] = (u + l) / (u - l),
                        this.cameraR.projectionMatrix.copy(p)
                    }
                    this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(s),
                    this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(a)
                }
            }()
        },
        i.Light = function(t, e) {
            i.Object3D.call(this),
            this.type = "Light",
            this.color = new i.Color(t),
            this.intensity = void 0 !== e ? e : 1,
            this.receiveShadow = void 0
        }
        ,
        i.Light.prototype = Object.create(i.Object3D.prototype),
        i.Light.prototype.constructor = i.Light,
        i.Light.prototype.copy = function(t) {
            return i.Object3D.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.intensity = t.intensity,
            this
        }
        ,
        i.Light.prototype.toJSON = function(t) {
            var e = i.Object3D.prototype.toJSON.call(this, t);
            return e.object.color = this.color.getHex(),
            e.object.intensity = this.intensity,
            void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.exponent && (e.object.exponent = this.exponent),
            e
        }
        ,
        i.LightShadow = function(t) {
            this.camera = t,
            this.bias = 0,
            this.radius = 1,
            this.mapSize = new i.Vector2(512,512),
            this.map = null,
            this.matrix = new i.Matrix4
        }
        ,
        i.LightShadow.prototype = {
            constructor: i.LightShadow,
            copy: function(t) {
                return this.camera = t.camera.clone(),
                this.bias = t.bias,
                this.radius = t.radius,
                this.mapSize.copy(t.mapSize),
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        },
        i.AmbientLight = function(t, e) {
            i.Light.call(this, t, e),
            this.type = "AmbientLight",
            this.castShadow = void 0
        }
        ,
        i.AmbientLight.prototype = Object.create(i.Light.prototype),
        i.AmbientLight.prototype.constructor = i.AmbientLight,
        i.DirectionalLight = function(t, e) {
            i.Light.call(this, t, e),
            this.type = "DirectionalLight",
            this.position.set(0, 1, 0),
            this.updateMatrix(),
            this.target = new i.Object3D,
            this.shadow = new i.LightShadow(new i.OrthographicCamera((-5),5,5,(-5),.5,500))
        }
        ,
        i.DirectionalLight.prototype = Object.create(i.Light.prototype),
        i.DirectionalLight.prototype.constructor = i.DirectionalLight,
        i.DirectionalLight.prototype.copy = function(t) {
            return i.Light.prototype.copy.call(this, t),
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
        ,
        i.HemisphereLight = function(t, e, r) {
            i.Light.call(this, t, r),
            this.type = "HemisphereLight",
            this.castShadow = void 0,
            this.position.set(0, 1, 0),
            this.updateMatrix(),
            this.groundColor = new i.Color(e)
        }
        ,
        i.HemisphereLight.prototype = Object.create(i.Light.prototype),
        i.HemisphereLight.prototype.constructor = i.HemisphereLight,
        i.HemisphereLight.prototype.copy = function(t) {
            return i.Light.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
        }
        ,
        i.PointLight = function(t, e, r, n) {
            i.Light.call(this, t, e),
            this.type = "PointLight",
            this.distance = void 0 !== r ? r : 0,
            this.decay = void 0 !== n ? n : 1,
            this.shadow = new i.LightShadow(new i.PerspectiveCamera(90,1,.5,500))
        }
        ,
        i.PointLight.prototype = Object.create(i.Light.prototype),
        i.PointLight.prototype.constructor = i.PointLight,
        i.PointLight.prototype.copy = function(t) {
            return i.Light.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.decay = t.decay,
            this.shadow = t.shadow.clone(),
            this
        }
        ,
        i.SpotLight = function(t, e, r, n, o, a) {
            i.Light.call(this, t, e),
            this.type = "SpotLight",
            this.position.set(0, 1, 0),
            this.updateMatrix(),
            this.target = new i.Object3D,
            this.distance = void 0 !== r ? r : 0,
            this.angle = void 0 !== n ? n : Math.PI / 3,
            this.exponent = void 0 !== o ? o : 10,
            this.decay = void 0 !== a ? a : 1,
            this.shadow = new i.LightShadow(new i.PerspectiveCamera(50,1,.5,500))
        }
        ,
        i.SpotLight.prototype = Object.create(i.Light.prototype),
        i.SpotLight.prototype.constructor = i.SpotLight,
        i.SpotLight.prototype.copy = function(t) {
            return i.Light.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.angle = t.angle,
            this.exponent = t.exponent,
            this.decay = t.decay,
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
        ,
        i.Cache = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                this.enabled !== !1 && (this.files[t] = e)
            },
            get: function(t) {
                if (this.enabled !== !1)
                    return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        },
        i.Loader = function() {
            this.onLoadStart = function() {}
            ,
            this.onLoadProgress = function() {}
            ,
            this.onLoadComplete = function() {}
        }
        ,
        i.Loader.prototype = {
            constructor: i.Loader,
            crossOrigin: void 0,
            extractUrlBase: function(t) {
                var e = t.split("/");
                return 1 === e.length ? "./" : (e.pop(),
                e.join("/") + "/")
            },
            initMaterials: function(t, e, r) {
                for (var i = [], n = 0; n < t.length; ++n)
                    i[n] = this.createMaterial(t[n], e, r);
                return i
            },
            createMaterial: function() {
                var t, e, r;
                return function(n, o, a) {
                    function s(t, r, n, s, c) {
                        var l, u = o + t, p = i.Loader.Handlers.get(u);
                        null !== p ? l = p.load(u) : (e.setCrossOrigin(a),
                        l = e.load(u)),
                        void 0 !== r && (l.repeat.fromArray(r),
                        1 !== r[0] && (l.wrapS = i.RepeatWrapping),
                        1 !== r[1] && (l.wrapT = i.RepeatWrapping)),
                        void 0 !== n && l.offset.fromArray(n),
                        void 0 !== s && ("repeat" === s[0] && (l.wrapS = i.RepeatWrapping),
                        "mirror" === s[0] && (l.wrapS = i.MirroredRepeatWrapping),
                        "repeat" === s[1] && (l.wrapT = i.RepeatWrapping),
                        "mirror" === s[1] && (l.wrapT = i.MirroredRepeatWrapping)),
                        void 0 !== c && (l.anisotropy = c);
                        var d = i.Math.generateUUID();
                        return h[d] = l,
                        d
                    }
                    void 0 === t && (t = new i.Color),
                    void 0 === e && (e = new i.TextureLoader),
                    void 0 === r && (r = new i.MaterialLoader);
                    var h = {}
                      , c = {
                        uuid: i.Math.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                    for (var l in n) {
                        var u = n[l];
                        switch (l) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            c.name = u;
                            break;
                        case "blending":
                            c.blending = i[u];
                            break;
                        case "colorAmbient":
                            console.warn("THREE.Loader.createMaterial: colorAmbient is no longer supported");
                            break;
                        case "colorDiffuse":
                            c.color = t.fromArray(u).getHex();
                            break;
                        case "colorSpecular":
                            c.specular = t.fromArray(u).getHex();
                            break;
                        case "colorEmissive":
                            c.emissive = t.fromArray(u).getHex();
                            break;
                        case "specularCoef":
                            c.shininess = u;
                            break;
                        case "shading":
                            "basic" === u.toLowerCase() && (c.type = "MeshBasicMaterial"),
                            "phong" === u.toLowerCase() && (c.type = "MeshPhongMaterial");
                            break;
                        case "mapDiffuse":
                            c.map = s(u, n.mapDiffuseRepeat, n.mapDiffuseOffset, n.mapDiffuseWrap, n.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapLight":
                            c.lightMap = s(u, n.mapLightRepeat, n.mapLightOffset, n.mapLightWrap, n.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            c.aoMap = s(u, n.mapAORepeat, n.mapAOOffset, n.mapAOWrap, n.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            c.bumpMap = s(u, n.mapBumpRepeat, n.mapBumpOffset, n.mapBumpWrap, n.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            c.bumpScale = u;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            c.normalMap = s(u, n.mapNormalRepeat, n.mapNormalOffset, n.mapNormalWrap, n.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            c.normalScale = [u, u];
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            c.specularMap = s(u, n.mapSpecularRepeat, n.mapSpecularOffset, n.mapSpecularWrap, n.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapAlpha":
                            c.alphaMap = s(u, n.mapAlphaRepeat, n.mapAlphaOffset, n.mapAlphaWrap, n.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            c.side = i.BackSide;
                            break;
                        case "doubleSided":
                            c.side = i.DoubleSide;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                            c.opacity = u;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            c[l] = u;
                            break;
                        case "vertexColors":
                            u === !0 && (c.vertexColors = i.VertexColors),
                            "face" === u && (c.vertexColors = i.FaceColors);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", l, u)
                        }
                    }
                    return "MeshBasicMaterial" === c.type && delete c.emissive,
                    "MeshPhongMaterial" !== c.type && delete c.specular,
                    c.opacity < 1 && (c.transparent = !0),
                    r.setTextures(h),
                    r.parse(c)
                }
            }()
        },
        i.Loader.Handlers = {
            handlers: [],
            add: function(t, e) {
                this.handlers.push(t, e)
            },
            get: function(t) {
                for (var e = this.handlers, r = 0, i = e.length; r < i; r += 2) {
                    var n = e[r]
                      , o = e[r + 1];
                    if (n.test(t))
                        return o
                }
                return null
            }
        },
        i.XHRLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager
        }
        ,
        i.XHRLoader.prototype = {
            constructor: i.XHRLoader,
            load: function(t, e, r, n) {
                void 0 !== this.path && (t = this.path + t);
                var o = this
                  , a = i.Cache.get(t);
                if (void 0 !== a)
                    return e && setTimeout(function() {
                        e(a)
                    }, 0),
                    a;
                var s = new XMLHttpRequest;
                return s.overrideMimeType("text/plain"),
                s.open("GET", t, !0),
                s.addEventListener("load", function(r) {
                    var a = r.target.response;
                    i.Cache.add(t, a),
                    200 === this.status ? (e && e(a),
                    o.manager.itemEnd(t)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."),
                    e && e(a),
                    o.manager.itemEnd(t)) : (n && n(r),
                    o.manager.itemError(t))
                }, !1),
                void 0 !== r && s.addEventListener("progress", function(t) {
                    r(t)
                }, !1),
                s.addEventListener("error", function(e) {
                    n && n(e),
                    o.manager.itemError(t)
                }, !1),
                void 0 !== this.responseType && (s.responseType = this.responseType),
                void 0 !== this.withCredentials && (s.withCredentials = this.withCredentials),
                s.send(null),
                o.manager.itemStart(t),
                s
            },
            setPath: function(t) {
                this.path = t
            },
            setResponseType: function(t) {
                this.responseType = t
            },
            setWithCredentials: function(t) {
                this.withCredentials = t
            }
        },
        i.FontLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager
        }
        ,
        i.FontLoader.prototype = {
            constructor: i.FontLoader,
            load: function(t, e, r, n) {
                var o = new i.XHRLoader(this.manager);
                o.load(t, function(t) {
                    e(new i.Font(JSON.parse(t.substring(65, t.length - 2))))
                }, r, n)
            }
        },
        i.ImageLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager
        }
        ,
        i.ImageLoader.prototype = {
            constructor: i.ImageLoader,
            load: function(t, e, r, n) {
                void 0 !== this.path && (t = this.path + t);
                var o = this
                  , a = i.Cache.get(t);
                if (void 0 !== a)
                    return o.manager.itemStart(t),
                    e ? setTimeout(function() {
                        e(a),
                        o.manager.itemEnd(t)
                    }, 0) : o.manager.itemEnd(t),
                    a;
                var s = document.createElement("img");
                return s.addEventListener("load", function(r) {
                    i.Cache.add(t, this),
                    e && e(this),
                    o.manager.itemEnd(t)
                }, !1),
                void 0 !== r && s.addEventListener("progress", function(t) {
                    r(t)
                }, !1),
                s.addEventListener("error", function(e) {
                    n && n(e),
                    o.manager.itemError(t)
                }, !1),
                void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
                o.manager.itemStart(t),
                s.src = t,
                s
            },
            setCrossOrigin: function(t) {
                this.crossOrigin = t
            },
            setPath: function(t) {
                this.path = t
            }
        },
        i.JSONLoader = function(t) {
            "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
            t = void 0),
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager,
            this.withCredentials = !1
        }
        ,
        i.JSONLoader.prototype = {
            constructor: i.JSONLoader,
            get statusDomElement() {
                return void 0 === this._statusDomElement && (this._statusDomElement = document.createElement("div")),
                console.warn("THREE.JSONLoader: .statusDomElement has been removed."),
                this._statusDomElement
            },
            load: function(t, e, r, n) {
                var o = this
                  , a = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : i.Loader.prototype.extractUrlBase(t)
                  , s = new i.XHRLoader(this.manager);
                s.setWithCredentials(this.withCredentials),
                s.load(t, function(r) {
                    var i = JSON.parse(r)
                      , n = i.metadata;
                    if (void 0 !== n) {
                        var s = n.type;
                        if (void 0 !== s) {
                            if ("object" === s.toLowerCase())
                                return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                            if ("scene" === s.toLowerCase())
                                return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                        }
                    }
                    var h = o.parse(i, a);
                    e(h.geometry, h.materials)
                }, r, n)
            },
            setTexturePath: function(t) {
                this.texturePath = t
            },
            parse: function(t, e) {
                function r(e) {
                    function r(t, e) {
                        return t & 1 << e
                    }
                    var n, o, a, h, c, l, u, p, d, f, m, g, v, y, x, b, w, _, M, S, E, T, A, L, C, R, P, U = t.faces, I = t.vertices, D = t.normals, O = t.colors, N = 0;
                    if (void 0 !== t.uvs) {
                        for (n = 0; n < t.uvs.length; n++)
                            t.uvs[n].length && N++;
                        for (n = 0; n < N; n++)
                            s.faceVertexUvs[n] = []
                    }
                    for (h = 0,
                    c = I.length; h < c; )
                        _ = new i.Vector3,
                        _.x = I[h++] * e,
                        _.y = I[h++] * e,
                        _.z = I[h++] * e,
                        s.vertices.push(_);
                    for (h = 0,
                    c = U.length; h < c; )
                        if (f = U[h++],
                        m = r(f, 0),
                        g = r(f, 1),
                        v = r(f, 3),
                        y = r(f, 4),
                        x = r(f, 5),
                        b = r(f, 6),
                        w = r(f, 7),
                        m) {
                            if (S = new i.Face3,
                            S.a = U[h],
                            S.b = U[h + 1],
                            S.c = U[h + 3],
                            E = new i.Face3,
                            E.a = U[h + 1],
                            E.b = U[h + 2],
                            E.c = U[h + 3],
                            h += 4,
                            g && (d = U[h++],
                            S.materialIndex = d,
                            E.materialIndex = d),
                            a = s.faces.length,
                            v)
                                for (n = 0; n < N; n++)
                                    for (L = t.uvs[n],
                                    s.faceVertexUvs[n][a] = [],
                                    s.faceVertexUvs[n][a + 1] = [],
                                    o = 0; o < 4; o++)
                                        p = U[h++],
                                        R = L[2 * p],
                                        P = L[2 * p + 1],
                                        C = new i.Vector2(R,P),
                                        2 !== o && s.faceVertexUvs[n][a].push(C),
                                        0 !== o && s.faceVertexUvs[n][a + 1].push(C);
                            if (y && (u = 3 * U[h++],
                            S.normal.set(D[u++], D[u++], D[u]),
                            E.normal.copy(S.normal)),
                            x)
                                for (n = 0; n < 4; n++)
                                    u = 3 * U[h++],
                                    A = new i.Vector3(D[u++],D[u++],D[u]),
                                    2 !== n && S.vertexNormals.push(A),
                                    0 !== n && E.vertexNormals.push(A);
                            if (b && (l = U[h++],
                            T = O[l],
                            S.color.setHex(T),
                            E.color.setHex(T)),
                            w)
                                for (n = 0; n < 4; n++)
                                    l = U[h++],
                                    T = O[l],
                                    2 !== n && S.vertexColors.push(new i.Color(T)),
                                    0 !== n && E.vertexColors.push(new i.Color(T));
                            s.faces.push(S),
                            s.faces.push(E)
                        } else {
                            if (M = new i.Face3,
                            M.a = U[h++],
                            M.b = U[h++],
                            M.c = U[h++],
                            g && (d = U[h++],
                            M.materialIndex = d),
                            a = s.faces.length,
                            v)
                                for (n = 0; n < N; n++)
                                    for (L = t.uvs[n],
                                    s.faceVertexUvs[n][a] = [],
                                    o = 0; o < 3; o++)
                                        p = U[h++],
                                        R = L[2 * p],
                                        P = L[2 * p + 1],
                                        C = new i.Vector2(R,P),
                                        s.faceVertexUvs[n][a].push(C);
                            if (y && (u = 3 * U[h++],
                            M.normal.set(D[u++], D[u++], D[u])),
                            x)
                                for (n = 0; n < 3; n++)
                                    u = 3 * U[h++],
                                    A = new i.Vector3(D[u++],D[u++],D[u]),
                                    M.vertexNormals.push(A);
                            if (b && (l = U[h++],
                            M.color.setHex(O[l])),
                            w)
                                for (n = 0; n < 3; n++)
                                    l = U[h++],
                                    M.vertexColors.push(new i.Color(O[l]));
                            s.faces.push(M)
                        }
                }
                function n() {
                    var e = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                    if (t.skinWeights)
                        for (var r = 0, n = t.skinWeights.length; r < n; r += e) {
                            var o = t.skinWeights[r]
                              , a = e > 1 ? t.skinWeights[r + 1] : 0
                              , h = e > 2 ? t.skinWeights[r + 2] : 0
                              , c = e > 3 ? t.skinWeights[r + 3] : 0;
                            s.skinWeights.push(new i.Vector4(o,a,h,c))
                        }
                    if (t.skinIndices)
                        for (var r = 0, n = t.skinIndices.length; r < n; r += e) {
                            var l = t.skinIndices[r]
                              , u = e > 1 ? t.skinIndices[r + 1] : 0
                              , p = e > 2 ? t.skinIndices[r + 2] : 0
                              , d = e > 3 ? t.skinIndices[r + 3] : 0;
                            s.skinIndices.push(new i.Vector4(l,u,p,d))
                        }
                    s.bones = t.bones,
                    s.bones && s.bones.length > 0 && (s.skinWeights.length !== s.skinIndices.length || s.skinIndices.length !== s.vertices.length) && console.warn("When skinning, number of vertices (" + s.vertices.length + "), skinIndices (" + s.skinIndices.length + "), and skinWeights (" + s.skinWeights.length + ") should match.")
                }
                function o(e) {
                    if (void 0 !== t.morphTargets)
                        for (var r = 0, n = t.morphTargets.length; r < n; r++) {
                            s.morphTargets[r] = {},
                            s.morphTargets[r].name = t.morphTargets[r].name,
                            s.morphTargets[r].vertices = [];
                            for (var o = s.morphTargets[r].vertices, a = t.morphTargets[r].vertices, h = 0, c = a.length; h < c; h += 3) {
                                var l = new i.Vector3;
                                l.x = a[h] * e,
                                l.y = a[h + 1] * e,
                                l.z = a[h + 2] * e,
                                o.push(l)
                            }
                        }
                    if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                        for (var u = s.faces, p = t.morphColors[0].colors, r = 0, n = u.length; r < n; r++)
                            u[r].color.fromArray(p, 3 * r)
                    }
                }
                function a() {
                    var e = []
                      , r = [];
                    void 0 !== t.animation && r.push(t.animation),
                    void 0 !== t.animations && (t.animations.length ? r = r.concat(t.animations) : r.push(t.animations));
                    for (var n = 0; n < r.length; n++) {
                        var o = i.AnimationClip.parseAnimation(r[n], s.bones);
                        o && e.push(o)
                    }
                    if (s.morphTargets) {
                        var a = i.AnimationClip.CreateClipsFromMorphTargetSequences(s.morphTargets, 10);
                        e = e.concat(a)
                    }
                    e.length > 0 && (s.animations = e)
                }
                var s = new i.Geometry
                  , h = void 0 !== t.scale ? 1 / t.scale : 1;
                if (r(h),
                n(),
                o(h),
                a(),
                s.computeFaceNormals(),
                s.computeBoundingSphere(),
                void 0 === t.materials || 0 === t.materials.length)
                    return {
                        geometry: s
                    };
                var c = i.Loader.prototype.initMaterials(t.materials, e, this.crossOrigin);
                return {
                    geometry: s,
                    materials: c
                }
            }
        },
        i.LoadingManager = function(t, e, r) {
            var i = this
              , n = !1
              , o = 0
              , a = 0;
            this.onStart = void 0,
            this.onLoad = t,
            this.onProgress = e,
            this.onError = r,
            this.itemStart = function(t) {
                a++,
                n === !1 && void 0 !== i.onStart && i.onStart(t, o, a),
                n = !0
            }
            ,
            this.itemEnd = function(t) {
                o++,
                void 0 !== i.onProgress && i.onProgress(t, o, a),
                o === a && (n = !1,
                void 0 !== i.onLoad && i.onLoad())
            }
            ,
            this.itemError = function(t) {
                void 0 !== i.onError && i.onError(t)
            }
        }
        ,
        i.DefaultLoadingManager = new i.LoadingManager,
        i.BufferGeometryLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager
        }
        ,
        i.BufferGeometryLoader.prototype = {
            constructor: i.BufferGeometryLoader,
            load: function(t, e, r, n) {
                var o = this
                  , a = new i.XHRLoader(o.manager);
                a.load(t, function(t) {
                    e(o.parse(JSON.parse(t)))
                }, r, n)
            },
            parse: function(t) {
                var e = new i.BufferGeometry
                  , r = t.data.index
                  , n = {
                    Int8Array: Int8Array,
                    Uint8Array: Uint8Array,
                    Uint8ClampedArray: Uint8ClampedArray,
                    Int16Array: Int16Array,
                    Uint16Array: Uint16Array,
                    Int32Array: Int32Array,
                    Uint32Array: Uint32Array,
                    Float32Array: Float32Array,
                    Float64Array: Float64Array
                };
                if (void 0 !== r) {
                    var o = new n[r.type](r.array);
                    e.setIndex(new i.BufferAttribute(o,1))
                }
                var a = t.data.attributes;
                for (var s in a) {
                    var h = a[s]
                      , o = new n[h.type](h.array);
                    e.addAttribute(s, new i.BufferAttribute(o,h.itemSize))
                }
                var c = t.data.groups || t.data.drawcalls || t.data.offsets;
                if (void 0 !== c)
                    for (var l = 0, u = c.length; l !== u; ++l) {
                        var p = c[l];
                        e.addGroup(p.start, p.count, p.materialIndex)
                    }
                var d = t.data.boundingSphere;
                if (void 0 !== d) {
                    var f = new i.Vector3;
                    void 0 !== d.center && f.fromArray(d.center),
                    e.boundingSphere = new i.Sphere(f,d.radius)
                }
                return e
            }
        },
        i.MaterialLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager,
            this.textures = {}
        }
        ,
        i.MaterialLoader.prototype = {
            constructor: i.MaterialLoader,
            load: function(t, e, r, n) {
                var o = this
                  , a = new i.XHRLoader(o.manager);
                a.load(t, function(t) {
                    e(o.parse(JSON.parse(t)))
                }, r, n)
            },
            setTextures: function(t) {
                this.textures = t
            },
            getTexture: function(t) {
                var e = this.textures;
                return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t),
                e[t]
            },
            parse: function(t) {
                var e = new i[t.type];
                if (void 0 !== t.uuid && (e.uuid = t.uuid),
                void 0 !== t.name && (e.name = t.name),
                void 0 !== t.color && e.color.setHex(t.color),
                void 0 !== t.roughness && (e.roughness = t.roughness),
                void 0 !== t.metalness && (e.metalness = t.metalness),
                void 0 !== t.emissive && e.emissive.setHex(t.emissive),
                void 0 !== t.specular && e.specular.setHex(t.specular),
                void 0 !== t.shininess && (e.shininess = t.shininess),
                void 0 !== t.uniforms && (e.uniforms = t.uniforms),
                void 0 !== t.vertexShader && (e.vertexShader = t.vertexShader),
                void 0 !== t.fragmentShader && (e.fragmentShader = t.fragmentShader),
                void 0 !== t.vertexColors && (e.vertexColors = t.vertexColors),
                void 0 !== t.shading && (e.shading = t.shading),
                void 0 !== t.blending && (e.blending = t.blending),
                void 0 !== t.side && (e.side = t.side),
                void 0 !== t.opacity && (e.opacity = t.opacity),
                void 0 !== t.transparent && (e.transparent = t.transparent),
                void 0 !== t.alphaTest && (e.alphaTest = t.alphaTest),
                void 0 !== t.depthTest && (e.depthTest = t.depthTest),
                void 0 !== t.depthWrite && (e.depthWrite = t.depthWrite),
                void 0 !== t.colorWrite && (e.colorWrite = t.colorWrite),
                void 0 !== t.wireframe && (e.wireframe = t.wireframe),
                void 0 !== t.wireframeLinewidth && (e.wireframeLinewidth = t.wireframeLinewidth),
                void 0 !== t.size && (e.size = t.size),
                void 0 !== t.sizeAttenuation && (e.sizeAttenuation = t.sizeAttenuation),
                void 0 !== t.map && (e.map = this.getTexture(t.map)),
                void 0 !== t.alphaMap && (e.alphaMap = this.getTexture(t.alphaMap),
                e.transparent = !0),
                void 0 !== t.bumpMap && (e.bumpMap = this.getTexture(t.bumpMap)),
                void 0 !== t.bumpScale && (e.bumpScale = t.bumpScale),
                void 0 !== t.normalMap && (e.normalMap = this.getTexture(t.normalMap)),
                void 0 !== t.normalScale) {
                    var r = t.normalScale;
                    Array.isArray(r) === !1 && (r = [r, r]),
                    e.normalScale = (new i.Vector2).fromArray(r)
                }
                if (void 0 !== t.displacementMap && (e.displacementMap = this.getTexture(t.displacementMap)),
                void 0 !== t.displacementScale && (e.displacementScale = t.displacementScale),
                void 0 !== t.displacementBias && (e.displacementBias = t.displacementBias),
                void 0 !== t.roughnessMap && (e.roughnessMap = this.getTexture(t.roughnessMap)),
                void 0 !== t.metalnessMap && (e.metalnessMap = this.getTexture(t.metalnessMap)),
                void 0 !== t.emissiveMap && (e.emissiveMap = this.getTexture(t.emissiveMap)),
                void 0 !== t.emissiveIntensity && (e.emissiveIntensity = t.emissiveIntensity),
                void 0 !== t.specularMap && (e.specularMap = this.getTexture(t.specularMap)),
                void 0 !== t.envMap && (e.envMap = this.getTexture(t.envMap),
                e.combine = i.MultiplyOperation),
                t.reflectivity && (e.reflectivity = t.reflectivity),
                void 0 !== t.lightMap && (e.lightMap = this.getTexture(t.lightMap)),
                void 0 !== t.lightMapIntensity && (e.lightMapIntensity = t.lightMapIntensity),
                void 0 !== t.aoMap && (e.aoMap = this.getTexture(t.aoMap)),
                void 0 !== t.aoMapIntensity && (e.aoMapIntensity = t.aoMapIntensity),
                void 0 !== t.materials)
                    for (var n = 0, o = t.materials.length; n < o; n++)
                        e.materials.push(this.parse(t.materials[n]));
                return e
            }
        },
        i.ObjectLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager,
            this.texturePath = ""
        }
        ,
        i.ObjectLoader.prototype = {
            constructor: i.ObjectLoader,
            load: function(t, e, r, n) {
                "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                var o = this
                  , a = new i.XHRLoader(o.manager);
                a.load(t, function(t) {
                    o.parse(JSON.parse(t), e)
                }, r, n)
            },
            setTexturePath: function(t) {
                this.texturePath = t
            },
            setCrossOrigin: function(t) {
                this.crossOrigin = t
            },
            parse: function(t, e) {
                var r = this.parseGeometries(t.geometries)
                  , i = this.parseImages(t.images, function() {
                    void 0 !== e && e(a)
                })
                  , n = this.parseTextures(t.textures, i)
                  , o = this.parseMaterials(t.materials, n)
                  , a = this.parseObject(t.object, r, o);
                return t.animations && (a.animations = this.parseAnimations(t.animations)),
                void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(a),
                a
            },
            parseGeometries: function(t) {
                var e = {};
                if (void 0 !== t)
                    for (var r = new i.JSONLoader, n = new i.BufferGeometryLoader, o = 0, a = t.length; o < a; o++) {
                        var s, h = t[o];
                        switch (h.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            s = new i[h.type](h.width,h.height,h.widthSegments,h.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "CubeGeometry":
                            s = new i.BoxGeometry(h.width,h.height,h.depth,h.widthSegments,h.heightSegments,h.depthSegments);
                            break;
                        case "CircleBufferGeometry":
                            s = new i.CircleBufferGeometry(h.radius,h.segments,h.thetaStart,h.thetaLength);
                            break;
                        case "CircleGeometry":
                            s = new i.CircleGeometry(h.radius,h.segments,h.thetaStart,h.thetaLength);
                            break;
                        case "CylinderGeometry":
                            s = new i.CylinderGeometry(h.radiusTop,h.radiusBottom,h.height,h.radialSegments,h.heightSegments,h.openEnded,h.thetaStart,h.thetaLength);
                            break;
                        case "SphereGeometry":
                            s = new i.SphereGeometry(h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);
                            break;
                        case "SphereBufferGeometry":
                            s = new i.SphereBufferGeometry(h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                            s = new i.DodecahedronGeometry(h.radius,h.detail);
                            break;
                        case "IcosahedronGeometry":
                            s = new i.IcosahedronGeometry(h.radius,h.detail);
                            break;
                        case "OctahedronGeometry":
                            s = new i.OctahedronGeometry(h.radius,h.detail);
                            break;
                        case "TetrahedronGeometry":
                            s = new i.TetrahedronGeometry(h.radius,h.detail);
                            break;
                        case "RingGeometry":
                            s = new i.RingGeometry(h.innerRadius,h.outerRadius,h.thetaSegments,h.phiSegments,h.thetaStart,h.thetaLength);
                            break;
                        case "TorusGeometry":
                            s = new i.TorusGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.arc);
                            break;
                        case "TorusKnotGeometry":
                            s = new i.TorusKnotGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.p,h.q,h.heightScale);
                            break;
                        case "LatheGeometry":
                            s = new i.LatheGeometry(h.points,h.segments,h.phiStart,h.phiLength);
                            break;
                        case "BufferGeometry":
                            s = n.parse(h);
                            break;
                        case "Geometry":
                            s = r.parse(h.data, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
                            continue
                        }
                        s.uuid = h.uuid,
                        void 0 !== h.name && (s.name = h.name),
                        e[h.uuid] = s
                    }
                return e
            },
            parseMaterials: function(t, e) {
                var r = {};
                if (void 0 !== t) {
                    var n = new i.MaterialLoader;
                    n.setTextures(e);
                    for (var o = 0, a = t.length; o < a; o++) {
                        var s = n.parse(t[o]);
                        r[s.uuid] = s
                    }
                }
                return r
            },
            parseAnimations: function(t) {
                for (var e = [], r = 0; r < t.length; r++) {
                    var n = i.AnimationClip.parse(t[r]);
                    e.push(n)
                }
                return e
            },
            parseImages: function(t, e) {
                function r(t) {
                    return n.manager.itemStart(t),
                    s.load(t, function() {
                        n.manager.itemEnd(t)
                    })
                }
                var n = this
                  , o = {};
                if (void 0 !== t && t.length > 0) {
                    var a = new i.LoadingManager(e)
                      , s = new i.ImageLoader(a);
                    s.setCrossOrigin(this.crossOrigin);
                    for (var h = 0, c = t.length; h < c; h++) {
                        var l = t[h]
                          , u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.texturePath + l.url;
                        o[l.uuid] = r(u)
                    }
                }
                return o
            },
            parseTextures: function(t, e) {
                function r(t) {
                    return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t),
                    i[t])
                }
                var n = {};
                if (void 0 !== t)
                    for (var o = 0, a = t.length; o < a; o++) {
                        var s = t[o];
                        void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
                        void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                        var h = new i.Texture(e[s.image]);
                        h.needsUpdate = !0,
                        h.uuid = s.uuid,
                        void 0 !== s.name && (h.name = s.name),
                        void 0 !== s.mapping && (h.mapping = r(s.mapping)),
                        void 0 !== s.offset && (h.offset = new i.Vector2(s.offset[0],s.offset[1])),
                        void 0 !== s.repeat && (h.repeat = new i.Vector2(s.repeat[0],s.repeat[1])),
                        void 0 !== s.minFilter && (h.minFilter = r(s.minFilter)),
                        void 0 !== s.magFilter && (h.magFilter = r(s.magFilter)),
                        void 0 !== s.anisotropy && (h.anisotropy = s.anisotropy),
                        Array.isArray(s.wrap) && (h.wrapS = r(s.wrap[0]),
                        h.wrapT = r(s.wrap[1])),
                        n[s.uuid] = h
                    }
                return n
            },
            parseObject: function() {
                var t = new i.Matrix4;
                return function(e, r, n) {
                    function o(t) {
                        return void 0 === r[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t),
                        r[t]
                    }
                    function a(t) {
                        if (void 0 !== t)
                            return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t),
                            n[t]
                    }
                    var s;
                    switch (e.type) {
                    case "Scene":
                        s = new i.Scene;
                        break;
                    case "PerspectiveCamera":
                        s = new i.PerspectiveCamera(e.fov,e.aspect,e.near,e.far);
                        break;
                    case "OrthographicCamera":
                        s = new i.OrthographicCamera(e.left,e.right,e.top,e.bottom,e.near,e.far);
                        break;
                    case "AmbientLight":
                        s = new i.AmbientLight(e.color,e.intensity);
                        break;
                    case "DirectionalLight":
                        s = new i.DirectionalLight(e.color,e.intensity);
                        break;
                    case "PointLight":
                        s = new i.PointLight(e.color,e.intensity,e.distance,e.decay);
                        break;
                    case "SpotLight":
                        s = new i.SpotLight(e.color,e.intensity,e.distance,e.angle,e.exponent,e.decay);
                        break;
                    case "HemisphereLight":
                        s = new i.HemisphereLight(e.color,e.groundColor,e.intensity);
                        break;
                    case "Mesh":
                        var h = o(e.geometry)
                          , c = a(e.material);
                        s = h.bones && h.bones.length > 0 ? new i.SkinnedMesh(h,c) : new i.Mesh(h,c);
                        break;
                    case "LOD":
                        s = new i.LOD;
                        break;
                    case "Line":
                        s = new i.Line(o(e.geometry),a(e.material),e.mode);
                        break;
                    case "PointCloud":
                    case "Points":
                        s = new i.Points(o(e.geometry),a(e.material));
                        break;
                    case "Sprite":
                        s = new i.Sprite(a(e.material));
                        break;
                    case "Group":
                        s = new i.Group;
                        break;
                    default:
                        s = new i.Object3D
                    }
                    if (s.uuid = e.uuid,
                    void 0 !== e.name && (s.name = e.name),
                    void 0 !== e.matrix ? (t.fromArray(e.matrix),
                    t.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== e.position && s.position.fromArray(e.position),
                    void 0 !== e.rotation && s.rotation.fromArray(e.rotation),
                    void 0 !== e.scale && s.scale.fromArray(e.scale)),
                    void 0 !== e.castShadow && (s.castShadow = e.castShadow),
                    void 0 !== e.receiveShadow && (s.receiveShadow = e.receiveShadow),
                    void 0 !== e.visible && (s.visible = e.visible),
                    void 0 !== e.userData && (s.userData = e.userData),
                    void 0 !== e.children)
                        for (var l in e.children)
                            s.add(this.parseObject(e.children[l], r, n));
                    if ("LOD" === e.type)
                        for (var u = e.levels, p = 0; p < u.length; p++) {
                            var d = u[p]
                              , l = s.getObjectByProperty("uuid", d.object);
                            void 0 !== l && s.addLevel(l, d.distance)
                        }
                    return s
                }
            }()
        },
        i.TextureLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager
        }
        ,
        i.TextureLoader.prototype = {
            constructor: i.TextureLoader,
            load: function(t, e, r, n) {
                var o = new i.Texture
                  , a = new i.ImageLoader(this.manager);
                return a.setCrossOrigin(this.crossOrigin),
                a.setPath(this.path),
                a.load(t, function(t) {
                    o.image = t,
                    o.needsUpdate = !0,
                    void 0 !== e && e(o)
                }, r, n),
                o
            },
            setCrossOrigin: function(t) {
                this.crossOrigin = t
            },
            setPath: function(t) {
                this.path = t
            }
        },
        i.CubeTextureLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager
        }
        ,
        i.CubeTextureLoader.prototype = {
            constructor: i.CubeTextureLoader,
            load: function(t, e, r, n) {
                function o(r) {
                    s.load(t[r], function(t) {
                        a.images[r] = t,
                        h++,
                        6 === h && (a.needsUpdate = !0,
                        e && e(a))
                    }, void 0, n)
                }
                var a = new i.CubeTexture([])
                  , s = new i.ImageLoader(this.manager);
                s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path);
                for (var h = 0, c = 0; c < t.length; ++c)
                    o(c);
                return a
            },
            setCrossOrigin: function(t) {
                this.crossOrigin = t
            },
            setPath: function(t) {
                this.path = t
            }
        },
        i.DataTextureLoader = i.BinaryTextureLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager,
            this._parser = null
        }
        ,
        i.BinaryTextureLoader.prototype = {
            constructor: i.BinaryTextureLoader,
            load: function(t, e, r, n) {
                var o = this
                  , a = new i.DataTexture
                  , s = new i.XHRLoader(this.manager);
                return s.setResponseType("arraybuffer"),
                s.load(t, function(t) {
                    var r = o._parser(t);
                    r && (void 0 !== r.image ? a.image = r.image : void 0 !== r.data && (a.image.width = r.width,
                    a.image.height = r.height,
                    a.image.data = r.data),
                    a.wrapS = void 0 !== r.wrapS ? r.wrapS : i.ClampToEdgeWrapping,
                    a.wrapT = void 0 !== r.wrapT ? r.wrapT : i.ClampToEdgeWrapping,
                    a.magFilter = void 0 !== r.magFilter ? r.magFilter : i.LinearFilter,
                    a.minFilter = void 0 !== r.minFilter ? r.minFilter : i.LinearMipMapLinearFilter,
                    a.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1,
                    void 0 !== r.format && (a.format = r.format),
                    void 0 !== r.type && (a.type = r.type),
                    void 0 !== r.mipmaps && (a.mipmaps = r.mipmaps),
                    1 === r.mipmapCount && (a.minFilter = i.LinearFilter),
                    a.needsUpdate = !0,
                    e && e(a, r))
                }, r, n),
                a
            }
        },
        i.CompressedTextureLoader = function(t) {
            this.manager = void 0 !== t ? t : i.DefaultLoadingManager,
            this._parser = null
        }
        ,
        i.CompressedTextureLoader.prototype = {
            constructor: i.CompressedTextureLoader,
            load: function(t, e, r, n) {
                function o(o) {
                    c.load(t[o], function(t) {
                        var r = a._parser(t, !0);
                        s[o] = {
                            width: r.width,
                            height: r.height,
                            format: r.format,
                            mipmaps: r.mipmaps
                        },
                        l += 1,
                        6 === l && (1 === r.mipmapCount && (h.minFilter = i.LinearFilter),
                        h.format = r.format,
                        h.needsUpdate = !0,
                        e && e(h))
                    }, r, n)
                }
                var a = this
                  , s = []
                  , h = new i.CompressedTexture;
                h.image = s;
                var c = new i.XHRLoader(this.manager);
                if (c.setPath(this.path),
                c.setResponseType("arraybuffer"),
                Array.isArray(t))
                    for (var l = 0, u = 0, p = t.length; u < p; ++u)
                        o(u);
                else
                    c.load(t, function(t) {
                        var r = a._parser(t, !0);
                        if (r.isCubemap)
                            for (var n = r.mipmaps.length / r.mipmapCount, o = 0; o < n; o++) {
                                s[o] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < r.mipmapCount; c++)
                                    s[o].mipmaps.push(r.mipmaps[o * r.mipmapCount + c]),
                                    s[o].format = r.format,
                                    s[o].width = r.width,
                                    s[o].height = r.height
                            }
                        else
                            h.image.width = r.width,
                            h.image.height = r.height,
                            h.mipmaps = r.mipmaps;
                        1 === r.mipmapCount && (h.minFilter = i.LinearFilter),
                        h.format = r.format,
                        h.needsUpdate = !0,
                        e && e(h)
                    }, r, n);
                return h
            },
            setPath: function(t) {
                this.path = t
            }
        },
        i.Material = function() {
            Object.defineProperty(this, "id", {
                value: i.MaterialIdCount++
            }),
            this.uuid = i.Math.generateUUID(),
            this.name = "",
            this.type = "Material",
            this.side = i.FrontSide,
            this.opacity = 1,
            this.transparent = !1,
            this.blending = i.NormalBlending,
            this.blendSrc = i.SrcAlphaFactor,
            this.blendDst = i.OneMinusSrcAlphaFactor,
            this.blendEquation = i.AddEquation,
            this.blendSrcAlpha = null,
            this.blendDstAlpha = null,
            this.blendEquationAlpha = null,
            this.depthFunc = i.LessEqualDepth,
            this.depthTest = !0,
            this.depthWrite = !0,
            this.colorWrite = !0,
            this.precision = null,
            this.polygonOffset = !1,
            this.polygonOffsetFactor = 0,
            this.polygonOffsetUnits = 0,
            this.alphaTest = 0,
            this.overdraw = 0,
            this.visible = !0,
            this._needsUpdate = !0
        }
        ,
        i.Material.prototype = {
            constructor: i.Material,
            get needsUpdate() {
                return this._needsUpdate
            },
            set needsUpdate(t) {
                t === !0 && this.update(),
                this._needsUpdate = t
            },
            setValues: function(t) {
                if (void 0 !== t)
                    for (var e in t) {
                        var r = t[e];
                        if (void 0 !== r) {
                            var n = this[e];
                            void 0 !== n ? n instanceof i.Color ? n.set(r) : n instanceof i.Vector3 && r instanceof i.Vector3 ? n.copy(r) : "overdraw" === e ? this[e] = Number(r) : this[e] = r : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        } else
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                    }
            },
            toJSON: function(t) {
                function e(t) {
                    var e = [];
                    for (var r in t) {
                        var i = t[r];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
                var r = void 0 === t;
                r && (t = {
                    textures: {},
                    images: {}
                });
                var n = {
                    metadata: {
                        version: 4.4,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color instanceof i.Color && (n.color = this.color.getHex()),
                .5 !== this.roughness && (n.roughness = this.roughness),
                .5 !== this.metalness && (n.metalness = this.metalness),
                this.emissive instanceof i.Color && (n.emissive = this.emissive.getHex()),
                this.specular instanceof i.Color && (n.specular = this.specular.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                this.map instanceof i.Texture && (n.map = this.map.toJSON(t).uuid),
                this.alphaMap instanceof i.Texture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                this.lightMap instanceof i.Texture && (n.lightMap = this.lightMap.toJSON(t).uuid),
                this.bumpMap instanceof i.Texture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap instanceof i.Texture && (n.normalMap = this.normalMap.toJSON(t).uuid,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap instanceof i.Texture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap instanceof i.Texture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                this.metalnessMap instanceof i.Texture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                this.emissiveMap instanceof i.Texture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                this.specularMap instanceof i.Texture && (n.specularMap = this.specularMap.toJSON(t).uuid),
                this.envMap instanceof i.Texture && (n.envMap = this.envMap.toJSON(t).uuid,
                n.reflectivity = this.reflectivity),
                void 0 !== this.size && (n.size = this.size),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                void 0 !== this.vertexColors && this.vertexColors !== i.NoColors && (n.vertexColors = this.vertexColors),
                void 0 !== this.shading && this.shading !== i.SmoothShading && (n.shading = this.shading),
                void 0 !== this.blending && this.blending !== i.NormalBlending && (n.blending = this.blending),
                void 0 !== this.side && this.side !== i.FrontSide && (n.side = this.side),
                this.opacity < 1 && (n.opacity = this.opacity),
                this.transparent === !0 && (n.transparent = this.transparent),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                this.wireframe === !0 && (n.wireframe = this.wireframe),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                r) {
                    var o = e(t.textures)
                      , a = e(t.images);
                    o.length > 0 && (n.textures = o),
                    a.length > 0 && (n.images = a)
                }
                return n
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.name = t.name,
                this.side = t.side,
                this.opacity = t.opacity,
                this.transparent = t.transparent,
                this.blending = t.blending,
                this.blendSrc = t.blendSrc,
                this.blendDst = t.blendDst,
                this.blendEquation = t.blendEquation,
                this.blendSrcAlpha = t.blendSrcAlpha,
                this.blendDstAlpha = t.blendDstAlpha,
                this.blendEquationAlpha = t.blendEquationAlpha,
                this.depthFunc = t.depthFunc,
                this.depthTest = t.depthTest,
                this.depthWrite = t.depthWrite,
                this.colorWrite = t.colorWrite,
                this.precision = t.precision,
                this.polygonOffset = t.polygonOffset,
                this.polygonOffsetFactor = t.polygonOffsetFactor,
                this.polygonOffsetUnits = t.polygonOffsetUnits,
                this.alphaTest = t.alphaTest,
                this.overdraw = t.overdraw,
                this.visible = t.visible,
                this
            },
            update: function() {
                this.dispatchEvent({
                    type: "update"
                })
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        },
        i.EventDispatcher.prototype.apply(i.Material.prototype),
        i.MaterialIdCount = 0,
        i.LineBasicMaterial = function(t) {
            i.Material.call(this),
            this.type = "LineBasicMaterial",
            this.color = new i.Color(16777215),
            this.linewidth = 1,
            this.linecap = "round",
            this.linejoin = "round",
            this.vertexColors = i.NoColors,
            this.fog = !0,
            this.setValues(t)
        }
        ,
        i.LineBasicMaterial.prototype = Object.create(i.Material.prototype),
        i.LineBasicMaterial.prototype.constructor = i.LineBasicMaterial,
        i.LineBasicMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.linewidth = t.linewidth,
            this.linecap = t.linecap,
            this.linejoin = t.linejoin,
            this.vertexColors = t.vertexColors,
            this.fog = t.fog,
            this
        }
        ,
        i.LineDashedMaterial = function(t) {
            i.Material.call(this),
            this.type = "LineDashedMaterial",
            this.color = new i.Color(16777215),
            this.linewidth = 1,
            this.scale = 1,
            this.dashSize = 3,
            this.gapSize = 1,
            this.vertexColors = i.NoColors,
            this.fog = !0,
            this.setValues(t)
        }
        ,
        i.LineDashedMaterial.prototype = Object.create(i.Material.prototype),
        i.LineDashedMaterial.prototype.constructor = i.LineDashedMaterial,
        i.LineDashedMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.linewidth = t.linewidth,
            this.scale = t.scale,
            this.dashSize = t.dashSize,
            this.gapSize = t.gapSize,
            this.vertexColors = t.vertexColors,
            this.fog = t.fog,
            this
        }
        ,
        i.MeshBasicMaterial = function(t) {
            i.Material.call(this),
            this.type = "MeshBasicMaterial",
            this.color = new i.Color(16777215),
            this.map = null,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = i.MultiplyOperation,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.fog = !0,
            this.shading = i.SmoothShading,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.vertexColors = i.NoColors,
            this.skinning = !1,
            this.morphTargets = !1,
            this.setValues(t)
        }
        ,
        i.MeshBasicMaterial.prototype = Object.create(i.Material.prototype),
        i.MeshBasicMaterial.prototype.constructor = i.MeshBasicMaterial,
        i.MeshBasicMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.map = t.map,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.fog = t.fog,
            this.shading = t.shading,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.vertexColors = t.vertexColors,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this
        }
        ,
        i.MeshLambertMaterial = function(t) {
            i.Material.call(this),
            this.type = "MeshLambertMaterial",
            this.color = new i.Color(16777215),
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new i.Color(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = i.MultiplyOperation,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.fog = !0,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.vertexColors = i.NoColors,
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.setValues(t)
        }
        ,
        i.MeshLambertMaterial.prototype = Object.create(i.Material.prototype);
        i.MeshLambertMaterial.prototype.constructor = i.MeshLambertMaterial;
        i.MeshLambertMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.fog = t.fog,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.vertexColors = t.vertexColors,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this
        }
        ,
        i.MeshPhongMaterial = function(t) {
            i.Material.call(this),
            this.type = "MeshPhongMaterial",
            this.color = new i.Color(16777215),
            this.specular = new i.Color(1118481),
            this.shininess = 30,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new i.Color(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalScale = new i.Vector2(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = i.MultiplyOperation,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.fog = !0,
            this.shading = i.SmoothShading,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.vertexColors = i.NoColors,
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.setValues(t)
        }
        ,
        i.MeshPhongMaterial.prototype = Object.create(i.Material.prototype),
        i.MeshPhongMaterial.prototype.constructor = i.MeshPhongMaterial,
        i.MeshPhongMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            this.shininess = t.shininess,
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.fog = t.fog,
            this.shading = t.shading,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.vertexColors = t.vertexColors,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this
        }
        ,
        i.MeshStandardMaterial = function(t) {
            i.Material.call(this),
            this.type = "MeshStandardMaterial",
            this.color = new i.Color(16777215),
            this.roughness = .5,
            this.metalness = .5,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new i.Color(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalScale = new i.Vector2(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.roughnessMap = null,
            this.metalnessMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.envMapIntensity = 1,
            this.refractionRatio = .98,
            this.fog = !0,
            this.shading = i.SmoothShading,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.vertexColors = i.NoColors,
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.setValues(t)
        }
        ,
        i.MeshStandardMaterial.prototype = Object.create(i.Material.prototype),
        i.MeshStandardMaterial.prototype.constructor = i.MeshStandardMaterial,
        i.MeshStandardMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.roughness = t.roughness,
            this.metalness = t.metalness,
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.roughnessMap = t.roughnessMap,
            this.metalnessMap = t.metalnessMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.envMapIntensity = t.envMapIntensity,
            this.refractionRatio = t.refractionRatio,
            this.fog = t.fog,
            this.shading = t.shading,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.vertexColors = t.vertexColors,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this
        }
        ,
        i.MeshDepthMaterial = function(t) {
            i.Material.call(this),
            this.type = "MeshDepthMaterial",
            this.morphTargets = !1,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.setValues(t)
        }
        ,
        i.MeshDepthMaterial.prototype = Object.create(i.Material.prototype),
        i.MeshDepthMaterial.prototype.constructor = i.MeshDepthMaterial,
        i.MeshDepthMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this
        }
        ,
        i.MeshNormalMaterial = function(t) {
            i.Material.call(this, t),
            this.type = "MeshNormalMaterial",
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.morphTargets = !1,
            this.setValues(t)
        }
        ,
        i.MeshNormalMaterial.prototype = Object.create(i.Material.prototype),
        i.MeshNormalMaterial.prototype.constructor = i.MeshNormalMaterial,
        i.MeshNormalMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this
        }
        ,
        i.MultiMaterial = function(t) {
            this.uuid = i.Math.generateUUID(),
            this.type = "MultiMaterial",
            this.materials = t instanceof Array ? t : [],
            this.visible = !0
        }
        ,
        i.MultiMaterial.prototype = {
            constructor: i.MultiMaterial,
            toJSON: function(t) {
                for (var e = {
                    metadata: {
                        version: 4.2,
                        type: "material",
                        generator: "MaterialExporter"
                    },
                    uuid: this.uuid,
                    type: this.type,
                    materials: []
                }, r = this.materials, i = 0, n = r.length; i < n; i++) {
                    var o = r[i].toJSON(t);
                    delete o.metadata,
                    e.materials.push(o)
                }
                return e.visible = this.visible,
                e
            },
            clone: function() {
                for (var t = new this.constructor, e = 0; e < this.materials.length; e++)
                    t.materials.push(this.materials[e].clone());
                return t.visible = this.visible,
                t
            }
        },
        i.PointsMaterial = function(t) {
            i.Material.call(this),
            this.type = "PointsMaterial",
            this.color = new i.Color(16777215),
            this.map = null,
            this.size = 1,
            this.sizeAttenuation = !0,
            this.vertexColors = i.NoColors,
            this.fog = !0,
            this.setValues(t)
        }
        ,
        i.PointsMaterial.prototype = Object.create(i.Material.prototype),
        i.PointsMaterial.prototype.constructor = i.PointsMaterial,
        i.PointsMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.map = t.map,
            this.size = t.size,
            this.sizeAttenuation = t.sizeAttenuation,
            this.vertexColors = t.vertexColors,
            this.fog = t.fog,
            this
        }
        ,
        i.ShaderMaterial = function(t) {
            i.Material.call(this),
            this.type = "ShaderMaterial",
            this.defines = {},
            this.uniforms = {},
            this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
            this.shading = i.SmoothShading,
            this.linewidth = 1,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.lights = !1,
            this.vertexColors = i.NoColors,
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            },
            this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            },
            this.index0AttributeName = void 0,
            void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
            this.setValues(t))
        }
        ,
        i.ShaderMaterial.prototype = Object.create(i.Material.prototype),
        i.ShaderMaterial.prototype.constructor = i.ShaderMaterial,
        i.ShaderMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.fragmentShader = t.fragmentShader,
            this.vertexShader = t.vertexShader,
            this.uniforms = i.UniformsUtils.clone(t.uniforms),
            this.defines = t.defines,
            this.shading = t.shading,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.fog = t.fog,
            this.lights = t.lights,
            this.vertexColors = t.vertexColors,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this.extensions = t.extensions,
            this
        }
        ,
        i.ShaderMaterial.prototype.toJSON = function(t) {
            var e = i.Material.prototype.toJSON.call(this, t);
            return e.uniforms = this.uniforms,
            e.vertexShader = this.vertexShader,
            e.fragmentShader = this.fragmentShader,
            e
        }
        ,
        i.RawShaderMaterial = function(t) {
            i.ShaderMaterial.call(this, t),
            this.type = "RawShaderMaterial"
        }
        ,
        i.RawShaderMaterial.prototype = Object.create(i.ShaderMaterial.prototype),
        i.RawShaderMaterial.prototype.constructor = i.RawShaderMaterial,
        i.SpriteMaterial = function(t) {
            i.Material.call(this),
            this.type = "SpriteMaterial",
            this.color = new i.Color(16777215),
            this.map = null,
            this.rotation = 0,
            this.fog = !1,
            this.setValues(t)
        }
        ,
        i.SpriteMaterial.prototype = Object.create(i.Material.prototype),
        i.SpriteMaterial.prototype.constructor = i.SpriteMaterial,
        i.SpriteMaterial.prototype.copy = function(t) {
            return i.Material.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.map = t.map,
            this.rotation = t.rotation,
            this.fog = t.fog,
            this
        }
        ,
        i.Texture = function(t, e, r, n, o, a, s, h, c) {
            Object.defineProperty(this, "id", {
                value: i.TextureIdCount++
            }),
            this.uuid = i.Math.generateUUID(),
            this.name = "",
            this.sourceFile = "",
            this.image = void 0 !== t ? t : i.Texture.DEFAULT_IMAGE,
            this.mipmaps = [],
            this.mapping = void 0 !== e ? e : i.Texture.DEFAULT_MAPPING,
            this.wrapS = void 0 !== r ? r : i.ClampToEdgeWrapping,
            this.wrapT = void 0 !== n ? n : i.ClampToEdgeWrapping,
            this.magFilter = void 0 !== o ? o : i.LinearFilter,
            this.minFilter = void 0 !== a ? a : i.LinearMipMapLinearFilter,
            this.anisotropy = void 0 !== c ? c : 1,
            this.format = void 0 !== s ? s : i.RGBAFormat,
            this.type = void 0 !== h ? h : i.UnsignedByteType,
            this.offset = new i.Vector2(0,0),
            this.repeat = new i.Vector2(1,1),
            this.generateMipmaps = !0,
            this.premultiplyAlpha = !1,
            this.flipY = !0,
            this.unpackAlignment = 4,
            this.version = 0,
            this.onUpdate = null
        }
        ,
        i.Texture.DEFAULT_IMAGE = void 0,
        i.Texture.DEFAULT_MAPPING = i.UVMapping,
        i.Texture.prototype = {
            constructor: i.Texture,
            set needsUpdate(t) {
                t === !0 && this.version++
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.image = t.image,
                this.mipmaps = t.mipmaps.slice(0),
                this.mapping = t.mapping,
                this.wrapS = t.wrapS,
                this.wrapT = t.wrapT,
                this.magFilter = t.magFilter,
                this.minFilter = t.minFilter,
                this.anisotropy = t.anisotropy,
                this.format = t.format,
                this.type = t.type,
                this.offset.copy(t.offset),
                this.repeat.copy(t.repeat),
                this.generateMipmaps = t.generateMipmaps,
                this.premultiplyAlpha = t.premultiplyAlpha,
                this.flipY = t.flipY,
                this.unpackAlignment = t.unpackAlignment,
                this
            },
            toJSON: function(t) {
                function e(t) {
                    var e;
                    return void 0 !== t.toDataURL ? e = t : (e = document.createElement("canvas"),
                    e.width = t.width,
                    e.height = t.height,
                    e.getContext("2d").drawImage(t, 0, 0, t.width, t.height)),
                    e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                }
                if (void 0 !== t.textures[this.uuid])
                    return t.textures[this.uuid];
                var r = {
                    metadata: {
                        version: 4.4,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    wrap: [this.wrapS, this.wrapT],
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy
                };
                if (void 0 !== this.image) {
                    var n = this.image;
                    void 0 === n.uuid && (n.uuid = i.Math.generateUUID()),
                    void 0 === t.images[n.uuid] && (t.images[n.uuid] = {
                        uuid: n.uuid,
                        url: e(n)
                    }),
                    r.image = n.uuid
                }
                return t.textures[this.uuid] = r,
                r
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function(t) {
                if (this.mapping === i.UVMapping) {
                    if (t.multiply(this.repeat),
                    t.add(this.offset),
                    t.x < 0 || t.x > 1)
                        switch (this.wrapS) {
                        case i.RepeatWrapping:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case i.ClampToEdgeWrapping:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case i.MirroredRepeatWrapping:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                        }
                    if (t.y < 0 || t.y > 1)
                        switch (this.wrapT) {
                        case i.RepeatWrapping:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case i.ClampToEdgeWrapping:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case i.MirroredRepeatWrapping:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                        }
                    this.flipY && (t.y = 1 - t.y)
                }
            }
        },
        i.EventDispatcher.prototype.apply(i.Texture.prototype),
        i.TextureIdCount = 0,
        i.CanvasTexture = function(t, e, r, n, o, a, s, h, c) {
            i.Texture.call(this, t, e, r, n, o, a, s, h, c),
            this.needsUpdate = !0
        }
        ,
        i.CanvasTexture.prototype = Object.create(i.Texture.prototype),
        i.CanvasTexture.prototype.constructor = i.CanvasTexture,
        i.CubeTexture = function(t, e, r, n, o, a, s, h, c) {
            e = void 0 !== e ? e : i.CubeReflectionMapping,
            i.Texture.call(this, t, e, r, n, o, a, s, h, c),
            this.images = t,
            this.flipY = !1
        }
        ,
        i.CubeTexture.prototype = Object.create(i.Texture.prototype),
        i.CubeTexture.prototype.constructor = i.CubeTexture,
        i.CubeTexture.prototype.copy = function(t) {
            return i.Texture.prototype.copy.call(this, t),
            this.images = t.images,
            this
        }
        ,
        i.CompressedTexture = function(t, e, r, n, o, a, s, h, c, l, u) {
            i.Texture.call(this, null, a, s, h, c, l, n, o, u),
            this.image = {
                width: e,
                height: r
            },
            this.mipmaps = t,
            this.flipY = !1,
            this.generateMipmaps = !1
        }
        ,
        i.CompressedTexture.prototype = Object.create(i.Texture.prototype),
        i.CompressedTexture.prototype.constructor = i.CompressedTexture,
        i.DataTexture = function(t, e, r, n, o, a, s, h, c, l, u) {
            i.Texture.call(this, null, a, s, h, c, l, n, o, u),
            this.image = {
                data: t,
                width: e,
                height: r
            },
            this.magFilter = void 0 !== c ? c : i.NearestFilter,
            this.minFilter = void 0 !== l ? l : i.NearestFilter,
            this.flipY = !1,
            this.generateMipmaps = !1
        }
        ,
        i.DataTexture.prototype = Object.create(i.Texture.prototype),
        i.DataTexture.prototype.constructor = i.DataTexture,
        i.VideoTexture = function(t, e, r, n, o, a, s, h, c) {
            function l() {
                requestAnimationFrame(l),
                t.readyState === t.HAVE_ENOUGH_DATA && (u.needsUpdate = !0)
            }
            i.Texture.call(this, t, e, r, n, o, a, s, h, c),
            this.generateMipmaps = !1;
            var u = this;
            l()
        }
        ,
        i.VideoTexture.prototype = Object.create(i.Texture.prototype),
        i.VideoTexture.prototype.constructor = i.VideoTexture,
        i.Group = function() {
            i.Object3D.call(this),
            this.type = "Group"
        }
        ,
        i.Group.prototype = Object.create(i.Object3D.prototype),
        i.Group.prototype.constructor = i.Group,
        i.Points = function(t, e) {
            i.Object3D.call(this),
            this.type = "Points",
            this.geometry = void 0 !== t ? t : new i.Geometry,
            this.material = void 0 !== e ? e : new i.PointsMaterial({
                color: 16777215 * Math.random()
            })
        }
        ,
        i.Points.prototype = Object.create(i.Object3D.prototype),
        i.Points.prototype.constructor = i.Points,
        i.Points.prototype.raycast = function() {
            var t = new i.Matrix4
              , e = new i.Ray
              , r = new i.Sphere;
            return function(n, o) {
                function a(t, r) {
                    var i = e.distanceSqToPoint(t);
                    if (i < p) {
                        var a = e.closestPointToPoint(t);
                        a.applyMatrix4(c);
                        var h = n.ray.origin.distanceTo(a);
                        if (h < n.near || h > n.far)
                            return;
                        o.push({
                            distance: h,
                            distanceToRay: Math.sqrt(i),
                            point: a.clone(),
                            index: r,
                            face: null,
                            object: s
                        })
                    }
                }
                var s = this
                  , h = this.geometry
                  , c = this.matrixWorld
                  , l = n.params.Points.threshold;
                if (null === h.boundingSphere && h.computeBoundingSphere(),
                r.copy(h.boundingSphere),
                r.applyMatrix4(c),
                n.ray.intersectsSphere(r) !== !1) {
                    t.getInverse(c),
                    e.copy(n.ray).applyMatrix4(t);
                    var u = l / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , p = u * u
                      , d = new i.Vector3;
                    if (h instanceof i.BufferGeometry) {
                        var f = h.index
                          , m = h.attributes
                          , g = m.position.array;
                        if (null !== f)
                            for (var v = f.array, y = 0, x = v.length; y < x; y++) {
                                var b = v[y];
                                d.fromArray(g, 3 * b),
                                a(d, b)
                            }
                        else
                            for (var y = 0, w = g.length / 3; y < w; y++)
                                d.fromArray(g, 3 * y),
                                a(d, y)
                    } else
                        for (var _ = h.vertices, y = 0, w = _.length; y < w; y++)
                            a(_[y], y)
                }
            }
        }(),
        i.Points.prototype.clone = function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
        ,
        i.Line = function(t, e, r) {
            return 1 === r ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
            new i.LineSegments(t,e)) : (i.Object3D.call(this),
            this.type = "Line",
            this.geometry = void 0 !== t ? t : new i.Geometry,
            void (this.material = void 0 !== e ? e : new i.LineBasicMaterial({
                color: 16777215 * Math.random()
            })))
        }
        ,
        i.Line.prototype = Object.create(i.Object3D.prototype),
        i.Line.prototype.constructor = i.Line,
        i.Line.prototype.raycast = function() {
            var t = new i.Matrix4
              , e = new i.Ray
              , r = new i.Sphere;
            return function(n, o) {
                var a = n.linePrecision
                  , s = a * a
                  , h = this.geometry
                  , c = this.matrixWorld;
                if (null === h.boundingSphere && h.computeBoundingSphere(),
                r.copy(h.boundingSphere),
                r.applyMatrix4(c),
                n.ray.intersectsSphere(r) !== !1) {
                    t.getInverse(c),
                    e.copy(n.ray).applyMatrix4(t);
                    var l = new i.Vector3
                      , u = new i.Vector3
                      , p = new i.Vector3
                      , d = new i.Vector3
                      , f = this instanceof i.LineSegments ? 2 : 1;
                    if (h instanceof i.BufferGeometry) {
                        var m = h.index
                          , g = h.attributes
                          , v = g.position.array;
                        if (null !== m)
                            for (var y = m.array, x = 0, b = y.length - 1; x < b; x += f) {
                                var w = y[x]
                                  , _ = y[x + 1];
                                l.fromArray(v, 3 * w),
                                u.fromArray(v, 3 * _);
                                var M = e.distanceSqToSegment(l, u, d, p);
                                if (!(M > s)) {
                                    d.applyMatrix4(this.matrixWorld);
                                    var S = n.ray.origin.distanceTo(d);
                                    S < n.near || S > n.far || o.push({
                                        distance: S,
                                        point: p.clone().applyMatrix4(this.matrixWorld),
                                        index: x,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                        else
                            for (var x = 0, b = v.length / 3 - 1; x < b; x += f) {
                                l.fromArray(v, 3 * x),
                                u.fromArray(v, 3 * x + 3);
                                var M = e.distanceSqToSegment(l, u, d, p);
                                if (!(M > s)) {
                                    d.applyMatrix4(this.matrixWorld);
                                    var S = n.ray.origin.distanceTo(d);
                                    S < n.near || S > n.far || o.push({
                                        distance: S,
                                        point: p.clone().applyMatrix4(this.matrixWorld),
                                        index: x,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                    } else if (h instanceof i.Geometry)
                        for (var E = h.vertices, T = E.length, x = 0; x < T - 1; x += f) {
                            var M = e.distanceSqToSegment(E[x], E[x + 1], d, p);
                            if (!(M > s)) {
                                d.applyMatrix4(this.matrixWorld);
                                var S = n.ray.origin.distanceTo(d);
                                S < n.near || S > n.far || o.push({
                                    distance: S,
                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                    index: x,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                }
            }
        }(),
        i.Line.prototype.clone = function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
        ,
        i.LineStrip = 0,
        i.LinePieces = 1,
        i.LineSegments = function(t, e) {
            i.Line.call(this, t, e),
            this.type = "LineSegments"
        }
        ,
        i.LineSegments.prototype = Object.create(i.Line.prototype),
        i.LineSegments.prototype.constructor = i.LineSegments,
        i.Mesh = function(t, e) {
            i.Object3D.call(this),
            this.type = "Mesh",
            this.geometry = void 0 !== t ? t : new i.Geometry,
            this.material = void 0 !== e ? e : new i.MeshBasicMaterial({
                color: 16777215 * Math.random()
            }),
            this.drawMode = i.TrianglesDrawMode,
            this.updateMorphTargets()
        }
        ,
        i.Mesh.prototype = Object.create(i.Object3D.prototype),
        i.Mesh.prototype.constructor = i.Mesh,
        i.Mesh.prototype.setDrawMode = function(t) {
            this.drawMode = t
        }
        ,
        i.Mesh.prototype.updateMorphTargets = function() {
            if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) {
                this.morphTargetBase = -1,
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (var t = 0, e = this.geometry.morphTargets.length; t < e; t++)
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[this.geometry.morphTargets[t].name] = t
            }
        }
        ,
        i.Mesh.prototype.getMorphTargetIndexByName = function(t) {
            return void 0 !== this.morphTargetDictionary[t] ? this.morphTargetDictionary[t] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + t + " does not exist. Returning 0."),
            0)
        }
        ,
        i.Mesh.prototype.raycast = function() {
            function t(t, e, r, n, o, a, s) {
                return i.Triangle.barycoordFromPoint(t, e, r, n, g),
                o.multiplyScalar(g.x),
                a.multiplyScalar(g.y),
                s.multiplyScalar(g.z),
                o.add(a).add(s),
                o.clone()
            }
            function e(t, e, r, n, o, a, s) {
                var h, c = t.material;
                if (h = c.side === i.BackSide ? r.intersectTriangle(a, o, n, !0, s) : r.intersectTriangle(n, o, a, c.side !== i.DoubleSide, s),
                null === h)
                    return null;
                y.copy(s),
                y.applyMatrix4(t.matrixWorld);
                var l = e.ray.origin.distanceTo(y);
                return l < e.near || l > e.far ? null : {
                    distance: l,
                    point: y.clone(),
                    object: t
                }
            }
            function r(r, n, o, a, l, u, p, g) {
                s.fromArray(a, 3 * u),
                h.fromArray(a, 3 * p),
                c.fromArray(a, 3 * g);
                var y = e(r, n, o, s, h, c, v);
                return y && (l && (d.fromArray(l, 2 * u),
                f.fromArray(l, 2 * p),
                m.fromArray(l, 2 * g),
                y.uv = t(v, s, h, c, d, f, m)),
                y.face = new i.Face3(u,p,g,i.Triangle.normal(s, h, c)),
                y.faceIndex = u),
                y
            }
            var n = new i.Matrix4
              , o = new i.Ray
              , a = new i.Sphere
              , s = new i.Vector3
              , h = new i.Vector3
              , c = new i.Vector3
              , l = new i.Vector3
              , u = new i.Vector3
              , p = new i.Vector3
              , d = new i.Vector2
              , f = new i.Vector2
              , m = new i.Vector2
              , g = new i.Vector3
              , v = new i.Vector3
              , y = new i.Vector3;
            return function(g, y) {
                var x = this.geometry
                  , b = this.material
                  , w = this.matrixWorld;
                if (void 0 !== b && (null === x.boundingSphere && x.computeBoundingSphere(),
                a.copy(x.boundingSphere),
                a.applyMatrix4(w),
                g.ray.intersectsSphere(a) !== !1 && (n.getInverse(w),
                o.copy(g.ray).applyMatrix4(n),
                null === x.boundingBox || o.intersectsBox(x.boundingBox) !== !1))) {
                    var _, M;
                    if (x instanceof i.BufferGeometry) {
                        var S, E, T, A = x.index, L = x.attributes, C = L.position.array;
                        if (void 0 !== L.uv && (_ = L.uv.array),
                        null !== A)
                            for (var R = A.array, P = 0, U = R.length; P < U; P += 3)
                                S = R[P],
                                E = R[P + 1],
                                T = R[P + 2],
                                M = r(this, g, o, C, _, S, E, T),
                                M && (M.faceIndex = Math.floor(P / 3),
                                y.push(M));
                        else
                            for (var P = 0, U = C.length; P < U; P += 9)
                                S = P / 3,
                                E = S + 1,
                                T = S + 2,
                                M = r(this, g, o, C, _, S, E, T),
                                M && (M.index = S,
                                y.push(M))
                    } else if (x instanceof i.Geometry) {
                        var I, D, O, N = b instanceof i.MultiMaterial, B = N === !0 ? b.materials : null, F = x.vertices, k = x.faces, z = x.faceVertexUvs[0];
                        z.length > 0 && (_ = z);
                        for (var V = 0, G = k.length; V < G; V++) {
                            var j = k[V]
                              , H = N === !0 ? B[j.materialIndex] : b;
                            if (void 0 !== H) {
                                if (I = F[j.a],
                                D = F[j.b],
                                O = F[j.c],
                                H.morphTargets === !0) {
                                    var W = x.morphTargets
                                      , X = this.morphTargetInfluences;
                                    s.set(0, 0, 0),
                                    h.set(0, 0, 0),
                                    c.set(0, 0, 0);
                                    for (var Y = 0, q = W.length; Y < q; Y++) {
                                        var Z = X[Y];
                                        if (0 !== Z) {
                                            var Q = W[Y].vertices;
                                            s.addScaledVector(l.subVectors(Q[j.a], I), Z),
                                            h.addScaledVector(u.subVectors(Q[j.b], D), Z),
                                            c.addScaledVector(p.subVectors(Q[j.c], O), Z)
                                        }
                                    }
                                    s.add(I),
                                    h.add(D),
                                    c.add(O),
                                    I = s,
                                    D = h,
                                    O = c
                                }
                                if (M = e(this, g, o, I, D, O, v)) {
                                    if (_) {
                                        var J = _[V];
                                        d.copy(J[0]),
                                        f.copy(J[1]),
                                        m.copy(J[2]),
                                        M.uv = t(v, I, D, O, d, f, m)
                                    }
                                    M.face = j,
                                    M.faceIndex = V,
                                    y.push(M)
                                }
                            }
                        }
                    }
                }
            }
        }(),
        i.Mesh.prototype.clone = function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
        ,
        i.Bone = function(t) {
            i.Object3D.call(this),
            this.type = "Bone",
            this.skin = t
        }
        ,
        i.Bone.prototype = Object.create(i.Object3D.prototype),
        i.Bone.prototype.constructor = i.Bone,
        i.Bone.prototype.copy = function(t) {
            return i.Object3D.prototype.copy.call(this, t),
            this.skin = t.skin,
            this
        }
        ,
        i.Skeleton = function(t, e, r) {
            if (this.useVertexTexture = void 0 === r || r,
            this.identityMatrix = new i.Matrix4,
            t = t || [],
            this.bones = t.slice(0),
            this.useVertexTexture) {
                var n = Math.sqrt(4 * this.bones.length);
                n = i.Math.nextPowerOfTwo(Math.ceil(n)),
                n = Math.max(n, 4),
                this.boneTextureWidth = n,
                this.boneTextureHeight = n,
                this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4),
                this.boneTexture = new i.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,i.RGBAFormat,i.FloatType)
            } else
                this.boneMatrices = new Float32Array(16 * this.bones.length);
            if (void 0 === e)
                this.calculateInverses();
            else if (this.bones.length === e.length)
                this.boneInverses = e.slice(0);
            else {
                console.warn("THREE.Skeleton bonInverses is the wrong length."),
                this.boneInverses = [];
                for (var o = 0, a = this.bones.length; o < a; o++)
                    this.boneInverses.push(new i.Matrix4)
            }
        }
        ,
        i.Skeleton.prototype.calculateInverses = function() {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var r = new i.Matrix4;
                this.bones[t] && r.getInverse(this.bones[t].matrixWorld),
                this.boneInverses.push(r)
            }
        }
        ,
        i.Skeleton.prototype.pose = function() {
            for (var t, e = 0, r = this.bones.length; e < r; e++)
                t = this.bones[e],
                t && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (var e = 0, r = this.bones.length; e < r; e++)
                t = this.bones[e],
                t && (t.parent ? (t.matrix.getInverse(t.parent.matrixWorld),
                t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                t.matrix.decompose(t.position, t.quaternion, t.scale))
        }
        ,
        i.Skeleton.prototype.update = function() {
            var t = new i.Matrix4;
            return function() {
                for (var e = 0, r = this.bones.length; e < r; e++) {
                    var i = this.bones[e] ? this.bones[e].matrixWorld : this.identityMatrix;
                    t.multiplyMatrices(i, this.boneInverses[e]),
                    t.flattenToArrayOffset(this.boneMatrices, 16 * e)
                }
                this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
            }
        }(),
        i.Skeleton.prototype.clone = function() {
            return new i.Skeleton(this.bones,this.boneInverses,this.useVertexTexture)
        }
        ,
        i.SkinnedMesh = function(t, e, r) {
            i.Mesh.call(this, t, e),
            this.type = "SkinnedMesh",
            this.bindMode = "attached",
            this.bindMatrix = new i.Matrix4,
            this.bindMatrixInverse = new i.Matrix4;
            var n = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (var o, a, s = 0, h = this.geometry.bones.length; s < h; ++s)
                    a = this.geometry.bones[s],
                    o = new i.Bone(this),
                    n.push(o),
                    o.name = a.name,
                    o.position.fromArray(a.pos),
                    o.quaternion.fromArray(a.rotq),
                    void 0 !== a.scl && o.scale.fromArray(a.scl);
                for (var s = 0, h = this.geometry.bones.length; s < h; ++s)
                    a = this.geometry.bones[s],
                    a.parent !== -1 && null !== a.parent ? n[a.parent].add(n[s]) : this.add(n[s])
            }
            this.normalizeSkinWeights(),
            this.updateMatrixWorld(!0),
            this.bind(new i.Skeleton(n,(void 0),r), this.matrixWorld)
        }
        ,
        i.SkinnedMesh.prototype = Object.create(i.Mesh.prototype),
        i.SkinnedMesh.prototype.constructor = i.SkinnedMesh,
        i.SkinnedMesh.prototype.bind = function(t, e) {
            this.skeleton = t,
            void 0 === e && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            e = this.matrixWorld),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e)
        }
        ,
        i.SkinnedMesh.prototype.pose = function() {
            this.skeleton.pose()
        }
        ,
        i.SkinnedMesh.prototype.normalizeSkinWeights = function() {
            if (this.geometry instanceof i.Geometry)
                for (var t = 0; t < this.geometry.skinWeights.length; t++) {
                    var e = this.geometry.skinWeights[t]
                      , r = 1 / e.lengthManhattan();
                    r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0)
                }
            else if (this.geometry instanceof i.BufferGeometry)
                for (var n = new i.Vector4, o = this.geometry.attributes.skinWeight, t = 0; t < o.count; t++) {
                    n.x = o.getX(t),
                    n.y = o.getY(t),
                    n.z = o.getZ(t),
                    n.w = o.getW(t);
                    var r = 1 / n.lengthManhattan();
                    r !== 1 / 0 ? n.multiplyScalar(r) : n.set(1, 0, 0, 0),
                    o.setXYZW(t, n.x, n.y, n.z, n.w)
                }
        }
        ,
        i.SkinnedMesh.prototype.updateMatrixWorld = function(t) {
            i.Mesh.prototype.updateMatrixWorld.call(this, !0),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
        }
        ,
        i.SkinnedMesh.prototype.clone = function() {
            return new this.constructor(this.geometry,this.material,this.useVertexTexture).copy(this)
        }
        ,
        i.LOD = function() {
            i.Object3D.call(this),
            this.type = "LOD",
            Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                },
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                        this.levels
                    }
                }
            })
        }
        ,
        i.LOD.prototype = Object.create(i.Object3D.prototype),
        i.LOD.prototype.constructor = i.LOD,
        i.LOD.prototype.addLevel = function(t, e) {
            void 0 === e && (e = 0),
            e = Math.abs(e);
            for (var r = this.levels, i = 0; i < r.length && !(e < r[i].distance); i++)
                ;
            r.splice(i, 0, {
                distance: e,
                object: t
            }),
            this.add(t)
        }
        ,
        i.LOD.prototype.getObjectForDistance = function(t) {
            for (var e = this.levels, r = 1, i = e.length; r < i && !(t < e[r].distance); r++)
                ;
            return e[r - 1].object
        }
        ,
        i.LOD.prototype.raycast = function() {
            var t = new i.Vector3;
            return function(e, r) {
                t.setFromMatrixPosition(this.matrixWorld);
                var i = e.ray.origin.distanceTo(t);
                this.getObjectForDistance(i).raycast(e, r)
            }
        }(),
        i.LOD.prototype.update = function() {
            var t = new i.Vector3
              , e = new i.Vector3;
            return function(r) {
                var i = this.levels;
                if (i.length > 1) {
                    t.setFromMatrixPosition(r.matrixWorld),
                    e.setFromMatrixPosition(this.matrixWorld);
                    var n = t.distanceTo(e);
                    i[0].object.visible = !0;
                    for (var o = 1, a = i.length; o < a && n >= i[o].distance; o++)
                        i[o - 1].object.visible = !1,
                        i[o].object.visible = !0;
                    for (; o < a; o++)
                        i[o].object.visible = !1
                }
            }
        }(),
        i.LOD.prototype.copy = function(t) {
            i.Object3D.prototype.copy.call(this, t, !1);
            for (var e = t.levels, r = 0, n = e.length; r < n; r++) {
                var o = e[r];
                this.addLevel(o.object.clone(), o.distance)
            }
            return this
        }
        ,
        i.LOD.prototype.toJSON = function(t) {
            var e = i.Object3D.prototype.toJSON.call(this, t);
            e.object.levels = [];
            for (var r = this.levels, n = 0, o = r.length; n < o; n++) {
                var a = r[n];
                e.object.levels.push({
                    object: a.object.uuid,
                    distance: a.distance
                })
            }
            return e
        }
        ,
        i.Sprite = function() {
            var t = new Uint16Array([0, 1, 2, 0, 2, 3])
              , e = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0])
              , r = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
              , n = new i.BufferGeometry;
            return n.setIndex(new i.BufferAttribute(t,1)),
            n.addAttribute("position", new i.BufferAttribute(e,3)),
            n.addAttribute("uv", new i.BufferAttribute(r,2)),
            function(t) {
                i.Object3D.call(this),
                this.type = "Sprite",
                this.geometry = n,
                this.material = void 0 !== t ? t : new i.SpriteMaterial
            }
        }(),
        i.Sprite.prototype = Object.create(i.Object3D.prototype),
        i.Sprite.prototype.constructor = i.Sprite,
        i.Sprite.prototype.raycast = function() {
            var t = new i.Vector3;
            return function(e, r) {
                t.setFromMatrixPosition(this.matrixWorld);
                var i = e.ray.distanceSqToPoint(t)
                  , n = this.scale.x * this.scale.y;
                i > n || r.push({
                    distance: Math.sqrt(i),
                    point: this.position,
                    face: null,
                    object: this
                })
            }
        }(),
        i.Sprite.prototype.clone = function() {
            return new this.constructor(this.material).copy(this)
        }
        ,
        i.Particle = i.Sprite,
        i.LensFlare = function(t, e, r, n, o) {
            i.Object3D.call(this),
            this.lensFlares = [],
            this.positionScreen = new i.Vector3,
            this.customUpdateCallback = void 0,
            void 0 !== t && this.add(t, e, r, n, o)
        }
        ,
        i.LensFlare.prototype = Object.create(i.Object3D.prototype),
        i.LensFlare.prototype.constructor = i.LensFlare,
        i.LensFlare.prototype.add = function(t, e, r, n, o, a) {
            void 0 === e && (e = -1),
            void 0 === r && (r = 0),
            void 0 === a && (a = 1),
            void 0 === o && (o = new i.Color(16777215)),
            void 0 === n && (n = i.NormalBlending),
            r = Math.min(r, Math.max(0, r)),
            this.lensFlares.push({
                texture: t,
                size: e,
                distance: r,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: a,
                color: o,
                blending: n
            })
        }
        ,
        i.LensFlare.prototype.updateLensFlares = function() {
            var t, e, r = this.lensFlares.length, i = 2 * -this.positionScreen.x, n = 2 * -this.positionScreen.y;
            for (t = 0; t < r; t++)
                e = this.lensFlares[t],
                e.x = this.positionScreen.x + i * e.distance,
                e.y = this.positionScreen.y + n * e.distance,
                e.wantedRotation = e.x * Math.PI * .25,
                e.rotation += .25 * (e.wantedRotation - e.rotation)
        }
        ,
        i.LensFlare.prototype.copy = function(t) {
            i.Object3D.prototype.copy.call(this, t),
            this.positionScreen.copy(t.positionScreen),
            this.customUpdateCallback = t.customUpdateCallback;
            for (var e = 0, r = t.lensFlares.length; e < r; e++)
                this.lensFlares.push(t.lensFlares[e]);
            return this
        }
        ,
        i.Scene = function() {
            i.Object3D.call(this),
            this.type = "Scene",
            this.fog = null,
            this.overrideMaterial = null,
            this.autoUpdate = !0
        }
        ,
        i.Scene.prototype = Object.create(i.Object3D.prototype),
        i.Scene.prototype.constructor = i.Scene,
        i.Scene.prototype.copy = function(t) {
            return i.Object3D.prototype.copy.call(this, t),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            this.autoUpdate = t.autoUpdate,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this
        }
        ,
        i.Fog = function(t, e, r) {
            this.name = "",
            this.color = new i.Color(t),
            this.near = void 0 !== e ? e : 1,
            this.far = void 0 !== r ? r : 1e3
        }
        ,
        i.Fog.prototype.clone = function() {
            return new i.Fog(this.color.getHex(),this.near,this.far)
        }
        ,
        i.FogExp2 = function(t, e) {
            this.name = "",
            this.color = new i.Color(t),
            this.density = void 0 !== e ? e : 25e-5
        }
        ,
        i.FogExp2.prototype.clone = function() {
            return new i.FogExp2(this.color.getHex(),this.density)
        }
        ,
        i.ShaderChunk = {},
        i.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        i.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        i.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        i.ShaderChunk.ambient_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\treturn PI * ambientLightColor;\n}\n",
        i.ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\treflectedLight.indirectDiffuse *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n#endif\n",
        i.ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        i.ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n",
        i.ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n",
        i.ShaderChunk.bsdfs = "float calcLightAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif ( decayExponent > 0.0 ) {\n\t  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = alpha * alpha;\n\tfloat gl = dotNL + pow( a2 + ( 1.0 - a2 ) * dotNL * dotNL, 0.5 );\n\tfloat gv = dotNV + pow( a2 + ( 1.0 - a2 ) * dotNV * dotNV, 0.5 );\n\treturn 1.0 / ( gl * gv );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = alpha * alpha;\n\tfloat denom = dotNH * dotNH * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / ( denom * denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = roughness * roughness;\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_Smith( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / square( ggxRoughness + 0.0001 ) - 2.0 );\n}",
        i.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        i.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        i.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        i.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        i.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        i.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat square( const in float x ) { return x*x; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nvec3 inputToLinear( in vec3 a ) {\n\t#ifdef GAMMA_INPUT\n\t\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n",
        i.ShaderChunk.defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
        i.ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        i.ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        i.ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\ttotalEmissiveLight *= emissiveColor.rgb;\n#endif\n",
        i.ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        i.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\tenvColor.xyz = inputToLinear( envColor.xyz );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        i.ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( STANDARD )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        i.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n\tvarying vec3 vReflect;\n\tuniform float refractionRatio;\n#endif\n",
        i.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t#ifdef ENVMAP_MODE_REFLECTION\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t#else\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t#endif\n#endif\n",
        i.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\t\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\n#endif",
        i.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        i.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        i.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        i.ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tdirectLight = getPointDirectLight( pointLights[ i ], geometry );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tdirectLight = getSpotDirectLight( spotLights[ i ], geometry );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectLight = getDirectionalDirectLight( directionalLights[ i ], geometry );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        i.ShaderChunk.lights_pars = "#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tIncidentLight getDirectionalDirectLight( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\n\t\tIncidentLight directLight;\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\treturn directLight;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tIncidentLight getPointDirectLight( const in PointLight pointLight, const in GeometricContext geometry ) {\n\t\tIncidentLight directLight;\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= calcLightAttenuation( length( lVector ), pointLight.distance, pointLight.decay );\n\t\treturn directLight;\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat angleCos;\n\t\tfloat exponent;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tIncidentLight getSpotDirectLight( const in SpotLight spotLight, const in GeometricContext geometry ) {\n\t\tIncidentLight directLight;\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat spotEffect = dot( directLight.direction, spotLight.direction );\n\t\tif ( spotEffect > spotLight.angleCos ) {\n\t\t\tfloat spotEffect = dot( spotLight.direction, directLight.direction );\n\t\t\tspotEffect = saturate( pow( saturate( spotEffect ), spotLight.exponent ) );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= ( spotEffect * calcLightAttenuation( length( lVector ), spotLight.distance, spotLight.decay ) );\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t}\n\t\treturn directLight;\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\treturn PI * mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( STANDARD )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t#else\n\t\t\tvec3 envMapColor = vec3( 0.0 );\n\t\t#endif\n\t\tenvMapColor.rgb = inputToLinear( envMapColor.rgb );\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( square( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t#endif\n\t\tenvMapColor.rgb = inputToLinear( envMapColor.rgb );\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        i.ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        i.ShaderChunk.lights_phong_pars_fragment = "#ifdef USE_ENVMAP\n\tvarying vec3 vWorldPosition;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * PI * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        i.ShaderChunk.lights_phong_pars_vertex = "#ifdef USE_ENVMAP\n\tvarying vec3 vWorldPosition;\n#endif\n",
        i.ShaderChunk.lights_phong_vertex = "#ifdef USE_ENVMAP\n\tvWorldPosition = worldPosition.xyz;\n#endif\n",
        i.ShaderChunk.lights_standard_fragment = "StandardMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n",
        i.ShaderChunk.lights_standard_pars_fragment = "struct StandardMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n};\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * PI * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Standard\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Standard\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Standard\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n",
        i.ShaderChunk.lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tdirectLight = getPointDirectLight( pointLight, geometry );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tdirectLight = getSpotDirectLight( spotLight, geometry );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tdirectLight = getDirectionalDirectLight( directionalLight, geometry );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tirradiance += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n",
        i.ShaderChunk.linear_to_gamma_fragment = "\n\toutgoingLight = linearToOutput( outgoingLight );\n",
        i.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
        i.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
        i.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
        i.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
        i.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\n\tdiffuseColor *= texelColor;\n#endif\n",
        i.ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        i.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n#endif\n",
        i.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
        i.ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n",
        i.ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        i.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        i.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        i.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        i.ShaderChunk.normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        i.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
        i.ShaderChunk.project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
        i.ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n",
        i.ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        i.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\treturn dot( rgba_depth, bit_shift );\n\t}\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec3 offset = vec3( - 1, 0, 1 ) * shadowRadius * 2.0 * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzz, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxz, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxz, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzz, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyz, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyz, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzz, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxz, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 21.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        i.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        i.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        i.ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        i.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        i.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        i.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n",
        i.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        i.ShaderChunk.specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        i.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        i.ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        i.ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        i.ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        i.ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
        i.ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";
        i.ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
        i.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n",
        i.UniformsUtils = {
            merge: function(t) {
                for (var e = {}, r = 0; r < t.length; r++) {
                    var i = this.clone(t[r]);
                    for (var n in i)
                        e[n] = i[n]
                }
                return e
            },
            clone: function(t) {
                var e = {};
                for (var r in t) {
                    e[r] = {};
                    for (var n in t[r]) {
                        var o = t[r][n];
                        o instanceof i.Color || o instanceof i.Vector2 || o instanceof i.Vector3 || o instanceof i.Vector4 || o instanceof i.Matrix3 || o instanceof i.Matrix4 || o instanceof i.Texture ? e[r][n] = o.clone() : Array.isArray(o) ? e[r][n] = o.slice() : e[r][n] = o;
                    }
                }
                return e
            }
        },
        i.UniformsLib = {
            common: {
                diffuse: {
                    type: "c",
                    value: new i.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new i.Vector4(0,0,1,1)
                },
                specularMap: {
                    type: "t",
                    value: null
                },
                alphaMap: {
                    type: "t",
                    value: null
                },
                envMap: {
                    type: "t",
                    value: null
                },
                flipEnvMap: {
                    type: "f",
                    value: -1
                },
                reflectivity: {
                    type: "f",
                    value: 1
                },
                refractionRatio: {
                    type: "f",
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    type: "t",
                    value: null
                },
                aoMapIntensity: {
                    type: "f",
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    type: "t",
                    value: null
                },
                lightMapIntensity: {
                    type: "f",
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    type: "t",
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    type: "t",
                    value: null
                },
                bumpScale: {
                    type: "f",
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    type: "t",
                    value: null
                },
                normalScale: {
                    type: "v2",
                    value: new i.Vector2(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    type: "t",
                    value: null
                },
                displacementScale: {
                    type: "f",
                    value: 1
                },
                displacementBias: {
                    type: "f",
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    type: "t",
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    type: "t",
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    type: "f",
                    value: 25e-5
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new i.Color(16777215)
                }
            },
            ambient: {
                ambientLightColor: {
                    type: "fv",
                    value: []
                }
            },
            lights: {
                directionalLights: {
                    type: "sa",
                    value: [],
                    properties: {
                        direction: {
                            type: "v3"
                        },
                        color: {
                            type: "c"
                        },
                        shadow: {
                            type: "i"
                        },
                        shadowBias: {
                            type: "f"
                        },
                        shadowRadius: {
                            type: "f"
                        },
                        shadowMapSize: {
                            type: "v2"
                        }
                    }
                },
                directionalShadowMap: {
                    type: "tv",
                    value: []
                },
                directionalShadowMatrix: {
                    type: "m4v",
                    value: []
                },
                spotLights: {
                    type: "sa",
                    value: [],
                    properties: {
                        color: {
                            type: "c"
                        },
                        position: {
                            type: "v3"
                        },
                        direction: {
                            type: "v3"
                        },
                        distance: {
                            type: "f"
                        },
                        angleCos: {
                            type: "f"
                        },
                        exponent: {
                            type: "f"
                        },
                        decay: {
                            type: "f"
                        },
                        shadow: {
                            type: "i"
                        },
                        shadowBias: {
                            type: "f"
                        },
                        shadowRadius: {
                            type: "f"
                        },
                        shadowMapSize: {
                            type: "v2"
                        }
                    }
                },
                spotShadowMap: {
                    type: "tv",
                    value: []
                },
                spotShadowMatrix: {
                    type: "m4v",
                    value: []
                },
                pointLights: {
                    type: "sa",
                    value: [],
                    properties: {
                        color: {
                            type: "c"
                        },
                        position: {
                            type: "v3"
                        },
                        decay: {
                            type: "f"
                        },
                        distance: {
                            type: "f"
                        },
                        shadow: {
                            type: "i"
                        },
                        shadowBias: {
                            type: "f"
                        },
                        shadowRadius: {
                            type: "f"
                        },
                        shadowMapSize: {
                            type: "v2"
                        }
                    }
                },
                pointShadowMap: {
                    type: "tv",
                    value: []
                },
                pointShadowMatrix: {
                    type: "m4v",
                    value: []
                },
                hemisphereLights: {
                    type: "sa",
                    value: [],
                    properties: {
                        direction: {
                            type: "v3"
                        },
                        skyColor: {
                            type: "c"
                        },
                        groundColor: {
                            type: "c"
                        }
                    }
                }
            },
            points: {
                diffuse: {
                    type: "c",
                    value: new i.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                size: {
                    type: "f",
                    value: 1
                },
                scale: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new i.Vector4(0,0,1,1)
                }
            }
        },
        i.ShaderLib = {
            basic: {
                uniforms: i.UniformsUtils.merge([i.UniformsLib.common, i.UniformsLib.aomap, i.UniformsLib.fog]),
                vertexShader: [i.ShaderChunk.common, i.ShaderChunk.uv_pars_vertex, i.ShaderChunk.uv2_pars_vertex, i.ShaderChunk.envmap_pars_vertex, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, i.ShaderChunk.shadowmap_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.uv_vertex, i.ShaderChunk.uv2_vertex, i.ShaderChunk.color_vertex, i.ShaderChunk.skinbase_vertex, "\t#ifdef USE_ENVMAP", i.ShaderChunk.beginnormal_vertex, i.ShaderChunk.morphnormal_vertex, i.ShaderChunk.skinnormal_vertex, i.ShaderChunk.defaultnormal_vertex, "\t#endif", i.ShaderChunk.begin_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.project_vertex, i.ShaderChunk.logdepthbuf_vertex, i.ShaderChunk.worldpos_vertex, i.ShaderChunk.envmap_vertex, i.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "#ifndef FLAT_SHADED", "\tvarying vec3 vNormal;", "#endif", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.uv_pars_fragment, i.ShaderChunk.uv2_pars_fragment, i.ShaderChunk.map_pars_fragment, i.ShaderChunk.alphamap_pars_fragment, i.ShaderChunk.aomap_pars_fragment, i.ShaderChunk.envmap_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.shadowmap_pars_fragment, i.ShaderChunk.specularmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tvec4 diffuseColor = vec4( diffuse, opacity );", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.map_fragment, i.ShaderChunk.color_fragment, i.ShaderChunk.alphamap_fragment, i.ShaderChunk.alphatest_fragment, i.ShaderChunk.specularmap_fragment, "\tReflectedLight reflectedLight;", "\treflectedLight.directDiffuse = vec3( 0.0 );", "\treflectedLight.directSpecular = vec3( 0.0 );", "\treflectedLight.indirectDiffuse = diffuseColor.rgb;", "\treflectedLight.indirectSpecular = vec3( 0.0 );", i.ShaderChunk.aomap_fragment, "\tvec3 outgoingLight = reflectedLight.indirectDiffuse;", i.ShaderChunk.envmap_fragment, i.ShaderChunk.linear_to_gamma_fragment, i.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
            },
            lambert: {
                uniforms: i.UniformsUtils.merge([i.UniformsLib.common, i.UniformsLib.aomap, i.UniformsLib.lightmap, i.UniformsLib.emissivemap, i.UniformsLib.fog, i.UniformsLib.ambient, i.UniformsLib.lights, {
                    emissive: {
                        type: "c",
                        value: new i.Color(0)
                    }
                }]),
                vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "\tvarying vec3 vLightBack;", "#endif", i.ShaderChunk.common, i.ShaderChunk.uv_pars_vertex, i.ShaderChunk.uv2_pars_vertex, i.ShaderChunk.envmap_pars_vertex, i.ShaderChunk.bsdfs, i.ShaderChunk.lights_pars, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, i.ShaderChunk.shadowmap_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.uv_vertex, i.ShaderChunk.uv2_vertex, i.ShaderChunk.color_vertex, i.ShaderChunk.beginnormal_vertex, i.ShaderChunk.morphnormal_vertex, i.ShaderChunk.skinbase_vertex, i.ShaderChunk.skinnormal_vertex, i.ShaderChunk.defaultnormal_vertex, i.ShaderChunk.begin_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.project_vertex, i.ShaderChunk.logdepthbuf_vertex, i.ShaderChunk.worldpos_vertex, i.ShaderChunk.envmap_vertex, i.ShaderChunk.lights_lambert_vertex, i.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "\tvarying vec3 vLightBack;", "#endif", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.uv_pars_fragment, i.ShaderChunk.uv2_pars_fragment, i.ShaderChunk.map_pars_fragment, i.ShaderChunk.alphamap_pars_fragment, i.ShaderChunk.aomap_pars_fragment, i.ShaderChunk.lightmap_pars_fragment, i.ShaderChunk.emissivemap_pars_fragment, i.ShaderChunk.envmap_pars_fragment, i.ShaderChunk.bsdfs, i.ShaderChunk.ambient_pars, i.ShaderChunk.lights_pars, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.shadowmap_pars_fragment, i.ShaderChunk.shadowmask_pars_fragment, i.ShaderChunk.specularmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tvec4 diffuseColor = vec4( diffuse, opacity );", "\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "\tvec3 totalEmissiveLight = emissive;", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.map_fragment, i.ShaderChunk.color_fragment, i.ShaderChunk.alphamap_fragment, i.ShaderChunk.alphatest_fragment, i.ShaderChunk.specularmap_fragment, i.ShaderChunk.emissivemap_fragment, "\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );", i.ShaderChunk.lightmap_fragment, "\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );", "\t#ifdef DOUBLE_SIDED", "\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;", "\t#else", "\t\treflectedLight.directDiffuse = vLightFront;", "\t#endif", "\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();", i.ShaderChunk.aomap_fragment, "\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveLight;", i.ShaderChunk.envmap_fragment, i.ShaderChunk.linear_to_gamma_fragment, i.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
            },
            phong: {
                uniforms: i.UniformsUtils.merge([i.UniformsLib.common, i.UniformsLib.aomap, i.UniformsLib.lightmap, i.UniformsLib.emissivemap, i.UniformsLib.bumpmap, i.UniformsLib.normalmap, i.UniformsLib.displacementmap, i.UniformsLib.fog, i.UniformsLib.ambient, i.UniformsLib.lights, {
                    emissive: {
                        type: "c",
                        value: new i.Color(0)
                    },
                    specular: {
                        type: "c",
                        value: new i.Color(1118481)
                    },
                    shininess: {
                        type: "f",
                        value: 30
                    }
                }]),
                vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "\tvarying vec3 vNormal;", "#endif", i.ShaderChunk.common, i.ShaderChunk.uv_pars_vertex, i.ShaderChunk.uv2_pars_vertex, i.ShaderChunk.displacementmap_pars_vertex, i.ShaderChunk.envmap_pars_vertex, i.ShaderChunk.lights_phong_pars_vertex, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, i.ShaderChunk.shadowmap_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.uv_vertex, i.ShaderChunk.uv2_vertex, i.ShaderChunk.color_vertex, i.ShaderChunk.beginnormal_vertex, i.ShaderChunk.morphnormal_vertex, i.ShaderChunk.skinbase_vertex, i.ShaderChunk.skinnormal_vertex, i.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED", "\tvNormal = normalize( transformedNormal );", "#endif", i.ShaderChunk.begin_vertex, i.ShaderChunk.displacementmap_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.project_vertex, i.ShaderChunk.logdepthbuf_vertex, "\tvViewPosition = - mvPosition.xyz;", i.ShaderChunk.worldpos_vertex, i.ShaderChunk.envmap_vertex, i.ShaderChunk.lights_phong_vertex, i.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.uv_pars_fragment, i.ShaderChunk.uv2_pars_fragment, i.ShaderChunk.map_pars_fragment, i.ShaderChunk.alphamap_pars_fragment, i.ShaderChunk.aomap_pars_fragment, i.ShaderChunk.lightmap_pars_fragment, i.ShaderChunk.emissivemap_pars_fragment, i.ShaderChunk.envmap_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.bsdfs, i.ShaderChunk.ambient_pars, i.ShaderChunk.lights_pars, i.ShaderChunk.lights_phong_pars_fragment, i.ShaderChunk.shadowmap_pars_fragment, i.ShaderChunk.bumpmap_pars_fragment, i.ShaderChunk.normalmap_pars_fragment, i.ShaderChunk.specularmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tvec4 diffuseColor = vec4( diffuse, opacity );", "\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "\tvec3 totalEmissiveLight = emissive;", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.map_fragment, i.ShaderChunk.color_fragment, i.ShaderChunk.alphamap_fragment, i.ShaderChunk.alphatest_fragment, i.ShaderChunk.specularmap_fragment, i.ShaderChunk.normal_fragment, i.ShaderChunk.emissivemap_fragment, i.ShaderChunk.lights_phong_fragment, i.ShaderChunk.lights_template, i.ShaderChunk.aomap_fragment, "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;", i.ShaderChunk.envmap_fragment, i.ShaderChunk.linear_to_gamma_fragment, i.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
            },
            standard: {
                uniforms: i.UniformsUtils.merge([i.UniformsLib.common, i.UniformsLib.aomap, i.UniformsLib.lightmap, i.UniformsLib.emissivemap, i.UniformsLib.bumpmap, i.UniformsLib.normalmap, i.UniformsLib.displacementmap, i.UniformsLib.roughnessmap, i.UniformsLib.metalnessmap, i.UniformsLib.fog, i.UniformsLib.ambient, i.UniformsLib.lights, {
                    emissive: {
                        type: "c",
                        value: new i.Color(0)
                    },
                    roughness: {
                        type: "f",
                        value: .5
                    },
                    metalness: {
                        type: "f",
                        value: 0
                    },
                    envMapIntensity: {
                        type: "f",
                        value: 1
                    }
                }]),
                vertexShader: ["#define STANDARD", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "\tvarying vec3 vNormal;", "#endif", i.ShaderChunk.common, i.ShaderChunk.uv_pars_vertex, i.ShaderChunk.uv2_pars_vertex, i.ShaderChunk.displacementmap_pars_vertex, i.ShaderChunk.envmap_pars_vertex, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, i.ShaderChunk.shadowmap_pars_vertex, i.ShaderChunk.specularmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.uv_vertex, i.ShaderChunk.uv2_vertex, i.ShaderChunk.color_vertex, i.ShaderChunk.beginnormal_vertex, i.ShaderChunk.morphnormal_vertex, i.ShaderChunk.skinbase_vertex, i.ShaderChunk.skinnormal_vertex, i.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED", "\tvNormal = normalize( transformedNormal );", "#endif", i.ShaderChunk.begin_vertex, i.ShaderChunk.displacementmap_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.project_vertex, i.ShaderChunk.logdepthbuf_vertex, "\tvViewPosition = - mvPosition.xyz;", i.ShaderChunk.worldpos_vertex, i.ShaderChunk.envmap_vertex, i.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                fragmentShader: ["#define STANDARD", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float roughness;", "uniform float metalness;", "uniform float opacity;", "uniform float envMapIntensity;", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "\tvarying vec3 vNormal;", "#endif", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.uv_pars_fragment, i.ShaderChunk.uv2_pars_fragment, i.ShaderChunk.map_pars_fragment, i.ShaderChunk.alphamap_pars_fragment, i.ShaderChunk.aomap_pars_fragment, i.ShaderChunk.lightmap_pars_fragment, i.ShaderChunk.emissivemap_pars_fragment, i.ShaderChunk.envmap_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.bsdfs, i.ShaderChunk.ambient_pars, i.ShaderChunk.lights_pars, i.ShaderChunk.lights_standard_pars_fragment, i.ShaderChunk.shadowmap_pars_fragment, i.ShaderChunk.bumpmap_pars_fragment, i.ShaderChunk.normalmap_pars_fragment, i.ShaderChunk.roughnessmap_pars_fragment, i.ShaderChunk.metalnessmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tvec4 diffuseColor = vec4( diffuse, opacity );", "\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "\tvec3 totalEmissiveLight = emissive;", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.map_fragment, i.ShaderChunk.color_fragment, i.ShaderChunk.alphamap_fragment, i.ShaderChunk.alphatest_fragment, i.ShaderChunk.specularmap_fragment, i.ShaderChunk.roughnessmap_fragment, i.ShaderChunk.metalnessmap_fragment, i.ShaderChunk.normal_fragment, i.ShaderChunk.emissivemap_fragment, i.ShaderChunk.lights_standard_fragment, i.ShaderChunk.lights_template, i.ShaderChunk.aomap_fragment, "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;", i.ShaderChunk.linear_to_gamma_fragment, i.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
            },
            points: {
                uniforms: i.UniformsUtils.merge([i.UniformsLib.points, i.UniformsLib.fog]),
                vertexShader: ["uniform float size;", "uniform float scale;", i.ShaderChunk.common, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.shadowmap_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.color_vertex, i.ShaderChunk.begin_vertex, i.ShaderChunk.project_vertex, "\t#ifdef USE_SIZEATTENUATION", "\t\tgl_PointSize = size * ( scale / - mvPosition.z );", "\t#else", "\t\tgl_PointSize = size;", "\t#endif", i.ShaderChunk.logdepthbuf_vertex, i.ShaderChunk.worldpos_vertex, i.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.map_particle_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.shadowmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tvec3 outgoingLight = vec3( 0.0 );", "\tvec4 diffuseColor = vec4( diffuse, opacity );", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.map_particle_fragment, i.ShaderChunk.color_fragment, i.ShaderChunk.alphatest_fragment, "\toutgoingLight = diffuseColor.rgb;", i.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
            },
            dashed: {
                uniforms: i.UniformsUtils.merge([i.UniformsLib.common, i.UniformsLib.fog, {
                    scale: {
                        type: "f",
                        value: 1
                    },
                    dashSize: {
                        type: "f",
                        value: 1
                    },
                    totalSize: {
                        type: "f",
                        value: 2
                    }
                }]),
                vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", i.ShaderChunk.common, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.color_vertex, "\tvLineDistance = scale * lineDistance;", "\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "\tgl_Position = projectionMatrix * mvPosition;", i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tif ( mod( vLineDistance, totalSize ) > dashSize ) {", "\t\tdiscard;", "\t}", "\tvec3 outgoingLight = vec3( 0.0 );", "\tvec4 diffuseColor = vec4( diffuse, opacity );", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.color_fragment, "\toutgoingLight = diffuseColor.rgb;", i.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
            },
            depth: {
                uniforms: {
                    mNear: {
                        type: "f",
                        value: 1
                    },
                    mFar: {
                        type: "f",
                        value: 2e3
                    },
                    opacity: {
                        type: "f",
                        value: 1
                    }
                },
                vertexShader: [i.ShaderChunk.common, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.begin_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.project_vertex, i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", i.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT", "\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;", "\t#else", "\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;", "\t#endif", "\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );", "\tgl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
            },
            normal: {
                uniforms: {
                    opacity: {
                        type: "f",
                        value: 1
                    }
                },
                vertexShader: ["varying vec3 vNormal;", i.ShaderChunk.common, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "\tvNormal = normalize( normalMatrix * normal );", i.ShaderChunk.begin_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.project_vertex, i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", i.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
            },
            cube: {
                uniforms: {
                    tCube: {
                        type: "t",
                        value: null
                    },
                    tFlip: {
                        type: "f",
                        value: -1
                    }
                },
                vertexShader: ["varying vec3 vWorldPosition;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "\tvWorldPosition = transformDirection( position, modelMatrix );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", i.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        type: "t",
                        value: null
                    },
                    tFlip: {
                        type: "f",
                        value: -1
                    }
                },
                vertexShader: ["varying vec3 vWorldPosition;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "\tvWorldPosition = transformDirection( position, modelMatrix );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", i.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
            },
            depthRGBA: {
                uniforms: {},
                vertexShader: [i.ShaderChunk.common, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.skinbase_vertex, i.ShaderChunk.begin_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.project_vertex, i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: [i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {", "\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "\tres -= res.xxyz * bit_mask;", "\treturn res;", "}", "void main() {", i.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT", "\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "\t#else", "\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "\t#endif", "}"].join("\n")
            },
            distanceRGBA: {
                uniforms: {
                    lightPos: {
                        type: "v3",
                        value: new i.Vector3(0,0,0)
                    }
                },
                vertexShader: ["varying vec4 vWorldPosition;", i.ShaderChunk.common, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, "void main() {", i.ShaderChunk.skinbase_vertex, i.ShaderChunk.begin_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.project_vertex, i.ShaderChunk.worldpos_vertex, "vWorldPosition = worldPosition;", "}"].join("\n"),
                fragmentShader: ["uniform vec3 lightPos;", "varying vec4 vWorldPosition;", i.ShaderChunk.common, "vec4 pack1K ( float depth ) {", "\tdepth /= 1000.0;", "\tconst vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "\tconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "\tvec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "\tres -= res.xxyz * bitMsk;", "\treturn res; ", "}", "float unpack1K ( vec4 color ) {", "\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "\treturn dot( color, bitSh ) * 1000.0;", "}", "void main () {", "\tgl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );", "}"].join("\n")
            }
        },
        i.WebGLRenderer = function(t) {
            function e() {
                return null === yt ? Pt : 1
            }
            function r(t, e, r, i) {
                at === !0 && (t *= i,
                e *= i,
                r *= i),
                Wt.clearColor(t, e, r, i)
            }
            function n() {
                Wt.init(),
                Wt.scissor(Mt.copy(Ut).multiplyScalar(Pt)),
                Wt.viewport(Et.copy(Dt).multiplyScalar(Pt)),
                r(At.r, At.g, At.b, Lt)
            }
            function o() {
                vt = null,
                _t = null,
                wt = "",
                bt = -1,
                Wt.reset()
            }
            function a(t) {
                t.preventDefault(),
                o(),
                n(),
                Xt.clear()
            }
            function s(t) {
                var e = t.target;
                e.removeEventListener("dispose", s),
                l(e),
                kt.textures--
            }
            function h(t) {
                var e = t.target;
                e.removeEventListener("dispose", h),
                u(e),
                kt.textures--
            }
            function c(t) {
                var e = t.target;
                e.removeEventListener("dispose", c),
                p(e)
            }
            function l(t) {
                var e = Xt.get(t);
                if (t.image && e.__image__webglTextureCube)
                    Vt.deleteTexture(e.__image__webglTextureCube);
                else {
                    if (void 0 === e.__webglInit)
                        return;
                    Vt.deleteTexture(e.__webglTexture)
                }
                Xt.delete(t)
            }
            function u(t) {
                var e = Xt.get(t)
                  , r = Xt.get(t.texture);
                if (t && void 0 !== r.__webglTexture) {
                    if (Vt.deleteTexture(r.__webglTexture),
                    t instanceof i.WebGLRenderTargetCube)
                        for (var n = 0; n < 6; n++)
                            Vt.deleteFramebuffer(e.__webglFramebuffer[n]),
                            Vt.deleteRenderbuffer(e.__webglDepthbuffer[n]);
                    else
                        Vt.deleteFramebuffer(e.__webglFramebuffer),
                        Vt.deleteRenderbuffer(e.__webglDepthbuffer);
                    Xt.delete(t.texture),
                    Xt.delete(t)
                }
            }
            function p(t) {
                d(t),
                Xt.delete(t)
            }
            function d(t) {
                var e = Xt.get(t).program;
                t.program = void 0,
                void 0 !== e && qt.releaseProgram(e)
            }
            function f(t, e, r, n) {
                var o;
                if (r instanceof i.InstancedBufferGeometry && (o = jt.get("ANGLE_instanced_arrays"),
                null === o))
                    return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                void 0 === n && (n = 0),
                Wt.initAttributes();
                var a = r.attributes
                  , s = e.getAttributes()
                  , h = t.defaultAttributeValues;
                for (var c in s) {
                    var l = s[c];
                    if (l >= 0) {
                        var u = a[c];
                        if (void 0 !== u) {
                            var p = u.itemSize
                              , d = Yt.getAttributeBuffer(u);
                            if (u instanceof i.InterleavedBufferAttribute) {
                                var f = u.data
                                  , m = f.stride
                                  , g = u.offset;
                                f instanceof i.InstancedInterleavedBuffer ? (Wt.enableAttributeAndDivisor(l, f.meshPerAttribute, o),
                                void 0 === r.maxInstancedCount && (r.maxInstancedCount = f.meshPerAttribute * f.count)) : Wt.enableAttribute(l),
                                Vt.bindBuffer(Vt.ARRAY_BUFFER, d),
                                Vt.vertexAttribPointer(l, p, Vt.FLOAT, !1, m * f.array.BYTES_PER_ELEMENT, (n * m + g) * f.array.BYTES_PER_ELEMENT)
                            } else
                                u instanceof i.InstancedBufferAttribute ? (Wt.enableAttributeAndDivisor(l, u.meshPerAttribute, o),
                                void 0 === r.maxInstancedCount && (r.maxInstancedCount = u.meshPerAttribute * u.count)) : Wt.enableAttribute(l),
                                Vt.bindBuffer(Vt.ARRAY_BUFFER, d),
                                Vt.vertexAttribPointer(l, p, Vt.FLOAT, !1, 0, n * p * 4)
                        } else if (void 0 !== h) {
                            var v = h[c];
                            if (void 0 !== v)
                                switch (v.length) {
                                case 2:
                                    Vt.vertexAttrib2fv(l, v);
                                    break;
                                case 3:
                                    Vt.vertexAttrib3fv(l, v);
                                    break;
                                case 4:
                                    Vt.vertexAttrib4fv(l, v);
                                    break;
                                default:
                                    Vt.vertexAttrib1fv(l, v)
                                }
                        }
                    }
                }
                Wt.disableUnusedAttributes()
            }
            function m(t, e) {
                return Math.abs(e[0]) - Math.abs(t[0])
            }
            function g(t, e) {
                return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }
            function v(t, e) {
                return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }
            function y(t, e, r, i, n) {
                var o, a;
                r.transparent ? (o = ut,
                a = ++pt) : (o = ct,
                a = ++lt);
                var s = o[a];
                void 0 !== s ? (s.id = t.id,
                s.object = t,
                s.geometry = e,
                s.material = r,
                s.z = Bt.z,
                s.group = n) : (s = {
                    id: t.id,
                    object: t,
                    geometry: e,
                    material: r,
                    z: Bt.z,
                    group: n
                },
                o.push(s))
            }
            function x(t, e) {
                if (t.visible !== !1) {
                    if (t.layers.test(e.layers))
                        if (t instanceof i.Light)
                            ht.push(t);
                        else if (t instanceof i.Sprite)
                            t.frustumCulled !== !1 && Ot.intersectsObject(t) !== !0 || ft.push(t);
                        else if (t instanceof i.LensFlare)
                            mt.push(t);
                        else if (t instanceof i.ImmediateRenderObject)
                            gt.sortObjects === !0 && (Bt.setFromMatrixPosition(t.matrixWorld),
                            Bt.applyProjection(Nt)),
                            y(t, null, t.material, Bt.z, null);
                        else if ((t instanceof i.Mesh || t instanceof i.Line || t instanceof i.Points) && (t instanceof i.SkinnedMesh && t.skeleton.update(),
                        t.frustumCulled === !1 || Ot.intersectsObject(t) === !0)) {
                            var r = t.material;
                            if (r.visible === !0) {
                                gt.sortObjects === !0 && (Bt.setFromMatrixPosition(t.matrixWorld),
                                Bt.applyProjection(Nt));
                                var n = Yt.update(t);
                                if (r instanceof i.MultiMaterial)
                                    for (var o = n.groups, a = r.materials, s = 0, h = o.length; s < h; s++) {
                                        var c = o[s]
                                          , l = a[c.materialIndex];
                                        l.visible === !0 && y(t, n, l, Bt.z, c)
                                    }
                                else
                                    y(t, n, r, Bt.z, null)
                            }
                        }
                    for (var u = t.children, s = 0, h = u.length; s < h; s++)
                        x(u[s], e)
                }
            }
            function b(t, e, r, n) {
                for (var o = 0, a = t.length; o < a; o++) {
                    var s = t[o]
                      , h = s.object
                      , c = s.geometry
                      , l = void 0 === n ? s.material : n
                      , u = s.group;
                    if (h.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, h.matrixWorld),
                    h.normalMatrix.getNormalMatrix(h.modelViewMatrix),
                    h instanceof i.ImmediateRenderObject) {
                        _(l);
                        var p = S(e, r, l, h);
                        wt = "",
                        h.render(function(t) {
                            gt.renderBufferImmediate(t, p, l)
                        })
                    } else
                        gt.renderBufferDirect(e, r, c, l, h, u)
                }
            }
            function w(t, e, r) {
                var n = Xt.get(t)
                  , o = qt.getParameters(t, Ft, e, r)
                  , a = qt.getProgramCode(t, o)
                  , s = n.program
                  , h = !0;
                if (void 0 === s)
                    t.addEventListener("dispose", c);
                else if (s.code !== a)
                    d(t);
                else {
                    if (void 0 !== o.shaderID)
                        return;
                    h = !1
                }
                if (h) {
                    if (o.shaderID) {
                        var l = i.ShaderLib[o.shaderID];
                        n.__webglShader = {
                            name: t.type,
                            uniforms: i.UniformsUtils.clone(l.uniforms),
                            vertexShader: l.vertexShader,
                            fragmentShader: l.fragmentShader
                        }
                    } else
                        n.__webglShader = {
                            name: t.type,
                            uniforms: t.uniforms,
                            vertexShader: t.vertexShader,
                            fragmentShader: t.fragmentShader
                        };
                    t.__webglShader = n.__webglShader,
                    s = qt.acquireProgram(t, o, a),
                    n.program = s,
                    t.program = s
                }
                var u = s.getAttributes();
                if (t.morphTargets) {
                    t.numSupportedMorphTargets = 0;
                    for (var p = 0; p < gt.maxMorphTargets; p++)
                        u["morphTarget" + p] >= 0 && t.numSupportedMorphTargets++
                }
                if (t.morphNormals) {
                    t.numSupportedMorphNormals = 0;
                    for (var p = 0; p < gt.maxMorphNormals; p++)
                        u["morphNormal" + p] >= 0 && t.numSupportedMorphNormals++
                }
                n.uniformsList = [];
                var f = n.__webglShader.uniforms
                  , m = n.program.getUniforms();
                for (var g in f) {
                    var v = m[g];
                    v && n.uniformsList.push([n.__webglShader.uniforms[g], v])
                }
                (t instanceof i.MeshPhongMaterial || t instanceof i.MeshLambertMaterial || t instanceof i.MeshStandardMaterial || t.lights) && (n.lightsHash = Ft.hash,
                f.ambientLightColor.value = Ft.ambient,
                f.directionalLights.value = Ft.directional,
                f.spotLights.value = Ft.spot,
                f.pointLights.value = Ft.point,
                f.hemisphereLights.value = Ft.hemi,
                f.directionalShadowMap.value = Ft.directionalShadowMap,
                f.directionalShadowMatrix.value = Ft.directionalShadowMatrix,
                f.spotShadowMap.value = Ft.spotShadowMap,
                f.spotShadowMatrix.value = Ft.spotShadowMatrix,
                f.pointShadowMap.value = Ft.pointShadowMap,
                f.pointShadowMatrix.value = Ft.pointShadowMatrix),
                n.hasDynamicUniforms = !1;
                for (var y = 0, x = n.uniformsList.length; y < x; y++) {
                    var b = n.uniformsList[y][0];
                    if (b.dynamic === !0) {
                        n.hasDynamicUniforms = !0;
                        break
                    }
                }
            }
            function _(t) {
                M(t),
                t.transparent === !0 ? Wt.setBlending(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha) : Wt.setBlending(i.NoBlending),
                Wt.setDepthFunc(t.depthFunc),
                Wt.setDepthTest(t.depthTest),
                Wt.setDepthWrite(t.depthWrite),
                Wt.setColorWrite(t.colorWrite),
                Wt.setPolygonOffset(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            }
            function M(t) {
                t.side !== i.DoubleSide ? Wt.enable(Vt.CULL_FACE) : Wt.disable(Vt.CULL_FACE),
                Wt.setFlipSided(t.side === i.BackSide)
            }
            function S(t, e, r, n) {
                Tt = 0;
                var o = Xt.get(r);
                void 0 === o.program && (r.needsUpdate = !0),
                void 0 !== o.lightsHash && o.lightsHash !== Ft.hash && (r.needsUpdate = !0),
                r.needsUpdate && (w(r, e, n),
                r.needsUpdate = !1);
                var a = !1
                  , s = !1
                  , h = !1
                  , c = o.program
                  , l = c.getUniforms()
                  , u = o.__webglShader.uniforms;
                if (c.id !== vt && (Vt.useProgram(c.program),
                vt = c.id,
                a = !0,
                s = !0,
                h = !0),
                r.id !== bt && (bt = r.id,
                s = !0),
                (a || t !== _t) && (Vt.uniformMatrix4fv(l.projectionMatrix, !1, t.projectionMatrix.elements),
                Ht.logarithmicDepthBuffer && Vt.uniform1f(l.logDepthBufFC, 2 / (Math.log(t.far + 1) / Math.LN2)),
                t !== _t && (_t = t,
                s = !0,
                h = !0),
                (r instanceof i.ShaderMaterial || r instanceof i.MeshPhongMaterial || r instanceof i.MeshStandardMaterial || r.envMap) && void 0 !== l.cameraPosition && (Bt.setFromMatrixPosition(t.matrixWorld),
                Vt.uniform3f(l.cameraPosition, Bt.x, Bt.y, Bt.z)),
                (r instanceof i.MeshPhongMaterial || r instanceof i.MeshLambertMaterial || r instanceof i.MeshBasicMaterial || r instanceof i.MeshStandardMaterial || r instanceof i.ShaderMaterial || r.skinning) && void 0 !== l.viewMatrix && Vt.uniformMatrix4fv(l.viewMatrix, !1, t.matrixWorldInverse.elements)),
                r.skinning)
                    if (n.bindMatrix && void 0 !== l.bindMatrix && Vt.uniformMatrix4fv(l.bindMatrix, !1, n.bindMatrix.elements),
                    n.bindMatrixInverse && void 0 !== l.bindMatrixInverse && Vt.uniformMatrix4fv(l.bindMatrixInverse, !1, n.bindMatrixInverse.elements),
                    Ht.floatVertexTextures && n.skeleton && n.skeleton.useVertexTexture) {
                        if (void 0 !== l.boneTexture) {
                            var p = N();
                            Vt.uniform1i(l.boneTexture, p),
                            gt.setTexture(n.skeleton.boneTexture, p)
                        }
                        void 0 !== l.boneTextureWidth && Vt.uniform1i(l.boneTextureWidth, n.skeleton.boneTextureWidth),
                        void 0 !== l.boneTextureHeight && Vt.uniform1i(l.boneTextureHeight, n.skeleton.boneTextureHeight)
                    } else
                        n.skeleton && n.skeleton.boneMatrices && void 0 !== l.boneGlobalMatrices && Vt.uniformMatrix4fv(l.boneGlobalMatrices, !1, n.skeleton.boneMatrices);
                return s && ((r instanceof i.MeshPhongMaterial || r instanceof i.MeshLambertMaterial || r instanceof i.MeshStandardMaterial || r.lights) && D(u, h),
                e && r.fog && R(u, e),
                (r instanceof i.MeshBasicMaterial || r instanceof i.MeshLambertMaterial || r instanceof i.MeshPhongMaterial || r instanceof i.MeshStandardMaterial) && T(u, r),
                r instanceof i.LineBasicMaterial ? A(u, r) : r instanceof i.LineDashedMaterial ? (A(u, r),
                L(u, r)) : r instanceof i.PointsMaterial ? C(u, r) : r instanceof i.MeshLambertMaterial ? P(u, r) : r instanceof i.MeshPhongMaterial ? U(u, r) : r instanceof i.MeshStandardMaterial ? I(u, r) : r instanceof i.MeshDepthMaterial ? (u.mNear.value = t.near,
                u.mFar.value = t.far,
                u.opacity.value = r.opacity) : r instanceof i.MeshNormalMaterial && (u.opacity.value = r.opacity),
                B(o.uniformsList)),
                O(l, n),
                void 0 !== l.modelMatrix && Vt.uniformMatrix4fv(l.modelMatrix, !1, n.matrixWorld.elements),
                o.hasDynamicUniforms === !0 && E(o.uniformsList, n, t),
                c
            }
            function E(t, e, r) {
                for (var i = [], n = 0, o = t.length; n < o; n++) {
                    var a = t[n][0]
                      , s = a.onUpdateCallback;
                    void 0 !== s && (s.bind(a)(e, r),
                    i.push(t[n]))
                }
                B(i)
            }
            function T(t, e) {
                t.opacity.value = e.opacity,
                t.diffuse.value = e.color,
                e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
                t.map.value = e.map,
                t.specularMap.value = e.specularMap,
                t.alphaMap.value = e.alphaMap,
                e.aoMap && (t.aoMap.value = e.aoMap,
                t.aoMapIntensity.value = e.aoMapIntensity);
                var r;
                if (e.map ? r = e.map : e.specularMap ? r = e.specularMap : e.displacementMap ? r = e.displacementMap : e.normalMap ? r = e.normalMap : e.bumpMap ? r = e.bumpMap : e.roughnessMap ? r = e.roughnessMap : e.metalnessMap ? r = e.metalnessMap : e.alphaMap ? r = e.alphaMap : e.emissiveMap && (r = e.emissiveMap),
                void 0 !== r) {
                    r instanceof i.WebGLRenderTarget && (r = r.texture);
                    var n = r.offset
                      , o = r.repeat;
                    t.offsetRepeat.value.set(n.x, n.y, o.x, o.y)
                }
                t.envMap.value = e.envMap,
                t.flipEnvMap.value = e.envMap instanceof i.WebGLRenderTargetCube ? 1 : -1,
                t.reflectivity.value = e.reflectivity,
                t.refractionRatio.value = e.refractionRatio
            }
            function A(t, e) {
                t.diffuse.value = e.color,
                t.opacity.value = e.opacity
            }
            function L(t, e) {
                t.dashSize.value = e.dashSize,
                t.totalSize.value = e.dashSize + e.gapSize,
                t.scale.value = e.scale
            }
            function C(t, e) {
                if (t.diffuse.value = e.color,
                t.opacity.value = e.opacity,
                t.size.value = e.size * Pt,
                t.scale.value = tt.clientHeight / 2,
                t.map.value = e.map,
                null !== e.map) {
                    var r = e.map.offset
                      , i = e.map.repeat;
                    t.offsetRepeat.value.set(r.x, r.y, i.x, i.y)
                }
            }
            function R(t, e) {
                t.fogColor.value = e.color,
                e instanceof i.Fog ? (t.fogNear.value = e.near,
                t.fogFar.value = e.far) : e instanceof i.FogExp2 && (t.fogDensity.value = e.density)
            }
            function P(t, e) {
                e.lightMap && (t.lightMap.value = e.lightMap,
                t.lightMapIntensity.value = e.lightMapIntensity),
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }
            function U(t, e) {
                t.specular.value = e.specular,
                t.shininess.value = Math.max(e.shininess, 1e-4),
                e.lightMap && (t.lightMap.value = e.lightMap,
                t.lightMapIntensity.value = e.lightMapIntensity),
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                e.bumpMap && (t.bumpMap.value = e.bumpMap,
                t.bumpScale.value = e.bumpScale),
                e.normalMap && (t.normalMap.value = e.normalMap,
                t.normalScale.value.copy(e.normalScale)),
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                t.displacementScale.value = e.displacementScale,
                t.displacementBias.value = e.displacementBias)
            }
            function I(t, e) {
                t.roughness.value = e.roughness,
                t.metalness.value = e.metalness,
                e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
                e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
                e.lightMap && (t.lightMap.value = e.lightMap,
                t.lightMapIntensity.value = e.lightMapIntensity),
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                e.bumpMap && (t.bumpMap.value = e.bumpMap,
                t.bumpScale.value = e.bumpScale),
                e.normalMap && (t.normalMap.value = e.normalMap,
                t.normalScale.value.copy(e.normalScale)),
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                t.displacementScale.value = e.displacementScale,
                t.displacementBias.value = e.displacementBias),
                e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }
            function D(t, e) {
                t.ambientLightColor.needsUpdate = e,
                t.directionalLights.needsUpdate = e,
                t.pointLights.needsUpdate = e,
                t.spotLights.needsUpdate = e,
                t.hemisphereLights.needsUpdate = e
            }
            function O(t, e) {
                Vt.uniformMatrix4fv(t.modelViewMatrix, !1, e.modelViewMatrix.elements),
                t.normalMatrix && Vt.uniformMatrix3fv(t.normalMatrix, !1, e.normalMatrix.elements)
            }
            function N() {
                var t = Tt;
                return t >= Ht.maxTextures && console.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + Ht.maxTextures),
                Tt += 1,
                t
            }
            function B(t) {
                for (var e, r, n = 0, o = t.length; n < o; n++) {
                    var a = t[n][0];
                    if (a.needsUpdate !== !1) {
                        var s = a.type
                          , h = a.value
                          , c = t[n][1];
                        switch (s) {
                        case "1i":
                            Vt.uniform1i(c, h);
                            break;
                        case "1f":
                            Vt.uniform1f(c, h);
                            break;
                        case "2f":
                            Vt.uniform2f(c, h[0], h[1]);
                            break;
                        case "3f":
                            Vt.uniform3f(c, h[0], h[1], h[2]);
                            break;
                        case "4f":
                            Vt.uniform4f(c, h[0], h[1], h[2], h[3]);
                            break;
                        case "1iv":
                            Vt.uniform1iv(c, h);
                            break;
                        case "3iv":
                            Vt.uniform3iv(c, h);
                            break;
                        case "1fv":
                            Vt.uniform1fv(c, h);
                            break;
                        case "2fv":
                            Vt.uniform2fv(c, h);
                            break;
                        case "3fv":
                            Vt.uniform3fv(c, h);
                            break;
                        case "4fv":
                            Vt.uniform4fv(c, h);
                            break;
                        case "Matrix2fv":
                            Vt.uniformMatrix2fv(c, !1, h);
                            break;
                        case "Matrix3fv":
                            Vt.uniformMatrix3fv(c, !1, h);
                            break;
                        case "Matrix4fv":
                            Vt.uniformMatrix4fv(c, !1, h);
                            break;
                        case "i":
                            Vt.uniform1i(c, h);
                            break;
                        case "f":
                            Vt.uniform1f(c, h);
                            break;
                        case "v2":
                            Vt.uniform2f(c, h.x, h.y);
                            break;
                        case "v3":
                            Vt.uniform3f(c, h.x, h.y, h.z);
                            break;
                        case "v4":
                            Vt.uniform4f(c, h.x, h.y, h.z, h.w);
                            break;
                        case "c":
                            Vt.uniform3f(c, h.r, h.g, h.b);
                            break;
                        case "sa":
                            for (var l = 0; l < h.length; l++)
                                for (var u in a.properties) {
                                    var p = a.properties[u]
                                      , d = c[l][u]
                                      , f = h[l][u];
                                    switch (p.type) {
                                    case "i":
                                        Vt.uniform1i(d, f);
                                        break;
                                    case "f":
                                        Vt.uniform1f(d, f);
                                        break;
                                    case "v2":
                                        Vt.uniform2f(d, f.x, f.y);
                                        break;
                                    case "v3":
                                        Vt.uniform3f(d, f.x, f.y, f.z);
                                        break;
                                    case "v4":
                                        Vt.uniform4f(d, f.x, f.y, f.z, f.w);
                                        break;
                                    case "c":
                                        Vt.uniform3f(d, f.r, f.g, f.b);
                                        break;
                                    case "m4":
                                        Vt.uniformMatrix4fv(d, !1, f.elements)
                                    }
                                }
                            break;
                        case "iv1":
                            Vt.uniform1iv(c, h);
                            break;
                        case "iv":
                            Vt.uniform3iv(c, h);
                            break;
                        case "fv1":
                            Vt.uniform1fv(c, h);
                            break;
                        case "fv":
                            Vt.uniform3fv(c, h);
                            break;
                        case "v2v":
                            void 0 === a._array && (a._array = new Float32Array(2 * h.length));
                            for (var l = 0, m = 0, g = h.length; l < g; l++,
                            m += 2)
                                a._array[m + 0] = h[l].x,
                                a._array[m + 1] = h[l].y;
                            Vt.uniform2fv(c, a._array);
                            break;
                        case "v3v":
                            void 0 === a._array && (a._array = new Float32Array(3 * h.length));
                            for (var l = 0, v = 0, g = h.length; l < g; l++,
                            v += 3)
                                a._array[v + 0] = h[l].x,
                                a._array[v + 1] = h[l].y,
                                a._array[v + 2] = h[l].z;
                            Vt.uniform3fv(c, a._array);
                            break;
                        case "v4v":
                            void 0 === a._array && (a._array = new Float32Array(4 * h.length));
                            for (var l = 0, y = 0, g = h.length; l < g; l++,
                            y += 4)
                                a._array[y + 0] = h[l].x,
                                a._array[y + 1] = h[l].y,
                                a._array[y + 2] = h[l].z,
                                a._array[y + 3] = h[l].w;
                            Vt.uniform4fv(c, a._array);
                            break;
                        case "m2":
                            Vt.uniformMatrix2fv(c, !1, h.elements);
                            break;
                        case "m3":
                            Vt.uniformMatrix3fv(c, !1, h.elements);
                            break;
                        case "m3v":
                            void 0 === a._array && (a._array = new Float32Array(9 * h.length));
                            for (var l = 0, g = h.length; l < g; l++)
                                h[l].flattenToArrayOffset(a._array, 9 * l);
                            Vt.uniformMatrix3fv(c, !1, a._array);
                            break;
                        case "m4":
                            Vt.uniformMatrix4fv(c, !1, h.elements);
                            break;
                        case "m4v":
                            void 0 === a._array && (a._array = new Float32Array(16 * h.length));
                            for (var l = 0, g = h.length; l < g; l++)
                                h[l].flattenToArrayOffset(a._array, 16 * l);
                            Vt.uniformMatrix4fv(c, !1, a._array);
                            break;
                        case "t":
                            if (e = h,
                            r = N(),
                            Vt.uniform1i(c, r),
                            !e)
                                continue;
                            e instanceof i.CubeTexture || Array.isArray(e.image) && 6 === e.image.length ? W(e, r) : e instanceof i.WebGLRenderTargetCube ? X(e.texture, r) : e instanceof i.WebGLRenderTarget ? gt.setTexture(e.texture, r) : gt.setTexture(e, r);
                            break;
                        case "tv":
                            void 0 === a._array && (a._array = []);
                            for (var l = 0, g = a.value.length; l < g; l++)
                                a._array[l] = N();
                            Vt.uniform1iv(c, a._array);
                            for (var l = 0, g = a.value.length; l < g; l++)
                                e = a.value[l],
                                r = a._array[l],
                                e && (e instanceof i.CubeTexture || e.image instanceof Array && 6 === e.image.length ? W(e, r) : e instanceof i.WebGLRenderTarget ? gt.setTexture(e.texture, r) : e instanceof i.WebGLRenderTargetCube ? X(e.texture, r) : gt.setTexture(e, r));
                            break;
                        default:
                            console.warn("THREE.WebGLRenderer: Unknown uniform type: " + s)
                        }
                    }
                }
            }
            function F(t, e) {
                var r, n, o, a, s, h, c = 0, l = 0, u = 0, p = e.matrixWorldInverse, d = 0, f = 0, m = 0, g = 0, v = 0;
                for (Ft.shadowsPointLight = 0,
                r = 0,
                n = t.length; r < n; r++)
                    if (o = t[r],
                    a = o.color,
                    s = o.intensity,
                    h = o.distance,
                    o instanceof i.AmbientLight)
                        c += a.r * s,
                        l += a.g * s,
                        u += a.b * s;
                    else if (o instanceof i.DirectionalLight) {
                        var y = Zt.get(o);
                        y.color.copy(o.color).multiplyScalar(o.intensity),
                        y.direction.setFromMatrixPosition(o.matrixWorld),
                        Bt.setFromMatrixPosition(o.target.matrixWorld),
                        y.direction.sub(Bt),
                        y.direction.transformDirection(p),
                        y.shadow = o.castShadow,
                        o.castShadow && (y.shadowBias = o.shadow.bias,
                        y.shadowRadius = o.shadow.radius,
                        y.shadowMapSize = o.shadow.mapSize,
                        Ft.shadows[v++] = o),
                        Ft.directionalShadowMap[d] = o.shadow.map,
                        Ft.directionalShadowMatrix[d] = o.shadow.matrix,
                        Ft.directional[d++] = y
                    } else if (o instanceof i.SpotLight) {
                        var y = Zt.get(o);
                        y.position.setFromMatrixPosition(o.matrixWorld),
                        y.position.applyMatrix4(p),
                        y.color.copy(a).multiplyScalar(s),
                        y.distance = h,
                        y.direction.setFromMatrixPosition(o.matrixWorld),
                        Bt.setFromMatrixPosition(o.target.matrixWorld),
                        y.direction.sub(Bt),
                        y.direction.transformDirection(p),
                        y.angleCos = Math.cos(o.angle),
                        y.exponent = o.exponent,
                        y.decay = 0 === o.distance ? 0 : o.decay,
                        y.shadow = o.castShadow,
                        o.castShadow && (y.shadowBias = o.shadow.bias,
                        y.shadowRadius = o.shadow.radius,
                        y.shadowMapSize = o.shadow.mapSize,
                        Ft.shadows[v++] = o),
                        Ft.spotShadowMap[m] = o.shadow.map,
                        Ft.spotShadowMatrix[m] = o.shadow.matrix,
                        Ft.spot[m++] = y
                    } else if (o instanceof i.PointLight) {
                        var y = Zt.get(o);
                        y.position.setFromMatrixPosition(o.matrixWorld),
                        y.position.applyMatrix4(p),
                        y.color.copy(o.color).multiplyScalar(o.intensity),
                        y.distance = o.distance,
                        y.decay = 0 === o.distance ? 0 : o.decay,
                        y.shadow = o.castShadow,
                        o.castShadow && (y.shadowBias = o.shadow.bias,
                        y.shadowRadius = o.shadow.radius,
                        y.shadowMapSize = o.shadow.mapSize,
                        Ft.shadows[v++] = o),
                        Ft.pointShadowMap[f] = o.shadow.map,
                        void 0 === Ft.pointShadowMatrix[f] && (Ft.pointShadowMatrix[f] = new i.Matrix4),
                        Bt.setFromMatrixPosition(o.matrixWorld).negate(),
                        Ft.pointShadowMatrix[f].identity().setPosition(Bt),
                        Ft.point[f++] = y
                    } else if (o instanceof i.HemisphereLight) {
                        var y = Zt.get(o);
                        y.direction.setFromMatrixPosition(o.matrixWorld),
                        y.direction.transformDirection(p),
                        y.direction.normalize(),
                        y.skyColor.copy(o.color).multiplyScalar(s),
                        y.groundColor.copy(o.groundColor).multiplyScalar(s),
                        Ft.hemi[g++] = y
                    }
                Ft.ambient[0] = c,
                Ft.ambient[1] = l,
                Ft.ambient[2] = u,
                Ft.directional.length = d,
                Ft.spot.length = m,
                Ft.point.length = f,
                Ft.hemi.length = g,
                Ft.shadows.length = v,
                Ft.hash = d + "," + f + "," + m + "," + g + "," + v
            }
            function k(t, e, r) {
                var n;
                if (r ? (Vt.texParameteri(t, Vt.TEXTURE_WRAP_S, $(e.wrapS)),
                Vt.texParameteri(t, Vt.TEXTURE_WRAP_T, $(e.wrapT)),
                Vt.texParameteri(t, Vt.TEXTURE_MAG_FILTER, $(e.magFilter)),
                Vt.texParameteri(t, Vt.TEXTURE_MIN_FILTER, $(e.minFilter))) : (Vt.texParameteri(t, Vt.TEXTURE_WRAP_S, Vt.CLAMP_TO_EDGE),
                Vt.texParameteri(t, Vt.TEXTURE_WRAP_T, Vt.CLAMP_TO_EDGE),
                e.wrapS === i.ClampToEdgeWrapping && e.wrapT === i.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", e),
                Vt.texParameteri(t, Vt.TEXTURE_MAG_FILTER, K(e.magFilter)),
                Vt.texParameteri(t, Vt.TEXTURE_MIN_FILTER, K(e.minFilter)),
                e.minFilter !== i.NearestFilter && e.minFilter !== i.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", e)),
                n = jt.get("EXT_texture_filter_anisotropic")) {
                    if (e.type === i.FloatType && null === jt.get("OES_texture_float_linear"))
                        return;
                    if (e.type === i.HalfFloatType && null === jt.get("OES_texture_half_float_linear"))
                        return;
                    (e.anisotropy > 1 || Xt.get(e).__currentAnisotropy) && (Vt.texParameterf(t, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, gt.getMaxAnisotropy())),
                    Xt.get(e).__currentAnisotropy = e.anisotropy)
                }
            }
            function z(t, e, r) {
                void 0 === t.__webglInit && (t.__webglInit = !0,
                e.addEventListener("dispose", s),
                t.__webglTexture = Vt.createTexture(),
                kt.textures++),
                Wt.activeTexture(Vt.TEXTURE0 + r),
                Wt.bindTexture(Vt.TEXTURE_2D, t.__webglTexture),
                Vt.pixelStorei(Vt.UNPACK_FLIP_Y_WEBGL, e.flipY),
                Vt.pixelStorei(Vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha),
                Vt.pixelStorei(Vt.UNPACK_ALIGNMENT, e.unpackAlignment);
                var n = V(e.image, Ht.maxTextureSize);
                j(e) && G(n) === !1 && (n = H(n));
                var o = G(n)
                  , a = $(e.format)
                  , h = $(e.type);
                k(Vt.TEXTURE_2D, e, o);
                var c, l = e.mipmaps;
                if (e instanceof i.DataTexture)
                    if (l.length > 0 && o) {
                        for (var u = 0, p = l.length; u < p; u++)
                            c = l[u],
                            Wt.texImage2D(Vt.TEXTURE_2D, u, a, c.width, c.height, 0, a, h, c.data);
                        e.generateMipmaps = !1
                    } else
                        Wt.texImage2D(Vt.TEXTURE_2D, 0, a, n.width, n.height, 0, a, h, n.data);
                else if (e instanceof i.CompressedTexture)
                    for (var u = 0, p = l.length; u < p; u++)
                        c = l[u],
                        e.format !== i.RGBAFormat && e.format !== i.RGBFormat ? Wt.getCompressedTextureFormats().indexOf(a) > -1 ? Wt.compressedTexImage2D(Vt.TEXTURE_2D, u, a, c.width, c.height, 0, c.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Wt.texImage2D(Vt.TEXTURE_2D, u, a, c.width, c.height, 0, a, h, c.data);
                else if (l.length > 0 && o) {
                    for (var u = 0, p = l.length; u < p; u++)
                        c = l[u],
                        Wt.texImage2D(Vt.TEXTURE_2D, u, a, a, h, c);
                    e.generateMipmaps = !1
                } else
                    Wt.texImage2D(Vt.TEXTURE_2D, 0, a, a, h, n);
                e.generateMipmaps && o && Vt.generateMipmap(Vt.TEXTURE_2D),
                t.__version = e.version,
                e.onUpdate && e.onUpdate(e)
            }
            function V(t, e) {
                if (t.width > e || t.height > e) {
                    var r = e / Math.max(t.width, t.height)
                      , i = document.createElement("canvas");
                    i.width = Math.floor(t.width * r),
                    i.height = Math.floor(t.height * r);
                    var n = i.getContext("2d");
                    return n.drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height),
                    console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height, t),
                    i
                }
                return t
            }
            function G(t) {
                return i.Math.isPowerOfTwo(t.width) && i.Math.isPowerOfTwo(t.height)
            }
            function j(t) {
                return t.wrapS !== i.ClampToEdgeWrapping || t.wrapT !== i.ClampToEdgeWrapping || t.minFilter !== i.NearestFilter && t.minFilter !== i.LinearFilter
            }
            function H(t) {
                if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) {
                    var e = document.createElement("canvas");
                    e.width = i.Math.nearestPowerOfTwo(t.width),
                    e.height = i.Math.nearestPowerOfTwo(t.height);
                    var r = e.getContext("2d");
                    return r.drawImage(t, 0, 0, e.width, e.height),
                    console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + e.width + "x" + e.height, t),
                    e
                }
                return t
            }
            function W(t, e) {
                var r = Xt.get(t);
                if (6 === t.image.length)
                    if (t.version > 0 && r.__version !== t.version) {
                        r.__image__webglTextureCube || (t.addEventListener("dispose", s),
                        r.__image__webglTextureCube = Vt.createTexture(),
                        kt.textures++),
                        Wt.activeTexture(Vt.TEXTURE0 + e),
                        Wt.bindTexture(Vt.TEXTURE_CUBE_MAP, r.__image__webglTextureCube),
                        Vt.pixelStorei(Vt.UNPACK_FLIP_Y_WEBGL, t.flipY);
                        for (var n = t instanceof i.CompressedTexture, o = t.image[0]instanceof i.DataTexture, a = [], h = 0; h < 6; h++)
                            !gt.autoScaleCubemaps || n || o ? a[h] = o ? t.image[h].image : t.image[h] : a[h] = V(t.image[h], Ht.maxCubemapSize);
                        var c = a[0]
                          , l = G(c)
                          , u = $(t.format)
                          , p = $(t.type);
                        k(Vt.TEXTURE_CUBE_MAP, t, l);
                        for (var h = 0; h < 6; h++)
                            if (n)
                                for (var d, f = a[h].mipmaps, m = 0, g = f.length; m < g; m++)
                                    d = f[m],
                                    t.format !== i.RGBAFormat && t.format !== i.RGBFormat ? Wt.getCompressedTextureFormats().indexOf(u) > -1 ? Wt.compressedTexImage2D(Vt.TEXTURE_CUBE_MAP_POSITIVE_X + h, m, u, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : Wt.texImage2D(Vt.TEXTURE_CUBE_MAP_POSITIVE_X + h, m, u, d.width, d.height, 0, u, p, d.data);
                            else
                                o ? Wt.texImage2D(Vt.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, u, a[h].width, a[h].height, 0, u, p, a[h].data) : Wt.texImage2D(Vt.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, u, u, p, a[h]);
                        t.generateMipmaps && l && Vt.generateMipmap(Vt.TEXTURE_CUBE_MAP),
                        r.__version = t.version,
                        t.onUpdate && t.onUpdate(t)
                    } else
                        Wt.activeTexture(Vt.TEXTURE0 + e),
                        Wt.bindTexture(Vt.TEXTURE_CUBE_MAP, r.__image__webglTextureCube)
            }
            function X(t, e) {
                Wt.activeTexture(Vt.TEXTURE0 + e),
                Wt.bindTexture(Vt.TEXTURE_CUBE_MAP, Xt.get(t).__webglTexture)
            }
            function Y(t, e, r, i) {
                var n = $(e.texture.format)
                  , o = $(e.texture.type);
                Wt.texImage2D(i, 0, n, e.width, e.height, 0, n, o, null),
                Vt.bindFramebuffer(Vt.FRAMEBUFFER, t),
                Vt.framebufferTexture2D(Vt.FRAMEBUFFER, r, i, Xt.get(e.texture).__webglTexture, 0),
                Vt.bindFramebuffer(Vt.FRAMEBUFFER, null)
            }
            function q(t, e) {
                Vt.bindRenderbuffer(Vt.RENDERBUFFER, t),
                e.depthBuffer && !e.stencilBuffer ? (Vt.renderbufferStorage(Vt.RENDERBUFFER, Vt.DEPTH_COMPONENT16, e.width, e.height),
                Vt.framebufferRenderbuffer(Vt.FRAMEBUFFER, Vt.DEPTH_ATTACHMENT, Vt.RENDERBUFFER, t)) : e.depthBuffer && e.stencilBuffer ? (Vt.renderbufferStorage(Vt.RENDERBUFFER, Vt.DEPTH_STENCIL, e.width, e.height),
                Vt.framebufferRenderbuffer(Vt.FRAMEBUFFER, Vt.DEPTH_STENCIL_ATTACHMENT, Vt.RENDERBUFFER, t)) : Vt.renderbufferStorage(Vt.RENDERBUFFER, Vt.RGBA4, e.width, e.height),
                Vt.bindRenderbuffer(Vt.RENDERBUFFER, null)
            }
            function Z(t) {
                var e = Xt.get(t)
                  , r = t instanceof i.WebGLRenderTargetCube;
                if (r) {
                    e.__webglDepthbuffer = [];
                    for (var n = 0; n < 6; n++)
                        Vt.bindFramebuffer(Vt.FRAMEBUFFER, e.__webglFramebuffer[n]),
                        e.__webglDepthbuffer[n] = Vt.createRenderbuffer(),
                        q(e.__webglDepthbuffer[n], t)
                } else
                    Vt.bindFramebuffer(Vt.FRAMEBUFFER, e.__webglFramebuffer),
                    e.__webglDepthbuffer = Vt.createRenderbuffer(),
                    q(e.__webglDepthbuffer, t);
                Vt.bindFramebuffer(Vt.FRAMEBUFFER, null)
            }
            function Q(t) {
                var e = Xt.get(t)
                  , r = Xt.get(t.texture);
                t.addEventListener("dispose", h),
                r.__webglTexture = Vt.createTexture(),
                kt.textures++;
                var n = t instanceof i.WebGLRenderTargetCube
                  , o = i.Math.isPowerOfTwo(t.width) && i.Math.isPowerOfTwo(t.height);
                if (n) {
                    e.__webglFramebuffer = [];
                    for (var a = 0; a < 6; a++)
                        e.__webglFramebuffer[a] = Vt.createFramebuffer()
                } else
                    e.__webglFramebuffer = Vt.createFramebuffer();
                if (n) {
                    Wt.bindTexture(Vt.TEXTURE_CUBE_MAP, r.__webglTexture),
                    k(Vt.TEXTURE_CUBE_MAP, t.texture, o);
                    for (var a = 0; a < 6; a++)
                        Y(e.__webglFramebuffer[a], t, Vt.COLOR_ATTACHMENT0, Vt.TEXTURE_CUBE_MAP_POSITIVE_X + a);
                    t.texture.generateMipmaps && o && Vt.generateMipmap(Vt.TEXTURE_CUBE_MAP),
                    Wt.bindTexture(Vt.TEXTURE_CUBE_MAP, null)
                } else
                    Wt.bindTexture(Vt.TEXTURE_2D, r.__webglTexture),
                    k(Vt.TEXTURE_2D, t.texture, o),
                    Y(e.__webglFramebuffer, t, Vt.COLOR_ATTACHMENT0, Vt.TEXTURE_2D),
                    t.texture.generateMipmaps && o && Vt.generateMipmap(Vt.TEXTURE_2D),
                    Wt.bindTexture(Vt.TEXTURE_2D, null);
                t.depthBuffer && Z(t)
            }
            function J(t) {
                var e = t instanceof i.WebGLRenderTargetCube ? Vt.TEXTURE_CUBE_MAP : Vt.TEXTURE_2D
                  , r = Xt.get(t.texture).__webglTexture;
                Wt.bindTexture(e, r),
                Vt.generateMipmap(e),
                Wt.bindTexture(e, null)
            }
            function K(t) {
                return t === i.NearestFilter || t === i.NearestMipMapNearestFilter || t === i.NearestMipMapLinearFilter ? Vt.NEAREST : Vt.LINEAR
            }
            function $(t) {
                var e;
                if (t === i.RepeatWrapping)
                    return Vt.REPEAT;
                if (t === i.ClampToEdgeWrapping)
                    return Vt.CLAMP_TO_EDGE;
                if (t === i.MirroredRepeatWrapping)
                    return Vt.MIRRORED_REPEAT;
                if (t === i.NearestFilter)
                    return Vt.NEAREST;
                if (t === i.NearestMipMapNearestFilter)
                    return Vt.NEAREST_MIPMAP_NEAREST;
                if (t === i.NearestMipMapLinearFilter)
                    return Vt.NEAREST_MIPMAP_LINEAR;
                if (t === i.LinearFilter)
                    return Vt.LINEAR;
                if (t === i.LinearMipMapNearestFilter)
                    return Vt.LINEAR_MIPMAP_NEAREST;
                if (t === i.LinearMipMapLinearFilter)
                    return Vt.LINEAR_MIPMAP_LINEAR;
                if (t === i.UnsignedByteType)
                    return Vt.UNSIGNED_BYTE;
                if (t === i.UnsignedShort4444Type)
                    return Vt.UNSIGNED_SHORT_4_4_4_4;
                if (t === i.UnsignedShort5551Type)
                    return Vt.UNSIGNED_SHORT_5_5_5_1;
                if (t === i.UnsignedShort565Type)
                    return Vt.UNSIGNED_SHORT_5_6_5;
                if (t === i.ByteType)
                    return Vt.BYTE;
                if (t === i.ShortType)
                    return Vt.SHORT;
                if (t === i.UnsignedShortType)
                    return Vt.UNSIGNED_SHORT;
                if (t === i.IntType)
                    return Vt.INT;
                if (t === i.UnsignedIntType)
                    return Vt.UNSIGNED_INT;
                if (t === i.FloatType)
                    return Vt.FLOAT;
                if (e = jt.get("OES_texture_half_float"),
                null !== e && t === i.HalfFloatType)
                    return e.HALF_FLOAT_OES;
                if (t === i.AlphaFormat)
                    return Vt.ALPHA;
                if (t === i.RGBFormat)
                    return Vt.RGB;
                if (t === i.RGBAFormat)
                    return Vt.RGBA;
                if (t === i.LuminanceFormat)
                    return Vt.LUMINANCE;
                if (t === i.LuminanceAlphaFormat)
                    return Vt.LUMINANCE_ALPHA;
                if (t === i.AddEquation)
                    return Vt.FUNC_ADD;
                if (t === i.SubtractEquation)
                    return Vt.FUNC_SUBTRACT;
                if (t === i.ReverseSubtractEquation)
                    return Vt.FUNC_REVERSE_SUBTRACT;
                if (t === i.ZeroFactor)
                    return Vt.ZERO;
                if (t === i.OneFactor)
                    return Vt.ONE;
                if (t === i.SrcColorFactor)
                    return Vt.SRC_COLOR;
                if (t === i.OneMinusSrcColorFactor)
                    return Vt.ONE_MINUS_SRC_COLOR;
                if (t === i.SrcAlphaFactor)
                    return Vt.SRC_ALPHA;
                if (t === i.OneMinusSrcAlphaFactor)
                    return Vt.ONE_MINUS_SRC_ALPHA;
                if (t === i.DstAlphaFactor)
                    return Vt.DST_ALPHA;
                if (t === i.OneMinusDstAlphaFactor)
                    return Vt.ONE_MINUS_DST_ALPHA;
                if (t === i.DstColorFactor)
                    return Vt.DST_COLOR;
                if (t === i.OneMinusDstColorFactor)
                    return Vt.ONE_MINUS_DST_COLOR;
                if (t === i.SrcAlphaSaturateFactor)
                    return Vt.SRC_ALPHA_SATURATE;
                if (e = jt.get("WEBGL_compressed_texture_s3tc"),
                null !== e) {
                    if (t === i.RGB_S3TC_DXT1_Format)
                        return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (t === i.RGBA_S3TC_DXT1_Format)
                        return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (t === i.RGBA_S3TC_DXT3_Format)
                        return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (t === i.RGBA_S3TC_DXT5_Format)
                        return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (e = jt.get("WEBGL_compressed_texture_pvrtc"),
                null !== e) {
                    if (t === i.RGB_PVRTC_4BPPV1_Format)
                        return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (t === i.RGB_PVRTC_2BPPV1_Format)
                        return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (t === i.RGBA_PVRTC_4BPPV1_Format)
                        return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (t === i.RGBA_PVRTC_2BPPV1_Format)
                        return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (e = jt.get("WEBGL_compressed_texture_etc1"),
                null !== e && t === i.RGB_ETC1_Format)
                    return e.COMPRESSED_RGB_ETC1_WEBGL;
                if (e = jt.get("EXT_blend_minmax"),
                null !== e) {
                    if (t === i.MinEquation)
                        return e.MIN_EXT;
                    if (t === i.MaxEquation)
                        return e.MAX_EXT
                }
                return 0
            }
            console.log("THREE.WebGLRenderer", i.REVISION),
            t = t || {};
            var tt = void 0 !== t.canvas ? t.canvas : document.createElement("canvas")
              , et = void 0 !== t.context ? t.context : null
              , rt = void 0 !== t.alpha && t.alpha
              , it = void 0 === t.depth || t.depth
              , nt = void 0 === t.stencil || t.stencil
              , ot = void 0 !== t.antialias && t.antialias
              , at = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
              , st = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
              , ht = []
              , ct = []
              , lt = -1
              , ut = []
              , pt = -1
              , dt = new Float32Array(8)
              , ft = []
              , mt = [];
            this.domElement = tt,
            this.context = null,
            this.autoClear = !0,
            this.autoClearColor = !0,
            this.autoClearDepth = !0,
            this.autoClearStencil = !0,
            this.sortObjects = !0,
            this.gammaFactor = 2,
            this.gammaInput = !1,
            this.gammaOutput = !1,
            this.maxMorphTargets = 8,
            this.maxMorphNormals = 4,
            this.autoScaleCubemaps = !0;
            var gt = this
              , vt = null
              , yt = null
              , xt = null
              , bt = -1
              , wt = ""
              , _t = null
              , Mt = new i.Vector4
              , St = null
              , Et = new i.Vector4
              , Tt = 0
              , At = new i.Color(0)
              , Lt = 0
              , Ct = tt.width
              , Rt = tt.height
              , Pt = 1
              , Ut = new i.Vector4(0,0,Ct,Rt)
              , It = !1
              , Dt = new i.Vector4(0,0,Ct,Rt)
              , Ot = new i.Frustum
              , Nt = new i.Matrix4
              , Bt = new i.Vector3
              , Ft = {
                hash: "",
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                shadows: [],
                shadowsPointLight: 0
            }
              , kt = {
                geometries: 0,
                textures: 0
            }
              , zt = {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            };
            this.info = {
                render: zt,
                memory: kt,
                programs: null
            };
            var Vt;
            try {
                var Gt = {
                    alpha: rt,
                    depth: it,
                    stencil: nt,
                    antialias: ot,
                    premultipliedAlpha: at,
                    preserveDrawingBuffer: st
                };
                if (Vt = et || tt.getContext("webgl", Gt) || tt.getContext("experimental-webgl", Gt),
                null === Vt)
                    throw null !== tt.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
                tt.addEventListener("webglcontextlost", a, !1)
            } catch (t) {
                console.error("THREE.WebGLRenderer: " + t)
            }
            var jt = new i.WebGLExtensions(Vt);
            jt.get("OES_texture_float"),
            jt.get("OES_texture_float_linear"),
            jt.get("OES_texture_half_float"),
            jt.get("OES_texture_half_float_linear"),
            jt.get("OES_standard_derivatives"),
            jt.get("ANGLE_instanced_arrays"),
            jt.get("OES_element_index_uint") && (i.BufferGeometry.MaxIndex = 4294967296);
            var Ht = new i.WebGLCapabilities(Vt,jt,t)
              , Wt = new i.WebGLState(Vt,jt,$)
              , Xt = new i.WebGLProperties
              , Yt = new i.WebGLObjects(Vt,Xt,this.info)
              , qt = new i.WebGLPrograms(this,Ht)
              , Zt = new i.WebGLLights;
            this.info.programs = qt.programs;
            var Qt = new i.WebGLBufferRenderer(Vt,jt,zt)
              , Jt = new i.WebGLIndexedBufferRenderer(Vt,jt,zt);
            n(),
            this.context = Vt,
            this.capabilities = Ht,
            this.extensions = jt,
            this.properties = Xt,
            this.state = Wt;
            var Kt = new i.WebGLShadowMap(this,Ft,Yt);
            this.shadowMap = Kt;
            var $t = new i.SpritePlugin(this,ft)
              , te = new i.LensFlarePlugin(this,mt);
            this.getContext = function() {
                return Vt
            }
            ,
            this.getContextAttributes = function() {
                return Vt.getContextAttributes()
            }
            ,
            this.forceContextLoss = function() {
                jt.get("WEBGL_lose_context").loseContext()
            }
            ,
            this.getMaxAnisotropy = function() {
                var t;
                return function() {
                    if (void 0 !== t)
                        return t;
                    var e = jt.get("EXT_texture_filter_anisotropic");
                    return t = null !== e ? Vt.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                }
            }(),
            this.getPrecision = function() {
                return Ht.precision
            }
            ,
            this.getPixelRatio = function() {
                return Pt
            }
            ,
            this.setPixelRatio = function(t) {
                void 0 !== t && (Pt = t,
                this.setSize(Dt.z, Dt.w, !1))
            }
            ,
            this.getSize = function() {
                return {
                    width: Ct,
                    height: Rt
                }
            }
            ,
            this.setSize = function(t, e, r) {
                Ct = t,
                Rt = e,
                tt.width = t * Pt,
                tt.height = e * Pt,
                r !== !1 && (tt.style.width = t + "px",
                tt.style.height = e + "px"),
                this.setViewport(0, 0, t, e)
            }
            ,
            this.setViewport = function(t, e, r, i) {
                Wt.viewport(Dt.set(t, e, r, i))
            }
            ,
            this.setScissor = function(t, e, r, i) {
                Wt.scissor(Ut.set(t, e, r, i))
            }
            ,
            this.setScissorTest = function(t) {
                Wt.setScissorTest(It = t)
            }
            ,
            this.getClearColor = function() {
                return At
            }
            ,
            this.setClearColor = function(t, e) {
                At.set(t),
                Lt = void 0 !== e ? e : 1,
                r(At.r, At.g, At.b, Lt)
            }
            ,
            this.getClearAlpha = function() {
                return Lt
            }
            ,
            this.setClearAlpha = function(t) {
                Lt = t,
                r(At.r, At.g, At.b, Lt)
            }
            ,
            this.clear = function(t, e, r) {
                var i = 0;
                (void 0 === t || t) && (i |= Vt.COLOR_BUFFER_BIT),
                (void 0 === e || e) && (i |= Vt.DEPTH_BUFFER_BIT),
                (void 0 === r || r) && (i |= Vt.STENCIL_BUFFER_BIT),
                Vt.clear(i)
            }
            ,
            this.clearColor = function() {
                this.clear(!0, !1, !1)
            }
            ,
            this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }
            ,
            this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }
            ,
            this.clearTarget = function(t, e, r, i) {
                this.setRenderTarget(t),
                this.clear(e, r, i)
            }
            ,
            this.resetGLState = o,
            this.dispose = function() {
                tt.removeEventListener("webglcontextlost", a, !1)
            }
            ,
            this.renderBufferImmediate = function(t, e, r) {
                Wt.initAttributes();
                var n = Xt.get(t);
                t.hasPositions && !n.position && (n.position = Vt.createBuffer()),
                t.hasNormals && !n.normal && (n.normal = Vt.createBuffer()),
                t.hasUvs && !n.uv && (n.uv = Vt.createBuffer()),
                t.hasColors && !n.color && (n.color = Vt.createBuffer());
                var o = e.getAttributes();
                if (t.hasPositions && (Vt.bindBuffer(Vt.ARRAY_BUFFER, n.position),
                Vt.bufferData(Vt.ARRAY_BUFFER, t.positionArray, Vt.DYNAMIC_DRAW),
                Wt.enableAttribute(o.position),
                Vt.vertexAttribPointer(o.position, 3, Vt.FLOAT, !1, 0, 0)),
                t.hasNormals) {
                    if (Vt.bindBuffer(Vt.ARRAY_BUFFER, n.normal),
                    "MeshPhongMaterial" !== r.type && "MeshStandardMaterial" !== r.type && r.shading === i.FlatShading)
                        for (var a = 0, s = 3 * t.count; a < s; a += 9) {
                            var h = t.normalArray
                              , c = (h[a + 0] + h[a + 3] + h[a + 6]) / 3
                              , l = (h[a + 1] + h[a + 4] + h[a + 7]) / 3
                              , u = (h[a + 2] + h[a + 5] + h[a + 8]) / 3;
                            h[a + 0] = c,
                            h[a + 1] = l,
                            h[a + 2] = u,
                            h[a + 3] = c,
                            h[a + 4] = l,
                            h[a + 5] = u,
                            h[a + 6] = c,
                            h[a + 7] = l,
                            h[a + 8] = u
                        }
                    Vt.bufferData(Vt.ARRAY_BUFFER, t.normalArray, Vt.DYNAMIC_DRAW),
                    Wt.enableAttribute(o.normal),
                    Vt.vertexAttribPointer(o.normal, 3, Vt.FLOAT, !1, 0, 0)
                }
                t.hasUvs && r.map && (Vt.bindBuffer(Vt.ARRAY_BUFFER, n.uv),
                Vt.bufferData(Vt.ARRAY_BUFFER, t.uvArray, Vt.DYNAMIC_DRAW),
                Wt.enableAttribute(o.uv),
                Vt.vertexAttribPointer(o.uv, 2, Vt.FLOAT, !1, 0, 0)),
                t.hasColors && r.vertexColors !== i.NoColors && (Vt.bindBuffer(Vt.ARRAY_BUFFER, n.color),
                Vt.bufferData(Vt.ARRAY_BUFFER, t.colorArray, Vt.DYNAMIC_DRAW),
                Wt.enableAttribute(o.color),
                Vt.vertexAttribPointer(o.color, 3, Vt.FLOAT, !1, 0, 0)),
                Wt.disableUnusedAttributes(),
                Vt.drawArrays(Vt.TRIANGLES, 0, t.count),
                t.count = 0
            }
            ,
            this.renderBufferDirect = function(t, r, n, o, a, s) {
                _(o);
                var h = S(t, r, o, a)
                  , c = !1
                  , l = n.id + "_" + h.id + "_" + o.wireframe;
                l !== wt && (wt = l,
                c = !0);
                var u = a.morphTargetInfluences;
                if (void 0 !== u) {
                    for (var p = [], d = 0, g = u.length; d < g; d++) {
                        var v = u[d];
                        p.push([v, d])
                    }
                    p.sort(m),
                    p.length > 8 && (p.length = 8);
                    for (var y = n.morphAttributes, d = 0, g = p.length; d < g; d++) {
                        var v = p[d];
                        if (dt[d] = v[0],
                        0 !== v[0]) {
                            var x = v[1];
                            o.morphTargets === !0 && y.position && n.addAttribute("morphTarget" + d, y.position[x]),
                            o.morphNormals === !0 && y.normal && n.addAttribute("morphNormal" + d, y.normal[x])
                        } else
                            o.morphTargets === !0 && n.removeAttribute("morphTarget" + d),
                            o.morphNormals === !0 && n.removeAttribute("morphNormal" + d)
                    }
                    var b = h.getUniforms();
                    null !== b.morphTargetInfluences && Vt.uniform1fv(b.morphTargetInfluences, dt),
                    c = !0
                }
                var x = n.index
                  , w = n.attributes.position;
                o.wireframe === !0 && (x = Yt.getWireframeAttribute(n));
                var M;
                null !== x ? (M = Jt,
                M.setIndex(x)) : M = Qt,
                c && (f(o, h, n),
                null !== x && Vt.bindBuffer(Vt.ELEMENT_ARRAY_BUFFER, Yt.getAttributeBuffer(x)));
                var E = 0
                  , T = 1 / 0;
                null !== x ? T = x.count : void 0 !== w && (T = w.count);
                var A = n.drawRange.start
                  , L = n.drawRange.count
                  , C = null !== s ? s.start : 0
                  , R = null !== s ? s.count : 1 / 0
                  , P = Math.max(E, A, C)
                  , U = Math.min(E + T, A + L, C + R) - 1
                  , I = Math.max(0, U - P + 1);
                if (a instanceof i.Mesh)
                    if (o.wireframe === !0)
                        Wt.setLineWidth(o.wireframeLinewidth * e()),
                        M.setMode(Vt.LINES);
                    else
                        switch (a.drawMode) {
                        case i.TrianglesDrawMode:
                            M.setMode(Vt.TRIANGLES);
                            break;
                        case i.TriangleStripDrawMode:
                            M.setMode(Vt.TRIANGLE_STRIP);
                            break;
                        case i.TriangleFanDrawMode:
                            M.setMode(Vt.TRIANGLE_FAN)
                        }
                else if (a instanceof i.Line) {
                    var D = o.linewidth;
                    void 0 === D && (D = 1),
                    Wt.setLineWidth(D * e()),
                    a instanceof i.LineSegments ? M.setMode(Vt.LINES) : M.setMode(Vt.LINE_STRIP)
                } else
                    a instanceof i.Points && M.setMode(Vt.POINTS);
                n instanceof i.InstancedBufferGeometry && n.maxInstancedCount > 0 ? M.renderInstances(n, P, I) : M.render(P, I)
            }
            ,
            this.render = function(t, e, r, n) {
                if (e instanceof i.Camera == !1)
                    return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                var o = t.fog;
                if (wt = "",
                bt = -1,
                _t = null,
                t.autoUpdate === !0 && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                e.matrixWorldInverse.getInverse(e.matrixWorld),
                Nt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                Ot.setFromMatrix(Nt),
                ht.length = 0,
                lt = -1,
                pt = -1,
                ft.length = 0,
                mt.length = 0,
                x(t, e),
                ct.length = lt + 1,
                ut.length = pt + 1,
                gt.sortObjects === !0 && (ct.sort(g),
                ut.sort(v)),
                F(ht, e),
                Kt.render(t, e),
                zt.calls = 0,
                zt.vertices = 0,
                zt.faces = 0,
                zt.points = 0,
                void 0 === r && (r = null),
                this.setRenderTarget(r),
                (this.autoClear || n) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil),
                t.overrideMaterial) {
                    var a = t.overrideMaterial;
                    b(ct, e, o, a),
                    b(ut, e, o, a)
                } else
                    Wt.setBlending(i.NoBlending),
                    b(ct, e, o),
                    b(ut, e, o);
                if ($t.render(t, e),
                te.render(t, e, Et),
                r) {
                    var s = r.texture;
                    s.generateMipmaps && G(r) && s.minFilter !== i.NearestFilter && s.minFilter !== i.LinearFilter && J(r)
                }
                Wt.setDepthTest(!0),
                Wt.setDepthWrite(!0),
                Wt.setColorWrite(!0)
            }
            ,
            this.setFaceCulling = function(t, e) {
                t === i.CullFaceNone ? Wt.disable(Vt.CULL_FACE) : (e === i.FrontFaceDirectionCW ? Vt.frontFace(Vt.CW) : Vt.frontFace(Vt.CCW),
                t === i.CullFaceBack ? Vt.cullFace(Vt.BACK) : t === i.CullFaceFront ? Vt.cullFace(Vt.FRONT) : Vt.cullFace(Vt.FRONT_AND_BACK),
                Wt.enable(Vt.CULL_FACE))
            }
            ,
            this.setTexture = function(t, e) {
                var r = Xt.get(t);
                if (t.version > 0 && r.__version !== t.version) {
                    var i = t.image;
                    return void 0 === i ? void console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", t) : i.complete === !1 ? void console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", t) : void z(r, t, e)
                }
                Wt.activeTexture(Vt.TEXTURE0 + e),
                Wt.bindTexture(Vt.TEXTURE_2D, r.__webglTexture)
            }
            ,
            this.setRenderTarget = function(t) {
                yt = t,
                t && void 0 === Xt.get(t).__webglFramebuffer && Q(t);
                var e, r = t instanceof i.WebGLRenderTargetCube;
                if (t) {
                    var n = Xt.get(t);
                    e = r ? n.__webglFramebuffer[t.activeCubeFace] : n.__webglFramebuffer,
                    Mt.copy(t.scissor),
                    St = t.scissorTest,
                    Et.copy(t.viewport)
                } else
                    e = null,
                    Mt.copy(Ut).multiplyScalar(Pt),
                    St = It,
                    Et.copy(Dt).multiplyScalar(Pt);
                if (xt !== e && (Vt.bindFramebuffer(Vt.FRAMEBUFFER, e),
                xt = e),
                Wt.scissor(Mt),
                Wt.setScissorTest(St),
                Wt.viewport(Et),
                r) {
                    var o = Xt.get(t.texture);
                    Vt.framebufferTexture2D(Vt.FRAMEBUFFER, Vt.COLOR_ATTACHMENT0, Vt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, o.__webglTexture, 0)
                }
            }
            ,
            this.readRenderTargetPixels = function(t, e, r, n, o, a) {
                if (t instanceof i.WebGLRenderTarget == !1)
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                var s = Xt.get(t).__webglFramebuffer;
                if (s) {
                    var h = !1;
                    s !== xt && (Vt.bindFramebuffer(Vt.FRAMEBUFFER, s),
                    h = !0);
                    try {
                        var c = t.texture;
                        if (c.format !== i.RGBAFormat && $(c.format) !== Vt.getParameter(Vt.IMPLEMENTATION_COLOR_READ_FORMAT))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(c.type === i.UnsignedByteType || $(c.type) === Vt.getParameter(Vt.IMPLEMENTATION_COLOR_READ_TYPE) || c.type === i.FloatType && jt.get("WEBGL_color_buffer_float") || c.type === i.HalfFloatType && jt.get("EXT_color_buffer_half_float")))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        Vt.checkFramebufferStatus(Vt.FRAMEBUFFER) === Vt.FRAMEBUFFER_COMPLETE ? Vt.readPixels(e, r, n, o, $(c.format), $(c.type), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        h && Vt.bindFramebuffer(Vt.FRAMEBUFFER, xt)
                    }
                }
            }
        }
        ,
        i.WebGLRenderTarget = function(t, e, r) {
            this.uuid = i.Math.generateUUID(),
            this.width = t,
            this.height = e,
            this.scissor = new i.Vector4(0,0,t,e),
            this.scissorTest = !1,
            this.viewport = new i.Vector4(0,0,t,e),
            r = r || {},
            void 0 === r.minFilter && (r.minFilter = i.LinearFilter),
            this.texture = new i.Texture((void 0),(void 0),r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy),
            this.depthBuffer = void 0 === r.depthBuffer || r.depthBuffer,
            this.stencilBuffer = void 0 === r.stencilBuffer || r.stencilBuffer
        }
        ,
        i.WebGLRenderTarget.prototype = {
            constructor: i.WebGLRenderTarget,
            setSize: function(t, e) {
                this.width === t && this.height === e || (this.width = t,
                this.height = e,
                this.dispose()),
                this.viewport.set(0, 0, t, e),
                this.scissor.set(0, 0, t, e)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.width = t.width,
                this.height = t.height,
                this.viewport.copy(t.viewport),
                this.texture = t.texture.clone(),
                this.depthBuffer = t.depthBuffer,
                this.stencilBuffer = t.stencilBuffer,
                this.shareDepthFrom = t.shareDepthFrom,
                this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        },
        i.EventDispatcher.prototype.apply(i.WebGLRenderTarget.prototype),
        i.WebGLRenderTargetCube = function(t, e, r) {
            i.WebGLRenderTarget.call(this, t, e, r),
            this.activeCubeFace = 0
        }
        ,
        i.WebGLRenderTargetCube.prototype = Object.create(i.WebGLRenderTarget.prototype),
        i.WebGLRenderTargetCube.prototype.constructor = i.WebGLRenderTargetCube,
        i.WebGLBufferRenderer = function(t, e, r) {
            function n(t) {
                s = t
            }
            function o(e, i) {
                t.drawArrays(s, e, i),
                r.calls++,
                r.vertices += i,
                s === t.TRIANGLES && (r.faces += i / 3)
            }
            function a(n) {
                var o = e.get("ANGLE_instanced_arrays");
                if (null === o)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                var a = n.attributes.position
                  , h = 0;
                a instanceof i.InterleavedBufferAttribute ? (h = a.data.count,
                o.drawArraysInstancedANGLE(s, 0, h, n.maxInstancedCount)) : (h = a.count,
                o.drawArraysInstancedANGLE(s, 0, h, n.maxInstancedCount)),
                r.calls++,
                r.vertices += h * n.maxInstancedCount,
                s === t.TRIANGLES && (r.faces += n.maxInstancedCount * h / 3)
            }
            var s;
            this.setMode = n,
            this.render = o,
            this.renderInstances = a
        }
        ,
        i.WebGLIndexedBufferRenderer = function(t, e, r) {
            function i(t) {
                s = t
            }
            function n(r) {
                r.array instanceof Uint32Array && e.get("OES_element_index_uint") ? (h = t.UNSIGNED_INT,
                c = 4) : (h = t.UNSIGNED_SHORT,
                c = 2)
            }
            function o(e, i) {
                t.drawElements(s, i, h, e * c),
                r.calls++,
                r.vertices += i,
                s === t.TRIANGLES && (r.faces += i / 3)
            }
            function a(i, n, o) {
                var a = e.get("ANGLE_instanced_arrays");
                return null === a ? void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (a.drawElementsInstancedANGLE(s, o, h, n * c, i.maxInstancedCount),
                r.calls++,
                r.vertices += o * i.maxInstancedCount,
                void (s === t.TRIANGLES && (r.faces += i.maxInstancedCount * o / 3)))
            }
            var s, h, c;
            this.setMode = i,
            this.setIndex = n,
            this.render = o,
            this.renderInstances = a
        }
        ,
        i.WebGLExtensions = function(t) {
            var e = {};
            this.get = function(r) {
                if (void 0 !== e[r])
                    return e[r];
                var i;
                switch (r) {
                case "EXT_texture_filter_anisotropic":
                    i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                case "WEBGL_compressed_texture_etc1":
                    i = t.getExtension("WEBGL_compressed_texture_etc1");
                    break;
                default:
                    i = t.getExtension(r)
                }
                return null === i && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."),
                e[r] = i,
                i
            }
        }
        ,
        i.WebGLCapabilities = function(t, e, r) {
            function i(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
                        return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            this.getMaxPrecision = i,
            this.precision = void 0 !== r.precision ? r.precision : "highp",
            this.logarithmicDepthBuffer = void 0 !== r.logarithmicDepthBuffer && r.logarithmicDepthBuffer,
            this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            this.maxVertexTextures = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE),
            this.maxCubemapSize = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            this.maxAttributes = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            this.maxVertexUniforms = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
            this.maxVaryings = t.getParameter(t.MAX_VARYING_VECTORS),
            this.maxFragmentUniforms = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
            this.vertexTextures = this.maxVertexTextures > 0,
            this.floatFragmentTextures = !!e.get("OES_texture_float"),
            this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
            var n = i(this.precision);
            n !== this.precision && (console.warn("THREE.WebGLRenderer:", this.precision, "not supported, using", n, "instead."),
            this.precision = n),
            this.logarithmicDepthBuffer && (this.logarithmicDepthBuffer = !!e.get("EXT_frag_depth"))
        }
        ,
        i.WebGLGeometries = function(t, e, r) {
            function n(t) {
                var e = t.geometry;
                if (void 0 !== l[e.id])
                    return l[e.id];
                e.addEventListener("dispose", o);
                var n;
                return e instanceof i.BufferGeometry ? n = e : e instanceof i.Geometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new i.BufferGeometry).setFromObject(t)),
                n = e._bufferGeometry),
                l[e.id] = n,
                r.memory.geometries++,
                n
            }
            function o(t) {
                var i = t.target
                  , n = l[i.id];
                null !== n.index && s(n.index),
                h(n.attributes),
                i.removeEventListener("dispose", o),
                delete l[i.id];
                var a = e.get(i);
                a.wireframe && s(a.wireframe),
                e.delete(i);
                var c = e.get(n);
                c.wireframe && s(c.wireframe),
                e.delete(n),
                r.memory.geometries--
            }
            function a(t) {
                return t instanceof i.InterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer
            }
            function s(e) {
                var r = a(e);
                void 0 !== r && (t.deleteBuffer(r),
                c(e))
            }
            function h(t) {
                for (var e in t)
                    s(t[e])
            }
            function c(t) {
                t instanceof i.InterleavedBufferAttribute ? e.delete(t.data) : e.delete(t)
            }
            var l = {};
            this.get = n
        }
        ,
        i.WebGLLights = function() {
            var t = {};
            this.get = function(e) {
                if (void 0 !== t[e.id])
                    return t[e.id];
                var r;
                switch (e.type) {
                case "DirectionalLight":
                    r = {
                        direction: new i.Vector3,
                        color: new i.Color,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new i.Vector2
                    };
                    break;
                case "SpotLight":
                    r = {
                        position: new i.Vector3,
                        direction: new i.Vector3,
                        color: new i.Color,
                        distance: 0,
                        angleCos: 0,
                        exponent: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new i.Vector2
                    };
                    break;
                case "PointLight":
                    r = {
                        position: new i.Vector3,
                        color: new i.Color,
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new i.Vector2
                    };
                    break;
                case "HemisphereLight":
                    r = {
                        direction: new i.Vector3,
                        skyColor: new i.Color,
                        groundColor: new i.Color
                    }
                }
                return t[e.id] = r,
                r
            }
        }
        ,
        i.WebGLObjects = function(t, e, r) {
            function n(e) {
                var r = u.get(e);
                e.geometry instanceof i.Geometry && r.updateFromObject(e);
                var n = r.index
                  , a = r.attributes;
                null !== n && o(n, t.ELEMENT_ARRAY_BUFFER);
                for (var s in a)
                    o(a[s], t.ARRAY_BUFFER);
                var h = r.morphAttributes;
                for (var s in h)
                    for (var c = h[s], l = 0, p = c.length; l < p; l++)
                        o(c[l], t.ARRAY_BUFFER);
                return r
            }
            function o(t, r) {
                var n = t instanceof i.InterleavedBufferAttribute ? t.data : t
                  , o = e.get(n);
                void 0 === o.__webglBuffer ? a(o, n, r) : o.version !== n.version && s(o, n, r)
            }
            function a(e, r, i) {
                e.__webglBuffer = t.createBuffer(),
                t.bindBuffer(i, e.__webglBuffer);
                var n = r.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW;
                t.bufferData(i, r.array, n),
                e.version = r.version
            }
            function s(e, r, i) {
                t.bindBuffer(i, e.__webglBuffer),
                r.dynamic === !1 || r.updateRange.count === -1 ? t.bufferSubData(i, 0, r.array) : 0 === r.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(i, r.updateRange.offset * r.array.BYTES_PER_ELEMENT, r.array.subarray(r.updateRange.offset, r.updateRange.offset + r.updateRange.count)),
                r.updateRange.count = 0),
                e.version = r.version
            }
            function h(t) {
                return t instanceof i.InterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer
            }
            function c(r) {
                var n = e.get(r);
                if (void 0 !== n.wireframe)
                    return n.wireframe;
                var a = []
                  , s = r.index
                  , h = r.attributes
                  , c = h.position;
                if (null !== s)
                    for (var u = {}, p = s.array, d = 0, f = p.length; d < f; d += 3) {
                        var m = p[d + 0]
                          , g = p[d + 1]
                          , v = p[d + 2];
                        l(u, m, g) && a.push(m, g),
                        l(u, g, v) && a.push(g, v),
                        l(u, v, m) && a.push(v, m)
                    }
                else
                    for (var p = h.position.array, d = 0, f = p.length / 3 - 1; d < f; d += 3) {
                        var m = d + 0
                          , g = d + 1
                          , v = d + 2;
                        a.push(m, g, g, v, v, m)
                    }
                var y = c.count > 65535 ? Uint32Array : Uint16Array
                  , x = new i.BufferAttribute(new y(a),1);
                return o(x, t.ELEMENT_ARRAY_BUFFER),
                n.wireframe = x,
                x
            }
            function l(t, e, r) {
                if (e > r) {
                    var i = e;
                    e = r,
                    r = i
                }
                var n = t[e];
                return void 0 === n ? (t[e] = [r],
                !0) : n.indexOf(r) === -1 && (n.push(r),
                !0)
            }
            var u = new i.WebGLGeometries(t,e,r);
            this.getAttributeBuffer = h,
            this.getWireframeAttribute = c,
            this.update = n
        }
        ,
        i.WebGLProgram = function() {
            function t(t, e, r) {
                t = t || {};
                var i = [t.derivatives || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && r.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && r.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && r.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                return i.filter(o).join("\n")
            }
            function e(t) {
                var e = [];
                for (var r in t) {
                    var i = t[r];
                    i !== !1 && e.push("#define " + r + " " + i)
                }
                return e.join("\n")
            }
            function r(t, e, r) {
                for (var i = {}, n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), o = 0; o < n; o++) {
                    var a = t.getActiveUniform(e, o)
                      , s = a.name
                      , h = t.getUniformLocation(e, s)
                      , p = c.exec(s);
                    if (p) {
                        var d = p[1]
                          , f = p[2]
                          , m = i[d];
                        m || (m = i[d] = {}),
                        m[f] = h
                    } else if (p = l.exec(s)) {
                        var g = p[1]
                          , v = p[2]
                          , y = p[3]
                          , x = i[g];
                        x || (x = i[g] = []);
                        var b = x[v];
                        b || (b = x[v] = {}),
                        b[y] = h
                    } else if (p = u.exec(s)) {
                        var g = p[1];
                        i[g] = h
                    } else
                        i[s] = h
                }
                return i
            }
            function n(t, e, r) {
                for (var i = {}, n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), o = 0; o < n; o++) {
                    var a = t.getActiveAttrib(e, o)
                      , s = a.name;
                    i[s] = t.getAttribLocation(e, s)
                }
                return i
            }
            function o(t) {
                return "" !== t
            }
            function a(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            }
            function s(t) {
                function e(t, e, r, i) {
                    for (var n = "", o = parseInt(e); o < parseInt(r); o++)
                        n += i.replace(/\[ i \]/g, "[ " + o + " ]");
                    return n
                }
                var r = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
                return t.replace(r, e)
            }
            var h = 0
              , c = /^([\w\d_]+)\.([\w\d_]+)$/
              , l = /^([\w\d_]+)\[(\d+)\]\.([\w\d_]+)$/
              , u = /^([\w\d_]+)\[0\]$/;
            return function(c, l, u, p) {
                var d = c.context
                  , f = u.extensions
                  , m = u.defines
                  , g = u.__webglShader.vertexShader
                  , v = u.__webglShader.fragmentShader
                  , y = "SHADOWMAP_TYPE_BASIC";
                p.shadowMapType === i.PCFShadowMap ? y = "SHADOWMAP_TYPE_PCF" : p.shadowMapType === i.PCFSoftShadowMap && (y = "SHADOWMAP_TYPE_PCF_SOFT");
                var x = "ENVMAP_TYPE_CUBE"
                  , b = "ENVMAP_MODE_REFLECTION"
                  , w = "ENVMAP_BLENDING_MULTIPLY";
                if (p.envMap) {
                    switch (u.envMap.mapping) {
                    case i.CubeReflectionMapping:
                    case i.CubeRefractionMapping:
                        x = "ENVMAP_TYPE_CUBE";
                        break;
                    case i.EquirectangularReflectionMapping:
                    case i.EquirectangularRefractionMapping:
                        x = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case i.SphericalReflectionMapping:
                        x = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (u.envMap.mapping) {
                    case i.CubeRefractionMapping:
                    case i.EquirectangularRefractionMapping:
                        b = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (u.combine) {
                    case i.MultiplyOperation:
                        w = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case i.MixOperation:
                        w = "ENVMAP_BLENDING_MIX";
                        break;
                    case i.AddOperation:
                        w = "ENVMAP_BLENDING_ADD"
                    }
                }
                var _, M, S = c.gammaFactor > 0 ? c.gammaFactor : 1, E = t(f, p, c.extensions), T = e(m), A = d.createProgram();
                u instanceof i.RawShaderMaterial ? (_ = "",
                M = "") : (_ = ["precision " + p.precision + " float;", "precision " + p.precision + " int;", "#define SHADER_NAME " + u.__webglShader.name, T, p.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", c.gammaInput ? "#define GAMMA_INPUT" : "", c.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + S, "#define MAX_BONES " + p.maxBones, p.map ? "#define USE_MAP" : "", p.envMap ? "#define USE_ENVMAP" : "", p.envMap ? "#define " + b : "", p.lightMap ? "#define USE_LIGHTMAP" : "", p.aoMap ? "#define USE_AOMAP" : "", p.emissiveMap ? "#define USE_EMISSIVEMAP" : "", p.bumpMap ? "#define USE_BUMPMAP" : "", p.normalMap ? "#define USE_NORMALMAP" : "", p.displacementMap && p.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", p.specularMap ? "#define USE_SPECULARMAP" : "", p.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", p.metalnessMap ? "#define USE_METALNESSMAP" : "", p.alphaMap ? "#define USE_ALPHAMAP" : "", p.vertexColors ? "#define USE_COLOR" : "", p.flatShading ? "#define FLAT_SHADED" : "", p.skinning ? "#define USE_SKINNING" : "", p.useVertexTexture ? "#define BONE_TEXTURE" : "", p.morphTargets ? "#define USE_MORPHTARGETS" : "", p.morphNormals && p.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", p.doubleSided ? "#define DOUBLE_SIDED" : "", p.flipSided ? "#define FLIP_SIDED" : "", p.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", p.shadowMapEnabled ? "#define " + y : "", p.pointLightShadows > 0 ? "#define POINT_LIGHT_SHADOWS" : "", p.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", p.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", p.logarithmicDepthBuffer && c.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(o).join("\n"),
                M = [E, "precision " + p.precision + " float;", "precision " + p.precision + " int;", "#define SHADER_NAME " + u.__webglShader.name, T, p.alphaTest ? "#define ALPHATEST " + p.alphaTest : "", c.gammaInput ? "#define GAMMA_INPUT" : "", c.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + S, p.useFog && p.fog ? "#define USE_FOG" : "", p.useFog && p.fogExp ? "#define FOG_EXP2" : "", p.map ? "#define USE_MAP" : "", p.envMap ? "#define USE_ENVMAP" : "", p.envMap ? "#define " + x : "", p.envMap ? "#define " + b : "", p.envMap ? "#define " + w : "", p.lightMap ? "#define USE_LIGHTMAP" : "", p.aoMap ? "#define USE_AOMAP" : "", p.emissiveMap ? "#define USE_EMISSIVEMAP" : "", p.bumpMap ? "#define USE_BUMPMAP" : "", p.normalMap ? "#define USE_NORMALMAP" : "", p.specularMap ? "#define USE_SPECULARMAP" : "", p.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", p.metalnessMap ? "#define USE_METALNESSMAP" : "", p.alphaMap ? "#define USE_ALPHAMAP" : "", p.vertexColors ? "#define USE_COLOR" : "", p.flatShading ? "#define FLAT_SHADED" : "", p.doubleSided ? "#define DOUBLE_SIDED" : "", p.flipSided ? "#define FLIP_SIDED" : "", p.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", p.shadowMapEnabled ? "#define " + y : "", p.pointLightShadows > 0 ? "#define POINT_LIGHT_SHADOWS" : "", p.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", p.logarithmicDepthBuffer && c.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", p.envMap && c.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "\n"].filter(o).join("\n")),
                g = a(g, p),
                v = a(v, p),
                u instanceof i.ShaderMaterial == !1 && (g = s(g),
                v = s(v));
                var L = _ + g
                  , C = M + v
                  , R = i.WebGLShader(d, d.VERTEX_SHADER, L)
                  , P = i.WebGLShader(d, d.FRAGMENT_SHADER, C);
                d.attachShader(A, R),
                d.attachShader(A, P),
                void 0 !== u.index0AttributeName ? d.bindAttribLocation(A, 0, u.index0AttributeName) : p.morphTargets === !0 && d.bindAttribLocation(A, 0, "position"),
                d.linkProgram(A);
                var U = d.getProgramInfoLog(A)
                  , I = d.getShaderInfoLog(R)
                  , D = d.getShaderInfoLog(P)
                  , O = !0
                  , N = !0;
                d.getProgramParameter(A, d.LINK_STATUS) === !1 ? (O = !1,
                console.error("THREE.WebGLProgram: shader error: ", d.getError(), "gl.VALIDATE_STATUS", d.getProgramParameter(A, d.VALIDATE_STATUS), "gl.getProgramInfoLog", U, I, D)) : "" !== U ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", U) : "" !== I && "" !== D || (N = !1),
                N && (this.diagnostics = {
                    runnable: O,
                    material: u,
                    programLog: U,
                    vertexShader: {
                        log: I,
                        prefix: _
                    },
                    fragmentShader: {
                        log: D,
                        prefix: M
                    }
                }),
                d.deleteShader(R),
                d.deleteShader(P);
                var B;
                this.getUniforms = function() {
                    return void 0 === B && (B = r(d, A)),
                    B
                }
                ;
                var F;
                return this.getAttributes = function() {
                    return void 0 === F && (F = n(d, A)),
                    F
                }
                ,
                this.destroy = function() {
                    d.deleteProgram(A),
                    this.program = void 0
                }
                ,
                Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                            this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                            this.getAttributes()
                        }
                    }
                }),
                this.id = h++,
                this.code = l,
                this.usedTimes = 1,
                this.program = A,
                this.vertexShader = R,
                this.fragmentShader = P,
                this
            }
        }(),
        i.WebGLPrograms = function(t, e) {
            function r(t) {
                if (e.floatVertexTextures && t && t.skeleton && t.skeleton.useVertexTexture)
                    return 1024;
                var r = e.maxVertexUniforms
                  , n = Math.floor((r - 20) / 4)
                  , o = n;
                return void 0 !== t && t instanceof i.SkinnedMesh && (o = Math.min(t.skeleton.bones.length, o),
                o < t.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + t.skeleton.bones.length + ", this GPU supports just " + o + " (try OpenGL instead of ANGLE)")),
                o
            }
            var n = []
              , o = {
                MeshDepthMaterial: "depth",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshStandardMaterial: "standard",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points"
            }
              , a = ["precision", "supportsVertexTextures", "map", "envMap", "envMapMode", "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "pointLightShadows", "shadowMapType", "alphaTest", "doubleSided", "flipSided"];
            this.getParameters = function(n, a, s, h) {
                var c = o[n.type]
                  , l = r(h)
                  , u = t.getPrecision();
                null !== n.precision && (u = e.getMaxPrecision(n.precision),
                u !== n.precision && console.warn("THREE.WebGLProgram.getParameters:", n.precision, "not supported, using", u, "instead."));
                var p = {
                    shaderID: c,
                    precision: u,
                    supportsVertexTextures: e.vertexTextures,
                    map: !!n.map,
                    envMap: !!n.envMap,
                    envMapMode: n.envMap && n.envMap.mapping,
                    lightMap: !!n.lightMap,
                    aoMap: !!n.aoMap,
                    emissiveMap: !!n.emissiveMap,
                    bumpMap: !!n.bumpMap,
                    normalMap: !!n.normalMap,
                    displacementMap: !!n.displacementMap,
                    roughnessMap: !!n.roughnessMap,
                    metalnessMap: !!n.metalnessMap,
                    specularMap: !!n.specularMap,
                    alphaMap: !!n.alphaMap,
                    combine: n.combine,
                    vertexColors: n.vertexColors,
                    fog: s,
                    useFog: n.fog,
                    fogExp: s instanceof i.FogExp2,
                    flatShading: n.shading === i.FlatShading,
                    sizeAttenuation: n.sizeAttenuation,
                    logarithmicDepthBuffer: e.logarithmicDepthBuffer,
                    skinning: n.skinning,
                    maxBones: l,
                    useVertexTexture: e.floatVertexTextures && h && h.skeleton && h.skeleton.useVertexTexture,
                    morphTargets: n.morphTargets,
                    morphNormals: n.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: a.directional.length,
                    numPointLights: a.point.length,
                    numSpotLights: a.spot.length,
                    numHemiLights: a.hemi.length,
                    pointLightShadows: a.shadowsPointLight,
                    shadowMapEnabled: t.shadowMap.enabled && h.receiveShadow && a.shadows.length > 0,
                    shadowMapType: t.shadowMap.type,
                    alphaTest: n.alphaTest,
                    doubleSided: n.side === i.DoubleSide,
                    flipSided: n.side === i.BackSide
                };
                return p
            }
            ,
            this.getProgramCode = function(t, e) {
                var r = [];
                if (e.shaderID ? r.push(e.shaderID) : (r.push(t.fragmentShader),
                r.push(t.vertexShader)),
                void 0 !== t.defines)
                    for (var i in t.defines)
                        r.push(i),
                        r.push(t.defines[i]);
                for (var n = 0; n < a.length; n++) {
                    var o = a[n];
                    r.push(o),
                    r.push(e[o])
                }
                return r.join()
            }
            ,
            this.acquireProgram = function(e, r, o) {
                for (var a, s = 0, h = n.length; s < h; s++) {
                    var c = n[s];
                    if (c.code === o) {
                        a = c,
                        ++a.usedTimes;
                        break
                    }
                }
                return void 0 === a && (a = new i.WebGLProgram(t,o,e,r),
                n.push(a)),
                a
            }
            ,
            this.releaseProgram = function(t) {
                if (0 === --t.usedTimes) {
                    var e = n.indexOf(t);
                    n[e] = n[n.length - 1],
                    n.pop(),
                    t.destroy()
                }
            }
            ,
            this.programs = n
        }
        ,
        i.WebGLProperties = function() {
            var t = {};
            this.get = function(e) {
                var r = e.uuid
                  , i = t[r];
                return void 0 === i && (i = {},
                t[r] = i),
                i
            }
            ,
            this.delete = function(e) {
                delete t[e.uuid]
            }
            ,
            this.clear = function() {
                t = {}
            }
        }
        ,
        i.WebGLShader = function() {
            function t(t) {
                for (var e = t.split("\n"), r = 0; r < e.length; r++)
                    e[r] = r + 1 + ": " + e[r];
                return e.join("\n")
            }
            return function(e, r, i) {
                var n = e.createShader(r);
                return e.shaderSource(n, i),
                e.compileShader(n),
                e.getShaderParameter(n, e.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."),
                "" !== e.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", r === e.VERTEX_SHADER ? "vertex" : "fragment", e.getShaderInfoLog(n), t(i)),
                n
            }
        }(),
        i.WebGLShadowMap = function(t, e, r) {
            function n(t, e, r, n) {
                var o = t.geometry
                  , a = null
                  , s = g
                  , h = t.customDepthMaterial;
                if (r && (s = v,
                h = t.customDistanceMaterial),
                h)
                    a = h;
                else {
                    var c = void 0 !== o.morphTargets && o.morphTargets.length > 0 && e.morphTargets
                      , l = t instanceof i.SkinnedMesh && e.skinning
                      , u = 0;
                    c && (u |= d),
                    l && (u |= f),
                    a = s[u]
                }
                return a.visible = e.visible,
                a.wireframe = e.wireframe,
                a.wireframeLinewidth = e.wireframeLinewidth,
                r && void 0 !== a.uniforms.lightPos && a.uniforms.lightPos.value.copy(n),
                a
            }
            function o(t, e, r) {
                if (t.visible !== !1) {
                    if (t.layers.test(e.layers) && (t instanceof i.Mesh || t instanceof i.Line || t instanceof i.Points) && t.castShadow && (t.frustumCulled === !1 || h.intersectsObject(t) === !0)) {
                        var n = t.material;
                        n.visible === !0 && (t.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, t.matrixWorld),
                        p.push(t))
                    }
                    for (var a = t.children, s = 0, c = a.length; s < c; s++)
                        o(a[s], e, r)
                }
            }
            for (var a = t.context, s = t.state, h = new i.Frustum, c = new i.Matrix4, l = new i.Vector3, u = new i.Vector3, p = [], d = 1, f = 2, m = (d | f) + 1, g = new Array(m), v = new Array(m), y = [new i.Vector3(1,0,0), new i.Vector3((-1),0,0), new i.Vector3(0,0,1), new i.Vector3(0,0,(-1)), new i.Vector3(0,1,0), new i.Vector3(0,(-1),0)], x = [new i.Vector3(0,1,0), new i.Vector3(0,1,0), new i.Vector3(0,1,0), new i.Vector3(0,1,0), new i.Vector3(0,0,1), new i.Vector3(0,0,(-1))], b = [new i.Vector4, new i.Vector4, new i.Vector4, new i.Vector4, new i.Vector4, new i.Vector4], w = i.ShaderLib.depthRGBA, _ = i.UniformsUtils.clone(w.uniforms), M = i.ShaderLib.distanceRGBA, S = i.UniformsUtils.clone(M.uniforms), E = 0; E !== m; ++E) {
                var T = 0 !== (E & d)
                  , A = 0 !== (E & f)
                  , L = new i.ShaderMaterial({
                    uniforms: _,
                    vertexShader: w.vertexShader,
                    fragmentShader: w.fragmentShader,
                    morphTargets: T,
                    skinning: A
                });
                L._shadowPass = !0,
                g[E] = L;
                var C = new i.ShaderMaterial({
                    uniforms: S,
                    vertexShader: M.vertexShader,
                    fragmentShader: M.fragmentShader,
                    morphTargets: T,
                    skinning: A
                });
                C._shadowPass = !0,
                v[E] = C
            }
            var R = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = i.PCFShadowMap,
            this.cullFace = i.CullFaceFront,
            this.render = function(d, f) {
                var m, g;
                if (R.enabled !== !1 && (R.autoUpdate !== !1 || R.needsUpdate !== !1)) {
                    s.clearColor(1, 1, 1, 1),
                    s.disable(a.BLEND),
                    s.enable(a.CULL_FACE),
                    a.frontFace(a.CCW),
                    a.cullFace(R.cullFace === i.CullFaceFront ? a.FRONT : a.BACK),
                    s.setDepthTest(!0),
                    s.setScissorTest(!1);
                    for (var v = e.shadows, w = 0, _ = v.length; w < _; w++) {
                        var M = v[w]
                          , S = M.shadow
                          , E = S.camera
                          , T = S.mapSize;
                        if (M instanceof i.PointLight) {
                            m = 6,
                            g = !0;
                            var A = T.x / 4
                              , L = T.y / 2;
                            b[0].set(2 * A, L, A, L),
                            b[1].set(0, L, A, L),
                            b[2].set(3 * A, L, A, L),
                            b[3].set(A, L, A, L),
                            b[4].set(3 * A, 0, A, L),
                            b[5].set(A, 0, A, L)
                        } else
                            m = 1,
                            g = !1;
                        if (null === S.map) {
                            var C = {
                                minFilter: i.LinearFilter,
                                magFilter: i.LinearFilter,
                                format: i.RGBAFormat
                            };
                            S.map = new i.WebGLRenderTarget(T.x,T.y,C),
                            M instanceof i.SpotLight && (E.aspect = T.x / T.y),
                            E.updateProjectionMatrix()
                        }
                        var P = S.map
                          , U = S.matrix;
                        u.setFromMatrixPosition(M.matrixWorld),
                        E.position.copy(u),
                        t.setRenderTarget(P),
                        t.clear();
                        for (var I = 0; I < m; I++) {
                            if (g) {
                                l.copy(E.position),
                                l.add(y[I]),
                                E.up.copy(x[I]),
                                E.lookAt(l);
                                var D = b[I];
                                s.viewport(D)
                            } else
                                l.setFromMatrixPosition(M.target.matrixWorld),
                                E.lookAt(l);
                            E.updateMatrixWorld(),
                            E.matrixWorldInverse.getInverse(E.matrixWorld),
                            U.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                            U.multiply(E.projectionMatrix),
                            U.multiply(E.matrixWorldInverse),
                            c.multiplyMatrices(E.projectionMatrix, E.matrixWorldInverse),
                            h.setFromMatrix(c),
                            p.length = 0,
                            o(d, f, E);
                            for (var O = 0, N = p.length; O < N; O++) {
                                var B = p[O]
                                  , F = r.update(B)
                                  , k = B.material;
                                if (k instanceof i.MultiMaterial)
                                    for (var z = F.groups, V = k.materials, G = 0, j = z.length; G < j; G++) {
                                        var H = z[G]
                                          , W = V[H.materialIndex];
                                        if (W.visible === !0) {
                                            var X = n(B, W, g, u);
                                            t.renderBufferDirect(E, null, F, X, B, H)
                                        }
                                    }
                                else {
                                    var X = n(B, k, g, u);
                                    t.renderBufferDirect(E, null, F, X, B, null)
                                }
                            }
                        }
                        t.resetGLState()
                    }
                    var Y = t.getClearColor()
                      , q = t.getClearAlpha();
                    t.setClearColor(Y, q),
                    s.enable(a.BLEND),
                    R.cullFace === i.CullFaceFront && a.cullFace(a.BACK),
                    t.resetGLState(),
                    R.needsUpdate = !1
                }
            }
        }
        ,
        i.WebGLState = function(t, e, r) {
            var n = this
              , o = new i.Vector4
              , a = new Uint8Array(16)
              , s = new Uint8Array(16)
              , h = new Uint8Array(16)
              , c = {}
              , l = null
              , u = null
              , p = null
              , d = null
              , f = null
              , m = null
              , g = null
              , v = null
              , y = null
              , x = null
              , b = null
              , w = null
              , _ = null
              , M = null
              , S = null
              , E = null
              , T = null
              , A = null
              , L = null
              , C = null
              , R = null
              , P = null
              , U = null
              , I = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
              , D = void 0
              , O = {}
              , N = new i.Vector4
              , B = null
              , F = null
              , k = new i.Vector4
              , z = new i.Vector4;
            this.init = function() {
                this.clearColor(0, 0, 0, 1),
                this.clearDepth(1),
                this.clearStencil(0),
                this.enable(t.DEPTH_TEST),
                t.depthFunc(t.LEQUAL),
                t.frontFace(t.CCW),
                t.cullFace(t.BACK),
                this.enable(t.CULL_FACE),
                this.enable(t.BLEND),
                t.blendEquation(t.FUNC_ADD),
                t.blendFunc(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA)
            }
            ,
            this.initAttributes = function() {
                for (var t = 0, e = a.length; t < e; t++)
                    a[t] = 0
            }
            ,
            this.enableAttribute = function(r) {
                if (a[r] = 1,
                0 === s[r] && (t.enableVertexAttribArray(r),
                s[r] = 1),
                0 !== h[r]) {
                    var i = e.get("ANGLE_instanced_arrays");
                    i.vertexAttribDivisorANGLE(r, 0),
                    h[r] = 0
                }
            }
            ,
            this.enableAttributeAndDivisor = function(e, r, i) {
                a[e] = 1,
                0 === s[e] && (t.enableVertexAttribArray(e),
                s[e] = 1),
                h[e] !== r && (i.vertexAttribDivisorANGLE(e, r),
                h[e] = r)
            }
            ,
            this.disableUnusedAttributes = function() {
                for (var e = 0, r = s.length; e < r; e++)
                    s[e] !== a[e] && (t.disableVertexAttribArray(e),
                    s[e] = 0)
            }
            ,
            this.enable = function(e) {
                c[e] !== !0 && (t.enable(e),
                c[e] = !0)
            }
            ,
            this.disable = function(e) {
                c[e] !== !1 && (t.disable(e),
                c[e] = !1)
            }
            ,
            this.getCompressedTextureFormats = function() {
                if (null === l && (l = [],
                e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1")))
                    for (var r = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), i = 0; i < r.length; i++)
                        l.push(r[i]);
                return l
            }
            ,
            this.setBlending = function(e, n, o, a, s, h, c) {
                e === i.NoBlending ? this.disable(t.BLEND) : this.enable(t.BLEND),
                e !== u && (e === i.AdditiveBlending ? (t.blendEquation(t.FUNC_ADD),
                t.blendFunc(t.SRC_ALPHA, t.ONE)) : e === i.SubtractiveBlending ? (t.blendEquation(t.FUNC_ADD),
                t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : e === i.MultiplyBlending ? (t.blendEquation(t.FUNC_ADD),
                t.blendFunc(t.ZERO, t.SRC_COLOR)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)),
                u = e),
                e === i.CustomBlending ? (s = s || n,
                h = h || o,
                c = c || a,
                n === p && s === m || (t.blendEquationSeparate(r(n), r(s)),
                p = n,
                m = s),
                o === d && a === f && h === g && c === v || (t.blendFuncSeparate(r(o), r(a), r(h), r(c)),
                d = o,
                f = a,
                g = h,
                v = c)) : (p = null,
                d = null,
                f = null,
                m = null,
                g = null,
                v = null)
            }
            ,
            this.setDepthFunc = function(e) {
                if (y !== e) {
                    if (e)
                        switch (e) {
                        case i.NeverDepth:
                            t.depthFunc(t.NEVER);
                            break;
                        case i.AlwaysDepth:
                            t.depthFunc(t.ALWAYS);
                            break;
                        case i.LessDepth:
                            t.depthFunc(t.LESS);
                            break;
                        case i.LessEqualDepth:
                            t.depthFunc(t.LEQUAL);
                            break;
                        case i.EqualDepth:
                            t.depthFunc(t.EQUAL);
                            break;
                        case i.GreaterEqualDepth:
                            t.depthFunc(t.GEQUAL);
                            break;
                        case i.GreaterDepth:
                            t.depthFunc(t.GREATER);
                            break;
                        case i.NotEqualDepth:
                            t.depthFunc(t.NOTEQUAL);
                            break;
                        default:
                            t.depthFunc(t.LEQUAL)
                        }
                    else
                        t.depthFunc(t.LEQUAL);
                    y = e
                }
            }
            ,
            this.setDepthTest = function(e) {
                e ? this.enable(t.DEPTH_TEST) : this.disable(t.DEPTH_TEST)
            }
            ,
            this.setDepthWrite = function(e) {
                x !== e && (t.depthMask(e),
                x = e)
            }
            ,
            this.setColorWrite = function(e) {
                b !== e && (t.colorMask(e, e, e, e),
                b = e)
            }
            ,
            this.setStencilFunc = function(e, r, i) {
                _ === e && M === r && S === i || (t.stencilFunc(e, r, i),
                _ = e,
                M = r,
                S = i)
            }
            ,
            this.setStencilOp = function(e, r, i) {
                E === e && T === r && A === i || (t.stencilOp(e, r, i),
                E = e,
                T = r,
                A = i)
            }
            ,
            this.setStencilTest = function(e) {
                e ? this.enable(t.STENCIL_TEST) : this.disable(t.STENCIL_TEST)
            }
            ,
            this.setStencilWrite = function(e) {
                w !== e && (t.stencilMask(e),
                w = e)
            }
            ,
            this.setFlipSided = function(e) {
                L !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
                L = e)
            }
            ,
            this.setLineWidth = function(e) {
                e !== C && (t.lineWidth(e),
                C = e)
            }
            ,
            this.setPolygonOffset = function(e, r, i) {
                e ? this.enable(t.POLYGON_OFFSET_FILL) : this.disable(t.POLYGON_OFFSET_FILL),
                !e || R === r && P === i || (t.polygonOffset(r, i),
                R = r,
                P = i)
            }
            ,
            this.getScissorTest = function() {
                return U
            }
            ,
            this.setScissorTest = function(e) {
                U = e,
                e ? this.enable(t.SCISSOR_TEST) : this.disable(t.SCISSOR_TEST)
            }
            ,
            this.activeTexture = function(e) {
                void 0 === e && (e = t.TEXTURE0 + I - 1),
                D !== e && (t.activeTexture(e),
                D = e)
            }
            ,
            this.bindTexture = function(e, r) {
                void 0 === D && n.activeTexture();
                var i = O[D];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                },
                O[D] = i),
                i.type === e && i.texture === r || (t.bindTexture(e, r),
                i.type = e,
                i.texture = r)
            }
            ,
            this.compressedTexImage2D = function() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error(t)
                }
            }
            ,
            this.texImage2D = function() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error(t)
                }
            }
            ,
            this.clearColor = function(e, r, i, n) {
                o.set(e, r, i, n),
                N.equals(o) === !1 && (t.clearColor(e, r, i, n),
                N.copy(o))
            }
            ,
            this.clearDepth = function(e) {
                B !== e && (t.clearDepth(e),
                B = e)
            }
            ,
            this.clearStencil = function(e) {
                F !== e && (t.clearStencil(e),
                F = e)
            }
            ,
            this.scissor = function(e) {
                k.equals(e) === !1 && (t.scissor(e.x, e.y, e.z, e.w),
                k.copy(e))
            }
            ,
            this.viewport = function(e) {
                z.equals(e) === !1 && (t.viewport(e.x, e.y, e.z, e.w),
                z.copy(e))
            }
            ,
            this.reset = function() {
                for (var e = 0; e < s.length; e++)
                    1 === s[e] && (t.disableVertexAttribArray(e),
                    s[e] = 0);
                c = {},
                l = null,
                u = null,
                b = null,
                x = null,
                w = null,
                L = null
            }
        }
        ,
        i.LensFlarePlugin = function(t, e) {
            function r() {
                var t = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1])
                  , e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                o = d.createBuffer(),
                a = d.createBuffer(),
                d.bindBuffer(d.ARRAY_BUFFER, o),
                d.bufferData(d.ARRAY_BUFFER, t, d.STATIC_DRAW),
                d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, a),
                d.bufferData(d.ELEMENT_ARRAY_BUFFER, e, d.STATIC_DRAW),
                u = d.createTexture(),
                p = d.createTexture(),
                f.bindTexture(d.TEXTURE_2D, u),
                d.texImage2D(d.TEXTURE_2D, 0, d.RGB, 16, 16, 0, d.RGB, d.UNSIGNED_BYTE, null),
                d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE),
                d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE),
                d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.NEAREST),
                d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.NEAREST),
                f.bindTexture(d.TEXTURE_2D, p),
                d.texImage2D(d.TEXTURE_2D, 0, d.RGBA, 16, 16, 0, d.RGBA, d.UNSIGNED_BYTE, null),
                d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE),
                d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE),
                d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.NEAREST),
                d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.NEAREST),
                l = d.getParameter(d.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
                var r;
                r = l ? {
                    vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                } : {
                    vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                },
                s = n(r),
                h = {
                    vertex: d.getAttribLocation(s, "position"),
                    uv: d.getAttribLocation(s, "uv")
                },
                c = {
                    renderType: d.getUniformLocation(s, "renderType"),
                    map: d.getUniformLocation(s, "map"),
                    occlusionMap: d.getUniformLocation(s, "occlusionMap"),
                    opacity: d.getUniformLocation(s, "opacity"),
                    color: d.getUniformLocation(s, "color"),
                    scale: d.getUniformLocation(s, "scale"),
                    rotation: d.getUniformLocation(s, "rotation"),
                    screenPosition: d.getUniformLocation(s, "screenPosition")
                }
            }
            function n(e) {
                var r = d.createProgram()
                  , i = d.createShader(d.FRAGMENT_SHADER)
                  , n = d.createShader(d.VERTEX_SHADER)
                  , o = "precision " + t.getPrecision() + " float;\n";
                return d.shaderSource(i, o + e.fragmentShader),
                d.shaderSource(n, o + e.vertexShader),
                d.compileShader(i),
                d.compileShader(n),
                d.attachShader(r, i),
                d.attachShader(r, n),
                d.linkProgram(r),
                r
            }
            var o, a, s, h, c, l, u, p, d = t.context, f = t.state;
            this.render = function(n, m, g) {
                if (0 !== e.length) {
                    var v = new i.Vector3
                      , y = g.w / g.z
                      , x = .5 * g.z
                      , b = .5 * g.w
                      , w = 16 / g.w
                      , _ = new i.Vector2(w * y,w)
                      , M = new i.Vector3(1,1,0)
                      , S = new i.Vector2(1,1);
                    void 0 === s && r(),
                    d.useProgram(s),
                    f.initAttributes(),
                    f.enableAttribute(h.vertex),
                    f.enableAttribute(h.uv),
                    f.disableUnusedAttributes(),
                    d.uniform1i(c.occlusionMap, 0),
                    d.uniform1i(c.map, 1),
                    d.bindBuffer(d.ARRAY_BUFFER, o),
                    d.vertexAttribPointer(h.vertex, 2, d.FLOAT, !1, 16, 0),
                    d.vertexAttribPointer(h.uv, 2, d.FLOAT, !1, 16, 8),
                    d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, a),
                    f.disable(d.CULL_FACE),
                    f.setDepthWrite(!1);
                    for (var E = 0, T = e.length; E < T; E++) {
                        w = 16 / g.w,
                        _.set(w * y, w);
                        var A = e[E];
                        if (v.set(A.matrixWorld.elements[12], A.matrixWorld.elements[13], A.matrixWorld.elements[14]),
                        v.applyMatrix4(m.matrixWorldInverse),
                        v.applyProjection(m.projectionMatrix),
                        M.copy(v),
                        S.x = M.x * x + x,
                        S.y = M.y * b + b,
                        l || S.x > 0 && S.x < g.z && S.y > 0 && S.y < g.w) {
                            f.activeTexture(d.TEXTURE0),
                            f.bindTexture(d.TEXTURE_2D, null),
                            f.activeTexture(d.TEXTURE1),
                            f.bindTexture(d.TEXTURE_2D, u),
                            d.copyTexImage2D(d.TEXTURE_2D, 0, d.RGB, g.x + S.x - 8, g.y + S.y - 8, 16, 16, 0),
                            d.uniform1i(c.renderType, 0),
                            d.uniform2f(c.scale, _.x, _.y),
                            d.uniform3f(c.screenPosition, M.x, M.y, M.z),
                            f.disable(d.BLEND),
                            f.enable(d.DEPTH_TEST),
                            d.drawElements(d.TRIANGLES, 6, d.UNSIGNED_SHORT, 0),
                            f.activeTexture(d.TEXTURE0),
                            f.bindTexture(d.TEXTURE_2D, p),
                            d.copyTexImage2D(d.TEXTURE_2D, 0, d.RGBA, g.x + S.x - 8, g.y + S.y - 8, 16, 16, 0),
                            d.uniform1i(c.renderType, 1),
                            f.disable(d.DEPTH_TEST),
                            f.activeTexture(d.TEXTURE1),
                            f.bindTexture(d.TEXTURE_2D, u),
                            d.drawElements(d.TRIANGLES, 6, d.UNSIGNED_SHORT, 0),
                            A.positionScreen.copy(M),
                            A.customUpdateCallback ? A.customUpdateCallback(A) : A.updateLensFlares(),
                            d.uniform1i(c.renderType, 2),
                            f.enable(d.BLEND);
                            for (var L = 0, C = A.lensFlares.length; L < C; L++) {
                                var R = A.lensFlares[L];
                                R.opacity > .001 && R.scale > .001 && (M.x = R.x,
                                M.y = R.y,
                                M.z = R.z,
                                w = R.size * R.scale / g.w,
                                _.x = w * y,
                                _.y = w,
                                d.uniform3f(c.screenPosition, M.x, M.y, M.z),
                                d.uniform2f(c.scale, _.x, _.y),
                                d.uniform1f(c.rotation, R.rotation),
                                d.uniform1f(c.opacity, R.opacity),
                                d.uniform3f(c.color, R.color.r, R.color.g, R.color.b),
                                f.setBlending(R.blending, R.blendEquation, R.blendSrc, R.blendDst),
                                t.setTexture(R.texture, 1),
                                d.drawElements(d.TRIANGLES, 6, d.UNSIGNED_SHORT, 0))
                            }
                        }
                    }
                    f.enable(d.CULL_FACE),
                    f.enable(d.DEPTH_TEST),
                    f.setDepthWrite(!0),
                    t.resetGLState()
                }
            }
        }
        ,
        i.SpritePlugin = function(t, e) {
            function r() {
                var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1])
                  , e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                a = p.createBuffer(),
                s = p.createBuffer(),
                p.bindBuffer(p.ARRAY_BUFFER, a),
                p.bufferData(p.ARRAY_BUFFER, t, p.STATIC_DRAW),
                p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, s),
                p.bufferData(p.ELEMENT_ARRAY_BUFFER, e, p.STATIC_DRAW),
                h = n(),
                c = {
                    position: p.getAttribLocation(h, "position"),
                    uv: p.getAttribLocation(h, "uv")
                },
                l = {
                    uvOffset: p.getUniformLocation(h, "uvOffset"),
                    uvScale: p.getUniformLocation(h, "uvScale"),
                    rotation: p.getUniformLocation(h, "rotation"),
                    scale: p.getUniformLocation(h, "scale"),
                    color: p.getUniformLocation(h, "color"),
                    map: p.getUniformLocation(h, "map"),
                    opacity: p.getUniformLocation(h, "opacity"),
                    modelViewMatrix: p.getUniformLocation(h, "modelViewMatrix"),
                    projectionMatrix: p.getUniformLocation(h, "projectionMatrix"),
                    fogType: p.getUniformLocation(h, "fogType"),
                    fogDensity: p.getUniformLocation(h, "fogDensity"),
                    fogNear: p.getUniformLocation(h, "fogNear"),
                    fogFar: p.getUniformLocation(h, "fogFar"),
                    fogColor: p.getUniformLocation(h, "fogColor"),
                    alphaTest: p.getUniformLocation(h, "alphaTest")
                };
                var r = document.createElement("canvas");
                r.width = 8,
                r.height = 8;
                var o = r.getContext("2d");
                o.fillStyle = "white",
                o.fillRect(0, 0, 8, 8),
                u = new i.Texture(r),
                u.needsUpdate = !0
            }
            function n() {
                var e = p.createProgram()
                  , r = p.createShader(p.VERTEX_SHADER)
                  , i = p.createShader(p.FRAGMENT_SHADER);
                return p.shaderSource(r, ["precision " + t.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")),
                p.shaderSource(i, ["precision " + t.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")),
                p.compileShader(r),
                p.compileShader(i),
                p.attachShader(e, r),
                p.attachShader(e, i),
                p.linkProgram(e),
                e
            }
            function o(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
            }
            var a, s, h, c, l, u, p = t.context, d = t.state, f = new i.Vector3, m = new i.Quaternion, g = new i.Vector3;
            this.render = function(n, v) {
                if (0 !== e.length) {
                    void 0 === h && r(),
                    p.useProgram(h),
                    d.initAttributes(),
                    d.enableAttribute(c.position),
                    d.enableAttribute(c.uv),
                    d.disableUnusedAttributes(),
                    d.disable(p.CULL_FACE),
                    d.enable(p.BLEND),
                    p.bindBuffer(p.ARRAY_BUFFER, a),
                    p.vertexAttribPointer(c.position, 2, p.FLOAT, !1, 16, 0),
                    p.vertexAttribPointer(c.uv, 2, p.FLOAT, !1, 16, 8),
                    p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, s),
                    p.uniformMatrix4fv(l.projectionMatrix, !1, v.projectionMatrix.elements),
                    d.activeTexture(p.TEXTURE0),
                    p.uniform1i(l.map, 0);
                    var y = 0
                      , x = 0
                      , b = n.fog;
                    b ? (p.uniform3f(l.fogColor, b.color.r, b.color.g, b.color.b),
                    b instanceof i.Fog ? (p.uniform1f(l.fogNear, b.near),
                    p.uniform1f(l.fogFar, b.far),
                    p.uniform1i(l.fogType, 1),
                    y = 1,
                    x = 1) : b instanceof i.FogExp2 && (p.uniform1f(l.fogDensity, b.density),
                    p.uniform1i(l.fogType, 2),
                    y = 2,
                    x = 2)) : (p.uniform1i(l.fogType, 0),
                    y = 0,
                    x = 0);
                    for (var w = 0, _ = e.length; w < _; w++) {
                        var M = e[w];
                        M.modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, M.matrixWorld),
                        M.z = -M.modelViewMatrix.elements[14]
                    }
                    e.sort(o);
                    for (var S = [], w = 0, _ = e.length; w < _; w++) {
                        var M = e[w]
                          , E = M.material;
                        p.uniform1f(l.alphaTest, E.alphaTest),
                        p.uniformMatrix4fv(l.modelViewMatrix, !1, M.modelViewMatrix.elements),
                        M.matrixWorld.decompose(f, m, g),
                        S[0] = g.x,
                        S[1] = g.y;
                        var T = 0;
                        n.fog && E.fog && (T = x),
                        y !== T && (p.uniform1i(l.fogType, T),
                        y = T),
                        null !== E.map ? (p.uniform2f(l.uvOffset, E.map.offset.x, E.map.offset.y),
                        p.uniform2f(l.uvScale, E.map.repeat.x, E.map.repeat.y)) : (p.uniform2f(l.uvOffset, 0, 0),
                        p.uniform2f(l.uvScale, 1, 1)),
                        p.uniform1f(l.opacity, E.opacity),
                        p.uniform3f(l.color, E.color.r, E.color.g, E.color.b),
                        p.uniform1f(l.rotation, E.rotation),
                        p.uniform2fv(l.scale, S),
                        d.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst),
                        d.setDepthTest(E.depthTest),
                        d.setDepthWrite(E.depthWrite),
                        E.map && E.map.image && E.map.image.width ? t.setTexture(E.map, 0) : t.setTexture(u, 0),
                        p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0)
                    }
                    d.enable(p.CULL_FACE),
                    t.resetGLState()
                }
            }
        }
        ,
        Object.defineProperties(i.Box2.prototype, {
            empty: {
                value: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
                    this.isEmpty()
                }
            },
            isIntersectionBox: {
                value: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(t)
                }
            }
        }),
        Object.defineProperties(i.Box3.prototype, {
            empty: {
                value: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
                    this.isEmpty()
                }
            },
            isIntersectionBox: {
                value: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(t)
                }
            },
            isIntersectionSphere: {
                value: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                    this.intersectsSphere(t)
                }
            }
        }),
        Object.defineProperties(i.Matrix3.prototype, {
            multiplyVector3: {
                value: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
                    t.applyMatrix3(this)
                }
            },
            multiplyVector3Array: {
                value: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
                    this.applyToVector3Array(t)
                }
            }
        }),
        Object.defineProperties(i.Matrix4.prototype, {
            extractPosition: {
                value: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
                    this.copyPosition(t)
                }
            },
            setRotationFromQuaternion: {
                value: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
                    this.makeRotationFromQuaternion(t)
                }
            },
            multiplyVector3: {
                value: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."),
                    t.applyProjection(this)
                }
            },
            multiplyVector4: {
                value: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                    t.applyMatrix4(this)
                }
            },
            multiplyVector3Array: {
                value: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
                    this.applyToVector3Array(t)
                }
            },
            rotateAxis: {
                value: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
                    t.transformDirection(this)
                }
            },
            crossVector: {
                value: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                    t.applyMatrix4(this)
                }
            },
            translate: {
                value: function(t) {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                }
            },
            rotateX: {
                value: function(t) {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                }
            },
            rotateY: {
                value: function(t) {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                }
            },
            rotateZ: {
                value: function(t) {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                }
            },
            rotateByAxis: {
                value: function(t, e) {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                }
            }
        }),
        Object.defineProperties(i.Plane.prototype, {
            isIntersectionLine: {
                value: function(t) {
                    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
                    this.intersectsLine(t)
                }
            }
        }),
        Object.defineProperties(i.Quaternion.prototype, {
            multiplyVector3: {
                value: function(t) {
                    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
                    t.applyQuaternion(this)
                }
            }
        }),
        Object.defineProperties(i.Ray.prototype, {
            isIntersectionBox: {
                value: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(t)
                }
            },
            isIntersectionPlane: {
                value: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
                    this.intersectsPlane(t)
                }
            },
            isIntersectionSphere: {
                value: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                    this.intersectsSphere(t)
                }
            }
        }),
        Object.defineProperties(i.Vector3.prototype, {
            setEulerFromRotationMatrix: {
                value: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                }
            },
            setEulerFromQuaternion: {
                value: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                }
            },
            getPositionFromMatrix: {
                value: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
                    this.setFromMatrixPosition(t)
                }
            },
            getScaleFromMatrix: {
                value: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
                    this.setFromMatrixScale(t)
                }
            },
            getColumnFromMatrix: {
                value: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
                    this.setFromMatrixColumn(t, e)
                }
            }
        }),
        i.Face4 = function(t, e, r, n, o, a, s) {
            return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
            new i.Face3(t,e,r,o,a,s)
        }
        ,
        Object.defineProperties(i.Object3D.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                    this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                    this.rotation.order = t
                }
            },
            getChildByName: {
                value: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
                    this.getObjectByName(t)
                }
            },
            renderDepth: {
                set: function(t) {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                }
            },
            translate: {
                value: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
                    this.translateOnAxis(e, t)
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }),
        Object.defineProperties(i, {
            PointCloud: {
                value: function(t, e) {
                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
                    new i.Points(t,e)
                }
            },
            ParticleSystem: {
                value: function(t, e) {
                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
                    new i.Points(t,e)
                }
            }
        }),
        Object.defineProperties(i.Light.prototype, {
            onlyShadow: {
                set: function(t) {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                    this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                    this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                    this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                    this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                    this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                    this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                    this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                    this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                    this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                    this.shadow.mapSize.height = t
                }
            }
        }),
        Object.defineProperties(i.BufferAttribute.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
                    this.array.length
                }
            }
        }),
        Object.defineProperties(i.BufferGeometry.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                    this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                    this.groups
                }
            },
            addIndex: {
                value: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
                    this.setIndex(t)
                }
            },
            addDrawCall: {
                value: function(t, e, r) {
                    void 0 !== r && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
                    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
                    this.addGroup(t, e)
                }
            },
            clearDrawCalls: {
                value: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
                    this.clearGroups()
                }
            },
            computeTangents: {
                value: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                }
            },
            computeOffsets: {
                value: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }
        }),
        Object.defineProperties(i.Material.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .wrapRGB has been removed."),
                    new i.Color
                }
            }
        }),
        Object.defineProperties(i, {
            PointCloudMaterial: {
                value: function(t) {
                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
                    new i.PointsMaterial(t)
                }
            },
            ParticleBasicMaterial: {
                value: function(t) {
                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
                    new i.PointsMaterial(t)
                }
            },
            ParticleSystemMaterial: {
                value: function(t) {
                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
                    new i.PointsMaterial(t)
                }
            }
        }),
        Object.defineProperties(i.MeshPhongMaterial.prototype, {
            metal: {
                get: function() {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                    !1
                },
                set: function(t) {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }),
        Object.defineProperties(i.ShaderMaterial.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                    this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                    this.extensions.derivatives = t
                }
            }
        }),
        Object.defineProperties(i.WebGLRenderer.prototype, {
            supportsFloatTextures: {
                value: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
                    this.extensions.get("OES_texture_float")
                }
            },
            supportsHalfFloatTextures: {
                value: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
                    this.extensions.get("OES_texture_half_float")
                }
            },
            supportsStandardDerivatives: {
                value: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
                    this.extensions.get("OES_standard_derivatives")
                }
            },
            supportsCompressedTextureS3TC: {
                value: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
                    this.extensions.get("WEBGL_compressed_texture_s3tc")
                }
            },
            supportsCompressedTexturePVRTC: {
                value: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
                    this.extensions.get("WEBGL_compressed_texture_pvrtc")
                }
            },
            supportsBlendMinMax: {
                value: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
                    this.extensions.get("EXT_blend_minmax")
                }
            },
            supportsVertexTextures: {
                value: function() {
                    return this.capabilities.vertexTextures
                }
            },
            supportsInstancedArrays: {
                value: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
                    this.extensions.get("ANGLE_instanced_arrays")
                }
            },
            enableScissorTest: {
                value: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
                    this.setScissorTest(t)
                }
            },
            initMaterial: {
                value: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                }
            },
            addPrePlugin: {
                value: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                }
            },
            addPostPlugin: {
                value: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                }
            },
            updateShadowMap: {
                value: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                }
            },
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                    this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                    this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    return this.shadowMap.cullFace
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."),
                    this.shadowMap.cullFace = t
                }
            }
        }),
        Object.defineProperties(i.WebGLRenderTarget.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                    this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                    this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                    this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                    this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                    this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                    this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                    this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                    this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                    this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                    this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                    this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                    this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                    this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                    this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                    this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                    this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                    this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                    this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                    this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                    this.texture.generateMipmaps = t
                }
            }
        }),
        i.GeometryUtils = {
            merge: function(t, e, r) {
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                var n;
                e instanceof i.Mesh && (e.matrixAutoUpdate && e.updateMatrix(),
                n = e.matrix,
                e = e.geometry),
                t.merge(e, n, r)
            },
            center: function(t) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
                t.center()
            }
        },
        i.ImageUtils = {
            crossOrigin: void 0,
            loadTexture: function(t, e, r, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var o = new i.TextureLoader;
                o.setCrossOrigin(this.crossOrigin);
                var a = o.load(t, r, void 0, n);
                return e && (a.mapping = e),
                a
            },
            loadTextureCube: function(t, e, r, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var o = new i.CubeTextureLoader;
                o.setCrossOrigin(this.crossOrigin);
                var a = o.load(t, r, void 0, n);
                return e && (a.mapping = e),
                a
            },
            loadCompressedTexture: function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            },
            loadCompressedTextureCube: function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        },
        i.Projector = function() {
            console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
            this.projectVector = function(t, e) {
                console.warn("THREE.Projector: .projectVector() is now vector.project()."),
                t.project(e)
            }
            ,
            this.unprojectVector = function(t, e) {
                console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
                t.unproject(e)
            }
            ,
            this.pickingRay = function(t, e) {
                console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
            }
        }
        ,
        i.CanvasRenderer = function() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),
            this.domElement = document.createElement("canvas"),
            this.clear = function() {}
            ,
            this.render = function() {}
            ,
            this.setClearColor = function() {}
            ,
            this.setSize = function() {}
        }
        ,
        i.MeshFaceMaterial = i.MultiMaterial,
        i.CurveUtils = {
            tangentQuadraticBezier: function(t, e, r, i) {
                return 2 * (1 - t) * (r - e) + 2 * t * (i - r)
            },
            tangentCubicBezier: function(t, e, r, i, n) {
                return -3 * e * (1 - t) * (1 - t) + 3 * r * (1 - t) * (1 - t) - 6 * t * r * (1 - t) + 6 * t * i * (1 - t) - 3 * t * t * i + 3 * t * t * n
            },
            tangentSpline: function(t, e, r, i, n) {
                var o = 6 * t * t - 6 * t
                  , a = 3 * t * t - 4 * t + 1
                  , s = -6 * t * t + 6 * t
                  , h = 3 * t * t - 2 * t;
                return o + a + s + h
            },
            interpolate: function(t, e, r, i, n) {
                var o = .5 * (r - t)
                  , a = .5 * (i - e)
                  , s = n * n
                  , h = n * s;
                return (2 * e - 2 * r + o + a) * h + (-3 * e + 3 * r - 2 * o - a) * s + o * n + e
            }
        },
        i.SceneUtils = {
            createMultiMaterialObject: function(t, e) {
                for (var r = new i.Group, n = 0, o = e.length; n < o; n++)
                    r.add(new i.Mesh(t,e[n]));
                return r
            },
            detach: function(t, e, r) {
                t.applyMatrix(e.matrixWorld),
                e.remove(t),
                r.add(t)
            },
            attach: function(t, e, r) {
                var n = new i.Matrix4;
                n.getInverse(r.matrixWorld),
                t.applyMatrix(n),
                e.remove(t),
                r.add(t)
            }
        },
        i.ShapeUtils = {
            area: function(t) {
                for (var e = t.length, r = 0, i = e - 1, n = 0; n < e; i = n++)
                    r += t[i].x * t[n].y - t[n].x * t[i].y;
                return .5 * r
            },
            triangulate: function() {
                function t(t, e, r, i, n, o) {
                    var a, s, h, c, l, u, p, d, f;
                    if (s = t[o[e]].x,
                    h = t[o[e]].y,
                    c = t[o[r]].x,
                    l = t[o[r]].y,
                    u = t[o[i]].x,
                    p = t[o[i]].y,
                    Number.EPSILON > (c - s) * (p - h) - (l - h) * (u - s))
                        return !1;
                    var m, g, v, y, x, b, w, _, M, S, E, T, A, L, C;
                    for (m = u - c,
                    g = p - l,
                    v = s - u,
                    y = h - p,
                    x = c - s,
                    b = l - h,
                    a = 0; a < n; a++)
                        if (d = t[o[a]].x,
                        f = t[o[a]].y,
                        !(d === s && f === h || d === c && f === l || d === u && f === p) && (w = d - s,
                        _ = f - h,
                        M = d - c,
                        S = f - l,
                        E = d - u,
                        T = f - p,
                        C = m * S - g * M,
                        A = x * _ - b * w,
                        L = v * T - y * E,
                        C >= -Number.EPSILON && L >= -Number.EPSILON && A >= -Number.EPSILON))
                            return !1;
                    return !0
                }
                return function(e, r) {
                    var n = e.length;
                    if (n < 3)
                        return null;
                    var o, a, s, h = [], c = [], l = [];
                    if (i.ShapeUtils.area(e) > 0)
                        for (a = 0; a < n; a++)
                            c[a] = a;
                    else
                        for (a = 0; a < n; a++)
                            c[a] = n - 1 - a;
                    var u = n
                      , p = 2 * u;
                    for (a = u - 1; u > 2; ) {
                        if (p-- <= 0)
                            return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"),
                            r ? l : h;
                        if (o = a,
                        u <= o && (o = 0),
                        a = o + 1,
                        u <= a && (a = 0),
                        s = a + 1,
                        u <= s && (s = 0),
                        t(e, o, a, s, u, c)) {
                            var d, f, m, g, v;
                            for (d = c[o],
                            f = c[a],
                            m = c[s],
                            h.push([e[d], e[f], e[m]]),
                            l.push([c[o], c[a], c[s]]),
                            g = a,
                            v = a + 1; v < u; g++,
                            v++)
                                c[g] = c[v];
                            u--,
                            p = 2 * u
                        }
                    }
                    return r ? l : h
                }
            }(),
            triangulateShape: function(t, e) {
                function r(t, e, r) {
                    return t.x !== e.x ? t.x < e.x ? t.x <= r.x && r.x <= e.x : e.x <= r.x && r.x <= t.x : t.y < e.y ? t.y <= r.y && r.y <= e.y : e.y <= r.y && r.y <= t.y
                }
                function n(t, e, i, n, o) {
                    var a = e.x - t.x
                      , s = e.y - t.y
                      , h = n.x - i.x
                      , c = n.y - i.y
                      , l = t.x - i.x
                      , u = t.y - i.y
                      , p = s * h - a * c
                      , d = s * l - a * u;
                    if (Math.abs(p) > Number.EPSILON) {
                        var f;
                        if (p > 0) {
                            if (d < 0 || d > p)
                                return [];
                            if (f = c * l - h * u,
                            f < 0 || f > p)
                                return []
                        } else {
                            if (d > 0 || d < p)
                                return [];
                            if (f = c * l - h * u,
                            f > 0 || f < p)
                                return []
                        }
                        if (0 === f)
                            return !o || 0 !== d && d !== p ? [t] : [];
                        if (f === p)
                            return !o || 0 !== d && d !== p ? [e] : [];
                        if (0 === d)
                            return [i];
                        if (d === p)
                            return [n];
                        var m = f / p;
                        return [{
                            x: t.x + m * a,
                            y: t.y + m * s
                        }]
                    }
                    if (0 !== d || c * l !== h * u)
                        return [];
                    var g = 0 === a && 0 === s
                      , v = 0 === h && 0 === c;
                    if (g && v)
                        return t.x !== i.x || t.y !== i.y ? [] : [t];
                    if (g)
                        return r(i, n, t) ? [t] : [];
                    if (v)
                        return r(t, e, i) ? [i] : [];
                    var y, x, b, w, _, M, S, E;
                    return 0 !== a ? (t.x < e.x ? (y = t,
                    b = t.x,
                    x = e,
                    w = e.x) : (y = e,
                    b = e.x,
                    x = t,
                    w = t.x),
                    i.x < n.x ? (_ = i,
                    S = i.x,
                    M = n,
                    E = n.x) : (_ = n,
                    S = n.x,
                    M = i,
                    E = i.x)) : (t.y < e.y ? (y = t,
                    b = t.y,
                    x = e,
                    w = e.y) : (y = e,
                    b = e.y,
                    x = t,
                    w = t.y),
                    i.y < n.y ? (_ = i,
                    S = i.y,
                    M = n,
                    E = n.y) : (_ = n,
                    S = n.y,
                    M = i,
                    E = i.y)),
                    b <= S ? w < S ? [] : w === S ? o ? [] : [_] : w <= E ? [_, x] : [_, M] : b > E ? [] : b === E ? o ? [] : [y] : w <= E ? [y, x] : [y, M]
                }
                function o(t, e, r, i) {
                    var n = e.x - t.x
                      , o = e.y - t.y
                      , a = r.x - t.x
                      , s = r.y - t.y
                      , h = i.x - t.x
                      , c = i.y - t.y
                      , l = n * s - o * a
                      , u = n * c - o * h;
                    if (Math.abs(l) > Number.EPSILON) {
                        var p = h * s - c * a;
                        return l > 0 ? u >= 0 && p >= 0 : u >= 0 || p >= 0
                    }
                    return u > 0
                }
                function a(t, e) {
                    function r(t, e) {
                        var r = y.length - 1
                          , i = t - 1;
                        i < 0 && (i = r);
                        var n = t + 1;
                        n > r && (n = 0);
                        var a = o(y[t], y[i], y[n], s[e]);
                        if (!a)
                            return !1;
                        var h = s.length - 1
                          , c = e - 1;
                        c < 0 && (c = h);
                        var l = e + 1;
                        return l > h && (l = 0),
                        a = o(s[e], s[c], s[l], y[t]),
                        !!a
                    }
                    function i(t, e) {
                        var r, i, o;
                        for (r = 0; r < y.length; r++)
                            if (i = r + 1,
                            i %= y.length,
                            o = n(t, e, y[r], y[i], !0),
                            o.length > 0)
                                return !0;
                        return !1
                    }
                    function a(t, r) {
                        var i, o, a, s, h;
                        for (i = 0; i < x.length; i++)
                            for (o = e[x[i]],
                            a = 0; a < o.length; a++)
                                if (s = a + 1,
                                s %= o.length,
                                h = n(t, r, o[a], o[s], !0),
                                h.length > 0)
                                    return !0;
                        return !1
                    }
                    for (var s, h, c, l, u, p, d, f, m, g, v, y = t.concat(), x = [], b = [], w = 0, _ = e.length; w < _; w++)
                        x.push(w);
                    for (var M = 0, S = 2 * x.length; x.length > 0; ) {
                        if (S--,
                        S < 0) {
                            console.log("Infinite Loop! Holes left:" + x.length + ", Probably Hole outside Shape!");
                            break
                        }
                        for (c = M; c < y.length; c++) {
                            l = y[c],
                            h = -1;
                            for (var w = 0; w < x.length; w++)
                                if (p = x[w],
                                d = l.x + ":" + l.y + ":" + p,
                                void 0 === b[d]) {
                                    s = e[p];
                                    for (var E = 0; E < s.length; E++)
                                        if (u = s[E],
                                        r(c, E) && !i(l, u) && !a(l, u)) {
                                            h = E,
                                            x.splice(w, 1),
                                            f = y.slice(0, c + 1),
                                            m = y.slice(c),
                                            g = s.slice(h),
                                            v = s.slice(0, h + 1),
                                            y = f.concat(g).concat(v).concat(m),
                                            M = c;
                                            break
                                        }
                                    if (h >= 0)
                                        break;
                                    b[d] = !0
                                }
                            if (h >= 0)
                                break
                        }
                    }
                    return y
                }
                for (var s, h, c, l, u, p, d = {}, f = t.concat(), m = 0, g = e.length; m < g; m++)
                    Array.prototype.push.apply(f, e[m]);
                for (s = 0,
                h = f.length; s < h; s++)
                    u = f[s].x + ":" + f[s].y,
                    void 0 !== d[u] && console.warn("THREE.Shape: Duplicate point", u),
                    d[u] = s;
                var v = a(t, e)
                  , y = i.ShapeUtils.triangulate(v, !1);
                for (s = 0,
                h = y.length; s < h; s++)
                    for (l = y[s],
                    c = 0; c < 3; c++)
                        u = l[c].x + ":" + l[c].y,
                        p = d[u],
                        void 0 !== p && (l[c] = p);
                return y.concat()
            },
            isClockWise: function(t) {
                return i.ShapeUtils.area(t) < 0
            },
            b2: function() {
                function t(t, e) {
                    var r = 1 - t;
                    return r * r * e
                }
                function e(t, e) {
                    return 2 * (1 - t) * t * e
                }
                function r(t, e) {
                    return t * t * e
                }
                return function(i, n, o, a) {
                    return t(i, n) + e(i, o) + r(i, a)
                }
            }(),
            b3: function() {
                function t(t, e) {
                    var r = 1 - t;
                    return r * r * r * e
                }
                function e(t, e) {
                    var r = 1 - t;
                    return 3 * r * r * t * e
                }
                function r(t, e) {
                    var r = 1 - t;
                    return 3 * r * t * t * e
                }
                function i(t, e) {
                    return t * t * t * e
                }
                return function(n, o, a, s, h) {
                    return t(n, o) + e(n, a) + r(n, s) + i(n, h)
                }
            }()
        },
        i.Curve = function() {}
        ,
        i.Curve.prototype = {
            constructor: i.Curve,
            getPoint: function(t) {
                return console.warn("THREE.Curve: Warning, getPoint() not implemented!"),
                null
            },
            getPointAt: function(t) {
                var e = this.getUtoTmapping(t);
                return this.getPoint(e)
            },
            getPoints: function(t) {
                t || (t = 5);
                var e, r = [];
                for (e = 0; e <= t; e++)
                    r.push(this.getPoint(e / t));
                return r
            },
            getSpacedPoints: function(t) {
                t || (t = 5);
                var e, r = [];
                for (e = 0; e <= t; e++)
                    r.push(this.getPointAt(e / t));
                return r
            },
            getLength: function() {
                var t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function(t) {
                if (t || (t = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200),
                this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                var e, r, i = [], n = this.getPoint(0), o = 0;
                for (i.push(0),
                r = 1; r <= t; r++)
                    e = this.getPoint(r / t),
                    o += e.distanceTo(n),
                    i.push(o),
                    n = e;
                return this.cacheArcLengths = i,
                i
            },
            updateArcLengths: function() {
                this.needsUpdate = !0,
                this.getLengths()
            },
            getUtoTmapping: function(t, e) {
                var r, i = this.getLengths(), n = 0, o = i.length;
                r = e ? e : t * i[o - 1];
                for (var a, s = 0, h = o - 1; s <= h; )
                    if (n = Math.floor(s + (h - s) / 2),
                    a = i[n] - r,
                    a < 0)
                        s = n + 1;
                    else {
                        if (!(a > 0)) {
                            h = n;
                            break
                        }
                        h = n - 1
                    }
                if (n = h,
                i[n] === r) {
                    var c = n / (o - 1);
                    return c
                }
                var l = i[n]
                  , u = i[n + 1]
                  , p = u - l
                  , d = (r - l) / p
                  , c = (n + d) / (o - 1);
                return c
            },
            getTangent: function(t) {
                var e = 1e-4
                  , r = t - e
                  , i = t + e;
                r < 0 && (r = 0),
                i > 1 && (i = 1);
                var n = this.getPoint(r)
                  , o = this.getPoint(i)
                  , a = o.clone().sub(n);
                return a.normalize()
            },
            getTangentAt: function(t) {
                var e = this.getUtoTmapping(t);
                return this.getTangent(e)
            }
        },
        i.Curve.create = function(t, e) {
            return t.prototype = Object.create(i.Curve.prototype),
            t.prototype.constructor = t,
            t.prototype.getPoint = e,
            t
        }
        ,
        i.CurvePath = function() {
            this.curves = [],
            this.autoClose = !1
        }
        ,
        i.CurvePath.prototype = Object.create(i.Curve.prototype),
        i.CurvePath.prototype.constructor = i.CurvePath,
        i.CurvePath.prototype.add = function(t) {
            this.curves.push(t)
        }
        ,
        i.CurvePath.prototype.closePath = function() {
            var t = this.curves[0].getPoint(0)
              , e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new i.LineCurve(e,t))
        }
        ,
        i.CurvePath.prototype.getPoint = function(t) {
            for (var e = t * this.getLength(), r = this.getCurveLengths(), i = 0; i < r.length; ) {
                if (r[i] >= e) {
                    var n = r[i] - e
                      , o = this.curves[i]
                      , a = 1 - n / o.getLength();
                    return o.getPointAt(a)
                }
                i++
            }
            return null
        }
        ,
        i.CurvePath.prototype.getLength = function() {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        }
        ,
        i.CurvePath.prototype.getCurveLengths = function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var t = [], e = 0, r = 0, i = this.curves.length; r < i; r++)
                e += this.curves[r].getLength(),
                t.push(e);
            return this.cacheLengths = t,
            t
        }
        ,
        i.CurvePath.prototype.createPointsGeometry = function(t) {
            var e = this.getPoints(t);
            return this.createGeometry(e)
        }
        ,
        i.CurvePath.prototype.createSpacedPointsGeometry = function(t) {
            var e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        }
        ,
        i.CurvePath.prototype.createGeometry = function(t) {
            for (var e = new i.Geometry, r = 0, n = t.length; r < n; r++) {
                var o = t[r];
                e.vertices.push(new i.Vector3(o.x,o.y,o.z || 0))
            }
            return e
        }
        ,
        i.Font = function(t) {
            this.data = t
        }
        ,
        i.Font.prototype = {
            constructor: i.Font,
            generateShapes: function(t, e, r) {
                function n(t) {
                    for (var r = String(t).split(""), i = e / a.resolution, n = 0, s = [], h = 0; h < r.length; h++) {
                        var c = o(r[h], i, n);
                        n += c.offset,
                        s.push(c.path)
                    }
                    return s
                }
                function o(t, e, n) {
                    var o = a.glyphs[t] || a.glyphs["?"];
                    if (o) {
                        var s, h, c, l, u, p, d, f, m, g, v, y = new i.Path, x = [], b = i.ShapeUtils.b2, w = i.ShapeUtils.b3;
                        if (o.o)
                            for (var _ = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), M = 0, S = _.length; M < S; ) {
                                var E = _[M++];
                                switch (E) {
                                case "m":
                                    s = _[M++] * e + n,
                                    h = _[M++] * e,
                                    y.moveTo(s, h);
                                    break;
                                case "l":
                                    s = _[M++] * e + n,
                                    h = _[M++] * e,
                                    y.lineTo(s, h);
                                    break;
                                case "q":
                                    if (c = _[M++] * e + n,
                                    l = _[M++] * e,
                                    d = _[M++] * e + n,
                                    f = _[M++] * e,
                                    y.quadraticCurveTo(d, f, c, l),
                                    v = x[x.length - 1]) {
                                        u = v.x,
                                        p = v.y;
                                        for (var T = 1; T <= r; T++) {
                                            var A = T / r;
                                            b(A, u, d, c),
                                            b(A, p, f, l)
                                        }
                                    }
                                    break;
                                case "b":
                                    if (c = _[M++] * e + n,
                                    l = _[M++] * e,
                                    d = _[M++] * e + n,
                                    f = _[M++] * e,
                                    m = _[M++] * e + n,
                                    g = _[M++] * e,
                                    y.bezierCurveTo(d, f, m, g, c, l),
                                    v = x[x.length - 1]) {
                                        u = v.x,
                                        p = v.y;
                                        for (var T = 1; T <= r; T++) {
                                            var A = T / r;
                                            w(A, u, d, m, c),
                                            w(A, p, f, g, l)
                                        }
                                    }
                                }
                            }
                        return {
                            offset: o.ha * e,
                            path: y
                        }
                    }
                }
                void 0 === e && (e = 100),
                void 0 === r && (r = 4);
                for (var a = this.data, s = n(t), h = [], c = 0, l = s.length; c < l; c++)
                    Array.prototype.push.apply(h, s[c].toShapes());
                return h
            }
        },
        i.Path = function(t) {
            i.CurvePath.call(this),
            this.actions = [],
            t && this.fromPoints(t)
        }
        ,
        i.Path.prototype = Object.create(i.CurvePath.prototype),
        i.Path.prototype.constructor = i.Path,
        i.Path.prototype.fromPoints = function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, r = t.length; e < r; e++)
                this.lineTo(t[e].x, t[e].y)
        }
        ,
        i.Path.prototype.moveTo = function(t, e) {
            this.actions.push({
                action: "moveTo",
                args: [t, e]
            })
        }
        ,
        i.Path.prototype.lineTo = function(t, e) {
            var r = this.actions[this.actions.length - 1].args
              , n = r[r.length - 2]
              , o = r[r.length - 1]
              , a = new i.LineCurve(new i.Vector2(n,o),new i.Vector2(t,e));
            this.curves.push(a),
            this.actions.push({
                action: "lineTo",
                args: [t, e]
            })
        }
        ,
        i.Path.prototype.quadraticCurveTo = function(t, e, r, n) {
            var o = this.actions[this.actions.length - 1].args
              , a = o[o.length - 2]
              , s = o[o.length - 1]
              , h = new i.QuadraticBezierCurve(new i.Vector2(a,s),new i.Vector2(t,e),new i.Vector2(r,n));
            this.curves.push(h),
            this.actions.push({
                action: "quadraticCurveTo",
                args: [t, e, r, n]
            })
        }
        ,
        i.Path.prototype.bezierCurveTo = function(t, e, r, n, o, a) {
            var s = this.actions[this.actions.length - 1].args
              , h = s[s.length - 2]
              , c = s[s.length - 1]
              , l = new i.CubicBezierCurve(new i.Vector2(h,c),new i.Vector2(t,e),new i.Vector2(r,n),new i.Vector2(o,a));
            this.curves.push(l),
            this.actions.push({
                action: "bezierCurveTo",
                args: [t, e, r, n, o, a]
            })
        }
        ,
        i.Path.prototype.splineThru = function(t) {
            var e = Array.prototype.slice.call(arguments)
              , r = this.actions[this.actions.length - 1].args
              , n = r[r.length - 2]
              , o = r[r.length - 1]
              , a = [new i.Vector2(n,o)];
            Array.prototype.push.apply(a, t);
            var s = new i.SplineCurve(a);
            this.curves.push(s),
            this.actions.push({
                action: "splineThru",
                args: e
            })
        }
        ,
        i.Path.prototype.arc = function(t, e, r, i, n, o) {
            var a = this.actions[this.actions.length - 1].args
              , s = a[a.length - 2]
              , h = a[a.length - 1];
            this.absarc(t + s, e + h, r, i, n, o)
        }
        ,
        i.Path.prototype.absarc = function(t, e, r, i, n, o) {
            this.absellipse(t, e, r, r, i, n, o)
        }
        ,
        i.Path.prototype.ellipse = function(t, e, r, i, n, o, a, s) {
            var h = this.actions[this.actions.length - 1].args
              , c = h[h.length - 2]
              , l = h[h.length - 1];
            this.absellipse(t + c, e + l, r, i, n, o, a, s)
        }
        ,
        i.Path.prototype.absellipse = function(t, e, r, n, o, a, s, h) {
            var c = [t, e, r, n, o, a, s, h || 0]
              , l = new i.EllipseCurve(t,e,r,n,o,a,s,h);
            this.curves.push(l);
            var u = l.getPoint(1);
            c.push(u.x),
            c.push(u.y),
            this.actions.push({
                action: "ellipse",
                args: c
            })
        }
        ,
        i.Path.prototype.getSpacedPoints = function(t) {
            t || (t = 40);
            for (var e = [], r = 0; r < t; r++)
                e.push(this.getPoint(r / t));
            return this.autoClose && e.push(e[0]),
            e
        }
        ,
        i.Path.prototype.getPoints = function(t) {
            t = t || 12;
            for (var e, r, n, o, a, s, h, c, l, u, p, d = i.ShapeUtils.b2, f = i.ShapeUtils.b3, m = [], g = 0, v = this.actions.length; g < v; g++) {
                var y = this.actions[g]
                  , x = y.action
                  , b = y.args;
                switch (x) {
                case "moveTo":
                    m.push(new i.Vector2(b[0],b[1]));
                    break;
                case "lineTo":
                    m.push(new i.Vector2(b[0],b[1]));
                    break;
                case "quadraticCurveTo":
                    e = b[2],
                    r = b[3],
                    a = b[0],
                    s = b[1],
                    m.length > 0 ? (l = m[m.length - 1],
                    h = l.x,
                    c = l.y) : (l = this.actions[g - 1].args,
                    h = l[l.length - 2],
                    c = l[l.length - 1]);
                    for (var w = 1; w <= t; w++) {
                        var _ = w / t;
                        u = d(_, h, a, e),
                        p = d(_, c, s, r),
                        m.push(new i.Vector2(u,p))
                    }
                    break;
                case "bezierCurveTo":
                    e = b[4],
                    r = b[5],
                    a = b[0],
                    s = b[1],
                    n = b[2],
                    o = b[3],
                    m.length > 0 ? (l = m[m.length - 1],
                    h = l.x,
                    c = l.y) : (l = this.actions[g - 1].args,
                    h = l[l.length - 2],
                    c = l[l.length - 1]);
                    for (var w = 1; w <= t; w++) {
                        var _ = w / t;
                        u = f(_, h, a, n, e),
                        p = f(_, c, s, o, r),
                        m.push(new i.Vector2(u,p))
                    }
                    break;
                case "splineThru":
                    l = this.actions[g - 1].args;
                    var M = new i.Vector2(l[l.length - 2],l[l.length - 1])
                      , S = [M]
                      , E = t * b[0].length;
                    S = S.concat(b[0]);
                    for (var T = new i.SplineCurve(S), w = 1; w <= E; w++)
                        m.push(T.getPointAt(w / E));
                    break;
                case "arc":
                    for (var A, L = b[0], C = b[1], R = b[2], P = b[3], U = b[4], I = !!b[5], D = U - P, O = 2 * t, w = 1; w <= O; w++) {
                        var _ = w / O;
                        I || (_ = 1 - _),
                        A = P + _ * D,
                        u = L + R * Math.cos(A),
                        p = C + R * Math.sin(A),
                        m.push(new i.Vector2(u,p))
                    }
                    break;
                case "ellipse":
                    var A, N, B, L = b[0], C = b[1], F = b[2], k = b[3], P = b[4], U = b[5], I = !!b[6], z = b[7], D = U - P, O = 2 * t;
                    0 !== z && (N = Math.cos(z),
                    B = Math.sin(z));
                    for (var w = 1; w <= O; w++) {
                        var _ = w / O;
                        if (I || (_ = 1 - _),
                        A = P + _ * D,
                        u = L + F * Math.cos(A),
                        p = C + k * Math.sin(A),
                        0 !== z) {
                            var V = u
                              , G = p;
                            u = (V - L) * N - (G - C) * B + L,
                            p = (V - L) * B + (G - C) * N + C
                        }
                        m.push(new i.Vector2(u,p))
                    }
                }
            }
            var j = m[m.length - 1];
            return Math.abs(j.x - m[0].x) < Number.EPSILON && Math.abs(j.y - m[0].y) < Number.EPSILON && m.splice(m.length - 1, 1),
            this.autoClose && m.push(m[0]),
            m
        }
        ,
        i.Path.prototype.toShapes = function(t, e) {
            function r(t) {
                for (var e = [], r = new i.Path, n = 0, o = t.length; n < o; n++) {
                    var a = t[n]
                      , s = a.args
                      , h = a.action;
                    "moveTo" === h && 0 !== r.actions.length && (e.push(r),
                    r = new i.Path),
                    r[h].apply(r, s)
                }
                return 0 !== r.actions.length && e.push(r),
                e
            }
            function n(t) {
                for (var e = [], r = 0, n = t.length; r < n; r++) {
                    var o = t[r]
                      , a = new i.Shape;
                    a.actions = o.actions,
                    a.curves = o.curves,
                    e.push(a)
                }
                return e
            }
            function o(t, e) {
                for (var r = e.length, i = !1, n = r - 1, o = 0; o < r; n = o++) {
                    var a = e[n]
                      , s = e[o]
                      , h = s.x - a.x
                      , c = s.y - a.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (c < 0 && (a = e[o],
                        h = -h,
                        s = e[n],
                        c = -c),
                        t.y < a.y || t.y > s.y)
                            continue;
                        if (t.y === a.y) {
                            if (t.x === a.x)
                                return !0
                        } else {
                            var l = c * (t.x - a.x) - h * (t.y - a.y);
                            if (0 === l)
                                return !0;
                            if (l < 0)
                                continue;
                            i = !i
                        }
                    } else {
                        if (t.y !== a.y)
                            continue;
                        if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x)
                            return !0
                    }
                }
                return i
            }
            var a = i.ShapeUtils.isClockWise
              , s = r(this.actions);
            if (0 === s.length)
                return [];
            if (e === !0)
                return n(s);
            var h, c, l, u = [];
            if (1 === s.length)
                return c = s[0],
                l = new i.Shape,
                l.actions = c.actions,
                l.curves = c.curves,
                u.push(l),
                u;
            var p = !a(s[0].getPoints());
            p = t ? !p : p;
            var d, f = [], m = [], g = [], v = 0;
            m[v] = void 0,
            g[v] = [];
            for (var y = 0, x = s.length; y < x; y++)
                c = s[y],
                d = c.getPoints(),
                h = a(d),
                h = t ? !h : h,
                h ? (!p && m[v] && v++,
                m[v] = {
                    s: new i.Shape,
                    p: d
                },
                m[v].s.actions = c.actions,
                m[v].s.curves = c.curves,
                p && v++,
                g[v] = []) : g[v].push({
                    h: c,
                    p: d[0]
                });
            if (!m[0])
                return n(s);
            if (m.length > 1) {
                for (var b = !1, w = [], _ = 0, M = m.length; _ < M; _++)
                    f[_] = [];
                for (var _ = 0, M = m.length; _ < M; _++)
                    for (var S = g[_], E = 0; E < S.length; E++) {
                        for (var T = S[E], A = !0, L = 0; L < m.length; L++)
                            o(T.p, m[L].p) && (_ !== L && w.push({
                                froms: _,
                                tos: L,
                                hole: E
                            }),
                            A ? (A = !1,
                            f[L].push(T)) : b = !0);
                        A && f[_].push(T)
                    }
                w.length > 0 && (b || (g = f))
            }
            for (var C, y = 0, R = m.length; y < R; y++) {
                l = m[y].s,
                u.push(l),
                C = g[y];
                for (var P = 0, U = C.length; P < U; P++)
                    l.holes.push(C[P].h)
            }
            return u
        }
        ,
        i.Shape = function() {
            i.Path.apply(this, arguments),
            this.holes = []
        }
        ,
        i.Shape.prototype = Object.create(i.Path.prototype),
        i.Shape.prototype.constructor = i.Shape,
        i.Shape.prototype.extrude = function(t) {
            return new i.ExtrudeGeometry(this,t)
        }
        ,
        i.Shape.prototype.makeGeometry = function(t) {
            return new i.ShapeGeometry(this,t)
        }
        ,
        i.Shape.prototype.getPointsHoles = function(t) {
            for (var e = [], r = 0, i = this.holes.length; r < i; r++)
                e[r] = this.holes[r].getPoints(t);
            return e
        }
        ,
        i.Shape.prototype.extractAllPoints = function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        }
        ,
        i.Shape.prototype.extractPoints = function(t) {
            return this.extractAllPoints(t)
        }
        ,
        i.LineCurve = function(t, e) {
            this.v1 = t,
            this.v2 = e
        }
        ,
        i.LineCurve.prototype = Object.create(i.Curve.prototype),
        i.LineCurve.prototype.constructor = i.LineCurve,
        i.LineCurve.prototype.getPoint = function(t) {
            var e = this.v2.clone().sub(this.v1);
            return e.multiplyScalar(t).add(this.v1),
            e
        }
        ,
        i.LineCurve.prototype.getPointAt = function(t) {
            return this.getPoint(t)
        }
        ,
        i.LineCurve.prototype.getTangent = function(t) {
            var e = this.v2.clone().sub(this.v1);
            return e.normalize()
        }
        ,
        i.QuadraticBezierCurve = function(t, e, r) {
            this.v0 = t,
            this.v1 = e,
            this.v2 = r
        }
        ,
        i.QuadraticBezierCurve.prototype = Object.create(i.Curve.prototype),
        i.QuadraticBezierCurve.prototype.constructor = i.QuadraticBezierCurve,
        i.QuadraticBezierCurve.prototype.getPoint = function(t) {
            var e = i.ShapeUtils.b2;
            return new i.Vector2(e(t, this.v0.x, this.v1.x, this.v2.x),e(t, this.v0.y, this.v1.y, this.v2.y))
        }
        ,
        i.QuadraticBezierCurve.prototype.getTangent = function(t) {
            var e = i.CurveUtils.tangentQuadraticBezier;
            return new i.Vector2(e(t, this.v0.x, this.v1.x, this.v2.x),e(t, this.v0.y, this.v1.y, this.v2.y)).normalize()
        }
        ,
        i.CubicBezierCurve = function(t, e, r, i) {
            this.v0 = t,
            this.v1 = e,
            this.v2 = r,
            this.v3 = i
        }
        ,
        i.CubicBezierCurve.prototype = Object.create(i.Curve.prototype),
        i.CubicBezierCurve.prototype.constructor = i.CubicBezierCurve,
        i.CubicBezierCurve.prototype.getPoint = function(t) {
            var e = i.ShapeUtils.b3;
            return new i.Vector2(e(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),e(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
        }
        ,
        i.CubicBezierCurve.prototype.getTangent = function(t) {
            var e = i.CurveUtils.tangentCubicBezier;
            return new i.Vector2(e(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),e(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize()
        }
        ,
        i.SplineCurve = function(t) {
            this.points = void 0 == t ? [] : t
        }
        ,
        i.SplineCurve.prototype = Object.create(i.Curve.prototype),
        i.SplineCurve.prototype.constructor = i.SplineCurve,
        i.SplineCurve.prototype.getPoint = function(t) {
            var e = this.points
              , r = (e.length - 1) * t
              , n = Math.floor(r)
              , o = r - n
              , a = e[0 === n ? n : n - 1]
              , s = e[n]
              , h = e[n > e.length - 2 ? e.length - 1 : n + 1]
              , c = e[n > e.length - 3 ? e.length - 1 : n + 2]
              , l = i.CurveUtils.interpolate;
            return new i.Vector2(l(a.x, s.x, h.x, c.x, o),l(a.y, s.y, h.y, c.y, o))
        }
        ,
        i.EllipseCurve = function(t, e, r, i, n, o, a, s) {
            this.aX = t,
            this.aY = e,
            this.xRadius = r,
            this.yRadius = i,
            this.aStartAngle = n,
            this.aEndAngle = o,
            this.aClockwise = a,
            this.aRotation = s || 0
        }
        ,
        i.EllipseCurve.prototype = Object.create(i.Curve.prototype),
        i.EllipseCurve.prototype.constructor = i.EllipseCurve,
        i.EllipseCurve.prototype.getPoint = function(t) {
            var e = this.aEndAngle - this.aStartAngle;
            e < 0 && (e += 2 * Math.PI),
            e > 2 * Math.PI && (e -= 2 * Math.PI);
            var r;
            r = this.aClockwise === !0 ? this.aEndAngle + (1 - t) * (2 * Math.PI - e) : this.aStartAngle + t * e;
            var n = this.aX + this.xRadius * Math.cos(r)
              , o = this.aY + this.yRadius * Math.sin(r);
            if (0 !== this.aRotation) {
                var a = Math.cos(this.aRotation)
                  , s = Math.sin(this.aRotation)
                  , h = n
                  , c = o;
                n = (h - this.aX) * a - (c - this.aY) * s + this.aX,
                o = (h - this.aX) * s + (c - this.aY) * a + this.aY
            }
            return new i.Vector2(n,o)
        }
        ,
        i.ArcCurve = function(t, e, r, n, o, a) {
            i.EllipseCurve.call(this, t, e, r, r, n, o, a)
        }
        ,
        i.ArcCurve.prototype = Object.create(i.EllipseCurve.prototype),
        i.ArcCurve.prototype.constructor = i.ArcCurve,
        i.LineCurve3 = i.Curve.create(function(t, e) {
            this.v1 = t,
            this.v2 = e
        }, function(t) {
            var e = new i.Vector3;
            return e.subVectors(this.v2, this.v1),
            e.multiplyScalar(t),
            e.add(this.v1),
            e
        }),
        i.QuadraticBezierCurve3 = i.Curve.create(function(t, e, r) {
            this.v0 = t,
            this.v1 = e,
            this.v2 = r
        }, function(t) {
            var e = i.ShapeUtils.b2;
            return new i.Vector3(e(t, this.v0.x, this.v1.x, this.v2.x),e(t, this.v0.y, this.v1.y, this.v2.y),e(t, this.v0.z, this.v1.z, this.v2.z))
        }),
        i.CubicBezierCurve3 = i.Curve.create(function(t, e, r, i) {
            this.v0 = t,
            this.v1 = e,
            this.v2 = r,
            this.v3 = i
        }, function(t) {
            var e = i.ShapeUtils.b3;
            return new i.Vector3(e(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),e(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y),e(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
        }),
        i.SplineCurve3 = i.Curve.create(function(t) {
            console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"),
            this.points = void 0 == t ? [] : t
        }, function(t) {
            var e = this.points
              , r = (e.length - 1) * t
              , n = Math.floor(r)
              , o = r - n
              , a = e[0 == n ? n : n - 1]
              , s = e[n]
              , h = e[n > e.length - 2 ? e.length - 1 : n + 1]
              , c = e[n > e.length - 3 ? e.length - 1 : n + 2]
              , l = i.CurveUtils.interpolate;
            return new i.Vector3(l(a.x, s.x, h.x, c.x, o),l(a.y, s.y, h.y, c.y, o),l(a.z, s.z, h.z, c.z, o))
        }),
        i.CatmullRomCurve3 = function() {
            function t() {}
            var e = new i.Vector3
              , r = new t
              , n = new t
              , o = new t;
            return t.prototype.init = function(t, e, r, i) {
                this.c0 = t,
                this.c1 = r,
                this.c2 = -3 * t + 3 * e - 2 * r - i,
                this.c3 = 2 * t - 2 * e + r + i
            }
            ,
            t.prototype.initNonuniformCatmullRom = function(t, e, r, i, n, o, a) {
                var s = (e - t) / n - (r - t) / (n + o) + (r - e) / o
                  , h = (r - e) / o - (i - e) / (o + a) + (i - r) / a;
                s *= o,
                h *= o,
                this.init(e, r, s, h)
            }
            ,
            t.prototype.initCatmullRom = function(t, e, r, i, n) {
                this.init(e, r, n * (r - t), n * (i - e))
            }
            ,
            t.prototype.calc = function(t) {
                var e = t * t
                  , r = e * t;
                return this.c0 + this.c1 * t + this.c2 * e + this.c3 * r
            }
            ,
            i.Curve.create(function(t) {
                this.points = t || [],
                this.closed = !1
            }, function(t) {
                var a, s, h, c, l = this.points;
                c = l.length,
                c < 2 && console.log("duh, you need at least 2 points"),
                a = (c - (this.closed ? 0 : 1)) * t,
                s = Math.floor(a),
                h = a - s,
                this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / l.length) + 1) * l.length : 0 === h && s === c - 1 && (s = c - 2,
                h = 1);
                var u, p, d, f;
                if (this.closed || s > 0 ? u = l[(s - 1) % c] : (e.subVectors(l[0], l[1]).add(l[0]),
                u = e),
                p = l[s % c],
                d = l[(s + 1) % c],
                this.closed || s + 2 < c ? f = l[(s + 2) % c] : (e.subVectors(l[c - 1], l[c - 2]).add(l[c - 1]),
                f = e),
                void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                    var m = "chordal" === this.type ? .5 : .25
                      , g = Math.pow(u.distanceToSquared(p), m)
                      , v = Math.pow(p.distanceToSquared(d), m)
                      , y = Math.pow(d.distanceToSquared(f), m);
                    v < 1e-4 && (v = 1),
                    g < 1e-4 && (g = v),
                    y < 1e-4 && (y = v),
                    r.initNonuniformCatmullRom(u.x, p.x, d.x, f.x, g, v, y),
                    n.initNonuniformCatmullRom(u.y, p.y, d.y, f.y, g, v, y),
                    o.initNonuniformCatmullRom(u.z, p.z, d.z, f.z, g, v, y)
                } else if ("catmullrom" === this.type) {
                    var x = void 0 !== this.tension ? this.tension : .5;
                    r.initCatmullRom(u.x, p.x, d.x, f.x, x),
                    n.initCatmullRom(u.y, p.y, d.y, f.y, x),
                    o.initCatmullRom(u.z, p.z, d.z, f.z, x)
                }
                var b = new i.Vector3(r.calc(h),n.calc(h),o.calc(h));
                return b
            })
        }(),
        i.ClosedSplineCurve3 = function(t) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."),
            i.CatmullRomCurve3.call(this, t),
            this.type = "catmullrom",
            this.closed = !0
        }
        ,
        i.ClosedSplineCurve3.prototype = Object.create(i.CatmullRomCurve3.prototype),
        i.BoxGeometry = function(t, e, r, n, o, a) {
            function s(t, e, r, n, o, a, s, c) {
                var l, u, p, d = h.widthSegments, f = h.heightSegments, m = o / 2, g = a / 2, v = h.vertices.length;
                "x" === t && "y" === e || "y" === t && "x" === e ? l = "z" : "x" === t && "z" === e || "z" === t && "x" === e ? (l = "y",
                f = h.depthSegments) : ("z" === t && "y" === e || "y" === t && "z" === e) && (l = "x",
                d = h.depthSegments);
                var y = d + 1
                  , x = f + 1
                  , b = o / d
                  , w = a / f
                  , _ = new i.Vector3;
                for (_[l] = s > 0 ? 1 : -1,
                p = 0; p < x; p++)
                    for (u = 0; u < y; u++) {
                        var M = new i.Vector3;
                        M[t] = (u * b - m) * r,
                        M[e] = (p * w - g) * n,
                        M[l] = s,
                        h.vertices.push(M)
                    }
                for (p = 0; p < f; p++)
                    for (u = 0; u < d; u++) {
                        var S = u + y * p
                          , E = u + y * (p + 1)
                          , T = u + 1 + y * (p + 1)
                          , A = u + 1 + y * p
                          , L = new i.Vector2(u / d,1 - p / f)
                          , C = new i.Vector2(u / d,1 - (p + 1) / f)
                          , R = new i.Vector2((u + 1) / d,1 - (p + 1) / f)
                          , P = new i.Vector2((u + 1) / d,1 - p / f)
                          , U = new i.Face3(S + v,E + v,A + v);
                        U.normal.copy(_),
                        U.vertexNormals.push(_.clone(), _.clone(), _.clone()),
                        U.materialIndex = c,
                        h.faces.push(U),
                        h.faceVertexUvs[0].push([L, C, P]),
                        U = new i.Face3(E + v,T + v,A + v),
                        U.normal.copy(_),
                        U.vertexNormals.push(_.clone(), _.clone(), _.clone()),
                        U.materialIndex = c,
                        h.faces.push(U),
                        h.faceVertexUvs[0].push([C.clone(), R, P.clone()])
                    }
            }
            i.Geometry.call(this),
            this.type = "BoxGeometry",
            this.parameters = {
                width: t,
                height: e,
                depth: r,
                widthSegments: n,
                heightSegments: o,
                depthSegments: a
            },
            this.widthSegments = n || 1,
            this.heightSegments = o || 1,
            this.depthSegments = a || 1;
            var h = this
              , c = t / 2
              , l = e / 2
              , u = r / 2;
            s("z", "y", -1, -1, r, e, c, 0),
            s("z", "y", 1, -1, r, e, -c, 1),
            s("x", "z", 1, 1, t, r, l, 2),
            s("x", "z", 1, -1, t, r, -l, 3),
            s("x", "y", 1, -1, t, e, u, 4),
            s("x", "y", -1, -1, t, e, -u, 5),
            this.mergeVertices()
        }
        ,
        i.BoxGeometry.prototype = Object.create(i.Geometry.prototype),
        i.BoxGeometry.prototype.constructor = i.BoxGeometry,
        i.CubeGeometry = i.BoxGeometry,
        i.CircleGeometry = function(t, e, r, n) {
            i.Geometry.call(this),
            this.type = "CircleGeometry",
            this.parameters = {
                radius: t,
                segments: e,
                thetaStart: r,
                thetaLength: n
            },
            this.fromBufferGeometry(new i.CircleBufferGeometry(t,e,r,n))
        }
        ,
        i.CircleGeometry.prototype = Object.create(i.Geometry.prototype),
        i.CircleGeometry.prototype.constructor = i.CircleGeometry,
        i.CircleBufferGeometry = function(t, e, r, n) {
            i.BufferGeometry.call(this),
            this.type = "CircleBufferGeometry",
            this.parameters = {
                radius: t,
                segments: e,
                thetaStart: r,
                thetaLength: n
            },
            t = t || 50,
            e = void 0 !== e ? Math.max(3, e) : 8,
            r = void 0 !== r ? r : 0,
            n = void 0 !== n ? n : 2 * Math.PI;
            var o = e + 2
              , a = new Float32Array(3 * o)
              , s = new Float32Array(3 * o)
              , h = new Float32Array(2 * o);
            s[2] = 1,
            h[0] = .5,
            h[1] = .5;
            for (var c = 0, l = 3, u = 2; c <= e; c++,
            l += 3,
            u += 2) {
                var p = r + c / e * n;
                a[l] = t * Math.cos(p),
                a[l + 1] = t * Math.sin(p),
                s[l + 2] = 1,
                h[u] = (a[l] / t + 1) / 2,
                h[u + 1] = (a[l + 1] / t + 1) / 2
            }
            for (var d = [], l = 1; l <= e; l++)
                d.push(l, l + 1, 0);
            this.setIndex(new i.BufferAttribute(new Uint16Array(d),1)),
            this.addAttribute("position", new i.BufferAttribute(a,3)),
            this.addAttribute("normal", new i.BufferAttribute(s,3)),
            this.addAttribute("uv", new i.BufferAttribute(h,2)),
            this.boundingSphere = new i.Sphere(new i.Vector3,t)
        }
        ,
        i.CircleBufferGeometry.prototype = Object.create(i.BufferGeometry.prototype),
        i.CircleBufferGeometry.prototype.constructor = i.CircleBufferGeometry,
        i.CylinderGeometry = function(t, e, r, n, o, a, s, h) {
            i.Geometry.call(this),
            this.type = "CylinderGeometry",
            this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: r,
                radialSegments: n,
                heightSegments: o,
                openEnded: a,
                thetaStart: s,
                thetaLength: h
            },
            t = void 0 !== t ? t : 20,
            e = void 0 !== e ? e : 20,
            r = void 0 !== r ? r : 100,
            n = n || 8,
            o = o || 1,
            a = void 0 !== a && a,
            s = void 0 !== s ? s : 0,
            h = void 0 !== h ? h : 2 * Math.PI;
            var c, l, u = r / 2, p = [], d = [];
            for (l = 0; l <= o; l++) {
                var f = []
                  , m = []
                  , g = l / o
                  , v = g * (e - t) + t;
                for (c = 0; c <= n; c++) {
                    var y = c / n
                      , x = new i.Vector3;
                    x.x = v * Math.sin(y * h + s),
                    x.y = -g * r + u,
                    x.z = v * Math.cos(y * h + s),
                    this.vertices.push(x),
                    f.push(this.vertices.length - 1),
                    m.push(new i.Vector2(y,1 - g))
                }
                p.push(f),
                d.push(m)
            }
            var b, w, _ = (e - t) / r;
            for (c = 0; c < n; c++)
                for (0 !== t ? (b = this.vertices[p[0][c]].clone(),
                w = this.vertices[p[0][c + 1]].clone()) : (b = this.vertices[p[1][c]].clone(),
                w = this.vertices[p[1][c + 1]].clone()),
                b.setY(Math.sqrt(b.x * b.x + b.z * b.z) * _).normalize(),
                w.setY(Math.sqrt(w.x * w.x + w.z * w.z) * _).normalize(),
                l = 0; l < o; l++) {
                    var M = p[l][c]
                      , S = p[l + 1][c]
                      , E = p[l + 1][c + 1]
                      , T = p[l][c + 1]
                      , A = b.clone()
                      , L = b.clone()
                      , C = w.clone()
                      , R = w.clone()
                      , P = d[l][c].clone()
                      , U = d[l + 1][c].clone()
                      , I = d[l + 1][c + 1].clone()
                      , D = d[l][c + 1].clone();
                    this.faces.push(new i.Face3(M,S,T,[A, L, R])),
                    this.faceVertexUvs[0].push([P, U, D]),
                    this.faces.push(new i.Face3(S,E,T,[L.clone(), C, R.clone()])),
                    this.faceVertexUvs[0].push([U.clone(), I, D.clone()])
                }
            if (a === !1 && t > 0)
                for (this.vertices.push(new i.Vector3(0,u,0)),
                c = 0; c < n; c++) {
                    var M = p[0][c]
                      , S = p[0][c + 1]
                      , E = this.vertices.length - 1
                      , A = new i.Vector3(0,1,0)
                      , L = new i.Vector3(0,1,0)
                      , C = new i.Vector3(0,1,0)
                      , P = d[0][c].clone()
                      , U = d[0][c + 1].clone()
                      , I = new i.Vector2(U.x,0);
                    this.faces.push(new i.Face3(M,S,E,[A, L, C],(void 0),1)),
                    this.faceVertexUvs[0].push([P, U, I])
                }
            if (a === !1 && e > 0)
                for (this.vertices.push(new i.Vector3(0,(-u),0)),
                c = 0; c < n; c++) {
                    var M = p[o][c + 1]
                      , S = p[o][c]
                      , E = this.vertices.length - 1
                      , A = new i.Vector3(0,(-1),0)
                      , L = new i.Vector3(0,(-1),0)
                      , C = new i.Vector3(0,(-1),0)
                      , P = d[o][c + 1].clone()
                      , U = d[o][c].clone()
                      , I = new i.Vector2(U.x,1);
                    this.faces.push(new i.Face3(M,S,E,[A, L, C],(void 0),2)),
                    this.faceVertexUvs[0].push([P, U, I])
                }
            this.computeFaceNormals()
        }
        ,
        i.CylinderGeometry.prototype = Object.create(i.Geometry.prototype),
        i.CylinderGeometry.prototype.constructor = i.CylinderGeometry,
        i.EdgesGeometry = function(t, e) {
            function r(t, e) {
                return t - e
            }
            i.BufferGeometry.call(this),
            e = void 0 !== e ? e : 1;
            var n, o = Math.cos(i.Math.degToRad(e)), a = [0, 0], s = {}, h = ["a", "b", "c"];
            t instanceof i.BufferGeometry ? (n = new i.Geometry,
            n.fromBufferGeometry(t)) : n = t.clone(),
            n.mergeVertices(),
            n.computeFaceNormals();
            for (var c = n.vertices, l = n.faces, u = 0, p = l.length; u < p; u++)
                for (var d = l[u], f = 0; f < 3; f++) {
                    a[0] = d[h[f]],
                    a[1] = d[h[(f + 1) % 3]],
                    a.sort(r);
                    var m = a.toString();
                    void 0 === s[m] ? s[m] = {
                        vert1: a[0],
                        vert2: a[1],
                        face1: u,
                        face2: void 0
                    } : s[m].face2 = u
                }
            var g = [];
            for (var m in s) {
                var v = s[m];
                if (void 0 === v.face2 || l[v.face1].normal.dot(l[v.face2].normal) <= o) {
                    var y = c[v.vert1];
                    g.push(y.x),
                    g.push(y.y),
                    g.push(y.z),
                    y = c[v.vert2],
                    g.push(y.x),
                    g.push(y.y),
                    g.push(y.z)
                }
            }
            this.addAttribute("position", new i.BufferAttribute(new Float32Array(g),3))
        }
        ,
        i.EdgesGeometry.prototype = Object.create(i.BufferGeometry.prototype),
        i.EdgesGeometry.prototype.constructor = i.EdgesGeometry,
        i.ExtrudeGeometry = function(t, e) {
            return "undefined" == typeof t ? void (t = []) : (i.Geometry.call(this),
            this.type = "ExtrudeGeometry",
            t = Array.isArray(t) ? t : [t],
            this.addShapeList(t, e),
            void this.computeFaceNormals())
        }
        ,
        i.ExtrudeGeometry.prototype = Object.create(i.Geometry.prototype),
        i.ExtrudeGeometry.prototype.constructor = i.ExtrudeGeometry,
        i.ExtrudeGeometry.prototype.addShapeList = function(t, e) {
            for (var r = t.length, i = 0; i < r; i++) {
                var n = t[i];
                this.addShape(n, e)
            }
        }
        ,
        i.ExtrudeGeometry.prototype.addShape = function(t, e) {
            function r(t, e, r) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                e.clone().multiplyScalar(r).add(t)
            }
            function n(t, e, r) {
                var n, o, a = 1, s = t.x - e.x, h = t.y - e.y, c = r.x - t.x, l = r.y - t.y, u = s * s + h * h, p = s * l - h * c;
                if (Math.abs(p) > Number.EPSILON) {
                    var d = Math.sqrt(u)
                      , f = Math.sqrt(c * c + l * l)
                      , m = e.x - h / d
                      , g = e.y + s / d
                      , v = r.x - l / f
                      , y = r.y + c / f
                      , x = ((v - m) * l - (y - g) * c) / (s * l - h * c);
                    n = m + s * x - t.x,
                    o = g + h * x - t.y;
                    var b = n * n + o * o;
                    if (b <= 2)
                        return new i.Vector2(n,o);
                    a = Math.sqrt(b / 2)
                } else {
                    var w = !1;
                    s > Number.EPSILON ? c > Number.EPSILON && (w = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (w = !0) : Math.sign(h) === Math.sign(l) && (w = !0),
                    w ? (n = -h,
                    o = s,
                    a = Math.sqrt(u)) : (n = s,
                    o = h,
                    a = Math.sqrt(u / 2))
                }
                return new i.Vector2(n / a,o / a)
            }
            function o() {
                if (b) {
                    var t = 0
                      , e = j * t;
                    for (X = 0; X < H; X++)
                        G = O[X],
                        c(G[2] + e, G[1] + e, G[0] + e);
                    for (t = _ + 2 * x,
                    e = j * t,
                    X = 0; X < H; X++)
                        G = O[X],
                        c(G[0] + e, G[1] + e, G[2] + e)
                } else {
                    for (X = 0; X < H; X++)
                        G = O[X],
                        c(G[2], G[1], G[0]);
                    for (X = 0; X < H; X++)
                        G = O[X],
                        c(G[0] + j * _, G[1] + j * _, G[2] + j * _)
                }
            }
            function a() {
                var t = 0;
                for (s(N, t),
                t += N.length,
                A = 0,
                L = I.length; A < L; A++)
                    T = I[A],
                    s(T, t),
                    t += T.length
            }
            function s(t, e) {
                var r, i;
                for (X = t.length; --X >= 0; ) {
                    r = X,
                    i = X - 1,
                    i < 0 && (i = t.length - 1);
                    var n = 0
                      , o = _ + 2 * x;
                    for (n = 0; n < o; n++) {
                        var a = j * n
                          , s = j * (n + 1)
                          , h = e + r + a
                          , c = e + i + a
                          , u = e + i + s
                          , p = e + r + s;
                        l(h, c, u, p, t, n, o, r, i)
                    }
                }
            }
            function h(t, e, r) {
                C.vertices.push(new i.Vector3(t,e,r))
            }
            function c(t, e, r) {
                t += R,
                e += R,
                r += R,
                C.faces.push(new i.Face3(t,e,r,null,null,0));
                var n = E.generateTopUV(C, t, e, r);
                C.faceVertexUvs[0].push(n)
            }
            function l(t, e, r, n, o, a, s, h, c) {
                t += R,
                e += R,
                r += R,
                n += R,
                C.faces.push(new i.Face3(t,e,n,null,null,1)),
                C.faces.push(new i.Face3(e,r,n,null,null,1));
                var l = E.generateSideWallUV(C, t, e, r, n);
                C.faceVertexUvs[0].push([l[0], l[1], l[3]]),
                C.faceVertexUvs[0].push([l[1], l[2], l[3]])
            }
            var u, p, d, f, m, g = void 0 !== e.amount ? e.amount : 100, v = void 0 !== e.bevelThickness ? e.bevelThickness : 6, y = void 0 !== e.bevelSize ? e.bevelSize : v - 2, x = void 0 !== e.bevelSegments ? e.bevelSegments : 3, b = void 0 === e.bevelEnabled || e.bevelEnabled, w = void 0 !== e.curveSegments ? e.curveSegments : 12, _ = void 0 !== e.steps ? e.steps : 1, M = e.extrudePath, S = !1, E = void 0 !== e.UVGenerator ? e.UVGenerator : i.ExtrudeGeometry.WorldUVGenerator;
            M && (u = M.getSpacedPoints(_),
            S = !0,
            b = !1,
            p = void 0 !== e.frames ? e.frames : new i.TubeGeometry.FrenetFrames(M,_,(!1)),
            d = new i.Vector3,
            f = new i.Vector3,
            m = new i.Vector3),
            b || (x = 0,
            v = 0,
            y = 0);
            var T, A, L, C = this, R = this.vertices.length, P = t.extractPoints(w), U = P.shape, I = P.holes, D = !i.ShapeUtils.isClockWise(U);
            if (D) {
                for (U = U.reverse(),
                A = 0,
                L = I.length; A < L; A++)
                    T = I[A],
                    i.ShapeUtils.isClockWise(T) && (I[A] = T.reverse());
                D = !1
            }
            var O = i.ShapeUtils.triangulateShape(U, I)
              , N = U;
            for (A = 0,
            L = I.length; A < L; A++)
                T = I[A],
                U = U.concat(T);
            for (var B, F, k, z, V, G, j = U.length, H = O.length, W = [], X = 0, Y = N.length, q = Y - 1, Z = X + 1; X < Y; X++,
            q++,
            Z++)
                q === Y && (q = 0),
                Z === Y && (Z = 0),
                W[X] = n(N[X], N[q], N[Z]);
            var Q, J = [], K = W.concat();
            for (A = 0,
            L = I.length; A < L; A++) {
                for (T = I[A],
                Q = [],
                X = 0,
                Y = T.length,
                q = Y - 1,
                Z = X + 1; X < Y; X++,
                q++,
                Z++)
                    q === Y && (q = 0),
                    Z === Y && (Z = 0),
                    Q[X] = n(T[X], T[q], T[Z]);
                J.push(Q),
                K = K.concat(Q)
            }
            for (B = 0; B < x; B++) {
                for (k = B / x,
                z = v * (1 - k),
                F = y * Math.sin(k * Math.PI / 2),
                X = 0,
                Y = N.length; X < Y; X++)
                    V = r(N[X], W[X], F),
                    h(V.x, V.y, -z);
                for (A = 0,
                L = I.length; A < L; A++)
                    for (T = I[A],
                    Q = J[A],
                    X = 0,
                    Y = T.length; X < Y; X++)
                        V = r(T[X], Q[X], F),
                        h(V.x, V.y, -z)
            }
            for (F = y,
            X = 0; X < j; X++)
                V = b ? r(U[X], K[X], F) : U[X],
                S ? (f.copy(p.normals[0]).multiplyScalar(V.x),
                d.copy(p.binormals[0]).multiplyScalar(V.y),
                m.copy(u[0]).add(f).add(d),
                h(m.x, m.y, m.z)) : h(V.x, V.y, 0);
            var $;
            for ($ = 1; $ <= _; $++)
                for (X = 0; X < j; X++)
                    V = b ? r(U[X], K[X], F) : U[X],
                    S ? (f.copy(p.normals[$]).multiplyScalar(V.x),
                    d.copy(p.binormals[$]).multiplyScalar(V.y),
                    m.copy(u[$]).add(f).add(d),
                    h(m.x, m.y, m.z)) : h(V.x, V.y, g / _ * $);
            for (B = x - 1; B >= 0; B--) {
                for (k = B / x,
                z = v * (1 - k),
                F = y * Math.sin(k * Math.PI / 2),
                X = 0,
                Y = N.length; X < Y; X++)
                    V = r(N[X], W[X], F),
                    h(V.x, V.y, g + z);
                for (A = 0,
                L = I.length; A < L; A++)
                    for (T = I[A],
                    Q = J[A],
                    X = 0,
                    Y = T.length; X < Y; X++)
                        V = r(T[X], Q[X], F),
                        S ? h(V.x, V.y + u[_ - 1].y, u[_ - 1].x + z) : h(V.x, V.y, g + z)
            }
            o(),
            a()
        }
        ,
        i.ExtrudeGeometry.WorldUVGenerator = {
            generateTopUV: function(t, e, r, n) {
                var o = t.vertices
                  , a = o[e]
                  , s = o[r]
                  , h = o[n];
                return [new i.Vector2(a.x,a.y), new i.Vector2(s.x,s.y), new i.Vector2(h.x,h.y)]
            },
            generateSideWallUV: function(t, e, r, n, o) {
                var a = t.vertices
                  , s = a[e]
                  , h = a[r]
                  , c = a[n]
                  , l = a[o];
                return Math.abs(s.y - h.y) < .01 ? [new i.Vector2(s.x,1 - s.z), new i.Vector2(h.x,1 - h.z), new i.Vector2(c.x,1 - c.z), new i.Vector2(l.x,1 - l.z)] : [new i.Vector2(s.y,1 - s.z), new i.Vector2(h.y,1 - h.z), new i.Vector2(c.y,1 - c.z), new i.Vector2(l.y,1 - l.z)]
            }
        },
        i.ShapeGeometry = function(t, e) {
            i.Geometry.call(this),
            this.type = "ShapeGeometry",
            Array.isArray(t) === !1 && (t = [t]),
            this.addShapeList(t, e),
            this.computeFaceNormals()
        }
        ,
        i.ShapeGeometry.prototype = Object.create(i.Geometry.prototype),
        i.ShapeGeometry.prototype.constructor = i.ShapeGeometry,
        i.ShapeGeometry.prototype.addShapeList = function(t, e) {
            for (var r = 0, i = t.length; r < i; r++)
                this.addShape(t[r], e);
            return this
        }
        ,
        i.ShapeGeometry.prototype.addShape = function(t, e) {
            void 0 === e && (e = {});
            var r, n, o, a = void 0 !== e.curveSegments ? e.curveSegments : 12, s = e.material, h = void 0 === e.UVGenerator ? i.ExtrudeGeometry.WorldUVGenerator : e.UVGenerator, c = this.vertices.length, l = t.extractPoints(a), u = l.shape, p = l.holes, d = !i.ShapeUtils.isClockWise(u);
            if (d) {
                for (u = u.reverse(),
                r = 0,
                n = p.length; r < n; r++)
                    o = p[r],
                    i.ShapeUtils.isClockWise(o) && (p[r] = o.reverse());
                d = !1
            }
            var f = i.ShapeUtils.triangulateShape(u, p);
            for (r = 0,
            n = p.length; r < n; r++)
                o = p[r],
                u = u.concat(o);
            var m, g, v = u.length, y = f.length;
            for (r = 0; r < v; r++)
                m = u[r],
                this.vertices.push(new i.Vector3(m.x,m.y,0));
            for (r = 0; r < y; r++) {
                g = f[r];
                var x = g[0] + c
                  , b = g[1] + c
                  , w = g[2] + c;
                this.faces.push(new i.Face3(x,b,w,null,null,s)),
                this.faceVertexUvs[0].push(h.generateTopUV(this, x, b, w))
            }
        }
        ,
        i.LatheGeometry = function(t, e, r, n) {
            i.Geometry.call(this),
            this.type = "LatheGeometry",
            this.parameters = {
                points: t,
                segments: e,
                phiStart: r,
                phiLength: n
            },
            e = e || 12,
            r = r || 0,
            n = n || 2 * Math.PI;
            for (var o = 1 / (t.length - 1), a = 1 / e, s = 0, h = e; s <= h; s++)
                for (var c = r + s * a * n, l = Math.sin(c), u = Math.cos(c), p = 0, d = t.length; p < d; p++) {
                    var f = t[p]
                      , m = new i.Vector3;
                    m.x = f.x * l,
                    m.y = f.y,
                    m.z = f.x * u,
                    this.vertices.push(m)
                }
            for (var g = t.length, s = 0, h = e; s < h; s++)
                for (var p = 0, d = t.length - 1; p < d; p++) {
                    var v = p + g * s
                      , y = v
                      , x = v + g
                      , b = v + 1 + g
                      , w = v + 1
                      , _ = s * a
                      , M = p * o
                      , S = _ + a
                      , E = M + o;
                    this.faces.push(new i.Face3(y,x,w)),
                    this.faceVertexUvs[0].push([new i.Vector2(_,M), new i.Vector2(S,M), new i.Vector2(_,E)]),
                    this.faces.push(new i.Face3(x,b,w)),
                    this.faceVertexUvs[0].push([new i.Vector2(S,M), new i.Vector2(S,E), new i.Vector2(_,E)])
                }
            this.mergeVertices(),
            this.computeFaceNormals(),
            this.computeVertexNormals()
        }
        ,
        i.LatheGeometry.prototype = Object.create(i.Geometry.prototype),
        i.LatheGeometry.prototype.constructor = i.LatheGeometry,
        i.PlaneGeometry = function(t, e, r, n) {
            i.Geometry.call(this),
            this.type = "PlaneGeometry",
            this.parameters = {
                width: t,
                height: e,
                widthSegments: r,
                heightSegments: n
            },
            this.fromBufferGeometry(new i.PlaneBufferGeometry(t,e,r,n))
        }
        ,
        i.PlaneGeometry.prototype = Object.create(i.Geometry.prototype),
        i.PlaneGeometry.prototype.constructor = i.PlaneGeometry,
        i.PlaneBufferGeometry = function(t, e, r, n) {
            i.BufferGeometry.call(this),
            this.type = "PlaneBufferGeometry",
            this.parameters = {
                width: t,
                height: e,
                widthSegments: r,
                heightSegments: n
            };
            for (var o = t / 2, a = e / 2, s = Math.floor(r) || 1, h = Math.floor(n) || 1, c = s + 1, l = h + 1, u = t / s, p = e / h, d = new Float32Array(c * l * 3), f = new Float32Array(c * l * 3), m = new Float32Array(c * l * 2), g = 0, v = 0, y = 0; y < l; y++)
                for (var x = y * p - a, b = 0; b < c; b++) {
                    var w = b * u - o;
                    d[g] = w,
                    d[g + 1] = -x,
                    f[g + 2] = 1,
                    m[v] = b / s,
                    m[v + 1] = 1 - y / h,
                    g += 3,
                    v += 2
                }
            g = 0;
            for (var _ = new (d.length / 3 > 65535 ? Uint32Array : Uint16Array)(s * h * 6), y = 0; y < h; y++)
                for (var b = 0; b < s; b++) {
                    var M = b + c * y
                      , S = b + c * (y + 1)
                      , E = b + 1 + c * (y + 1)
                      , T = b + 1 + c * y;
                    _[g] = M,
                    _[g + 1] = S,
                    _[g + 2] = T,
                    _[g + 3] = S,
                    _[g + 4] = E,
                    _[g + 5] = T,
                    g += 6
                }
            this.setIndex(new i.BufferAttribute(_,1)),
            this.addAttribute("position", new i.BufferAttribute(d,3)),
            this.addAttribute("normal", new i.BufferAttribute(f,3)),
            this.addAttribute("uv", new i.BufferAttribute(m,2))
        }
        ,
        i.PlaneBufferGeometry.prototype = Object.create(i.BufferGeometry.prototype),
        i.PlaneBufferGeometry.prototype.constructor = i.PlaneBufferGeometry,
        i.RingGeometry = function(t, e, r, n, o, a) {
            i.Geometry.call(this),
            this.type = "RingGeometry",
            this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: r,
                phiSegments: n,
                thetaStart: o,
                thetaLength: a
            },
            t = t || 0,
            e = e || 50,
            o = void 0 !== o ? o : 0,
            a = void 0 !== a ? a : 2 * Math.PI,
            r = void 0 !== r ? Math.max(3, r) : 8,
            n = void 0 !== n ? Math.max(1, n) : 8;
            var s, h, c = [], l = t, u = (e - t) / n;
            for (s = 0; s < n + 1; s++) {
                for (h = 0; h < r + 1; h++) {
                    var p = new i.Vector3
                      , d = o + h / r * a;
                    p.x = l * Math.cos(d),
                    p.y = l * Math.sin(d),
                    this.vertices.push(p),
                    c.push(new i.Vector2((p.x / e + 1) / 2,(p.y / e + 1) / 2))
                }
                l += u
            }
            var f = new i.Vector3(0,0,1);
            for (s = 0; s < n; s++) {
                var m = s * (r + 1);
                for (h = 0; h < r; h++) {
                    var d = h + m
                      , g = d
                      , v = d + r + 1
                      , y = d + r + 2;
                    this.faces.push(new i.Face3(g,v,y,[f.clone(), f.clone(), f.clone()])),
                    this.faceVertexUvs[0].push([c[g].clone(), c[v].clone(), c[y].clone()]),
                    g = d,
                    v = d + r + 2,
                    y = d + 1,
                    this.faces.push(new i.Face3(g,v,y,[f.clone(), f.clone(), f.clone()])),
                    this.faceVertexUvs[0].push([c[g].clone(), c[v].clone(), c[y].clone()])
                }
            }
            this.computeFaceNormals(),
            this.boundingSphere = new i.Sphere(new i.Vector3,l)
        }
        ,
        i.RingGeometry.prototype = Object.create(i.Geometry.prototype),
        i.RingGeometry.prototype.constructor = i.RingGeometry,
        i.SphereGeometry = function(t, e, r, n, o, a, s) {
            i.Geometry.call(this),
            this.type = "SphereGeometry",
            this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: r,
                phiStart: n,
                phiLength: o,
                thetaStart: a,
                thetaLength: s
            },
            this.fromBufferGeometry(new i.SphereBufferGeometry(t,e,r,n,o,a,s))
        }
        ,
        i.SphereGeometry.prototype = Object.create(i.Geometry.prototype),
        i.SphereGeometry.prototype.constructor = i.SphereGeometry,
        i.SphereBufferGeometry = function(t, e, r, n, o, a, s) {
            i.BufferGeometry.call(this),
            this.type = "SphereBufferGeometry",
            this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: r,
                phiStart: n,
                phiLength: o,
                thetaStart: a,
                thetaLength: s
            },
            t = t || 50,
            e = Math.max(3, Math.floor(e) || 8),
            r = Math.max(2, Math.floor(r) || 6),
            n = void 0 !== n ? n : 0,
            o = void 0 !== o ? o : 2 * Math.PI,
            a = void 0 !== a ? a : 0,
            s = void 0 !== s ? s : Math.PI;
            for (var h = a + s, c = (e + 1) * (r + 1), l = new i.BufferAttribute(new Float32Array(3 * c),3), u = new i.BufferAttribute(new Float32Array(3 * c),3), p = new i.BufferAttribute(new Float32Array(2 * c),2), d = 0, f = [], m = new i.Vector3, g = 0; g <= r; g++) {
                for (var v = [], y = g / r, x = 0; x <= e; x++) {
                    var b = x / e
                      , w = -t * Math.cos(n + b * o) * Math.sin(a + y * s)
                      , _ = t * Math.cos(a + y * s)
                      , M = t * Math.sin(n + b * o) * Math.sin(a + y * s);
                    m.set(w, _, M).normalize(),
                    l.setXYZ(d, w, _, M),
                    u.setXYZ(d, m.x, m.y, m.z),
                    p.setXY(d, b, 1 - y),
                    v.push(d),
                    d++
                }
                f.push(v)
            }
            for (var S = [], g = 0; g < r; g++)
                for (var x = 0; x < e; x++) {
                    var E = f[g][x + 1]
                      , T = f[g][x]
                      , A = f[g + 1][x]
                      , L = f[g + 1][x + 1];
                    (0 !== g || a > 0) && S.push(E, T, L),
                    (g !== r - 1 || h < Math.PI) && S.push(T, A, L)
                }
            this.setIndex(new (l.count > 65535 ? i.Uint32Attribute : i.Uint16Attribute)(S,1)),
            this.addAttribute("position", l),
            this.addAttribute("normal", u),
            this.addAttribute("uv", p),
            this.boundingSphere = new i.Sphere(new i.Vector3,t)
        }
        ,
        i.SphereBufferGeometry.prototype = Object.create(i.BufferGeometry.prototype),
        i.SphereBufferGeometry.prototype.constructor = i.SphereBufferGeometry,
        i.TextGeometry = function(t, e) {
            e = e || {};
            var r = e.font;
            if (r instanceof i.Font == !1)
                return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
                new i.Geometry;
            var n = r.generateShapes(t, e.size, e.curveSegments);
            e.amount = void 0 !== e.height ? e.height : 50,
            void 0 === e.bevelThickness && (e.bevelThickness = 10),
            void 0 === e.bevelSize && (e.bevelSize = 8),
            void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
            i.ExtrudeGeometry.call(this, n, e),
            this.type = "TextGeometry"
        }
        ,
        i.TextGeometry.prototype = Object.create(i.ExtrudeGeometry.prototype),
        i.TextGeometry.prototype.constructor = i.TextGeometry,
        i.TorusGeometry = function(t, e, r, n, o) {
            i.Geometry.call(this),
            this.type = "TorusGeometry",
            this.parameters = {
                radius: t,
                tube: e,
                radialSegments: r,
                tubularSegments: n,
                arc: o
            },
            t = t || 100,
            e = e || 40,
            r = r || 8,
            n = n || 6,
            o = o || 2 * Math.PI;
            for (var a = new i.Vector3, s = [], h = [], c = 0; c <= r; c++)
                for (var l = 0; l <= n; l++) {
                    var u = l / n * o
                      , p = c / r * Math.PI * 2;
                    a.x = t * Math.cos(u),
                    a.y = t * Math.sin(u);
                    var d = new i.Vector3;
                    d.x = (t + e * Math.cos(p)) * Math.cos(u),
                    d.y = (t + e * Math.cos(p)) * Math.sin(u),
                    d.z = e * Math.sin(p),
                    this.vertices.push(d),
                    s.push(new i.Vector2(l / n,c / r)),
                    h.push(d.clone().sub(a).normalize())
                }
            for (var c = 1; c <= r; c++)
                for (var l = 1; l <= n; l++) {
                    var f = (n + 1) * c + l - 1
                      , m = (n + 1) * (c - 1) + l - 1
                      , g = (n + 1) * (c - 1) + l
                      , v = (n + 1) * c + l
                      , y = new i.Face3(f,m,v,[h[f].clone(), h[m].clone(), h[v].clone()]);
                    this.faces.push(y),
                    this.faceVertexUvs[0].push([s[f].clone(), s[m].clone(), s[v].clone()]),
                    y = new i.Face3(m,g,v,[h[m].clone(), h[g].clone(), h[v].clone()]),
                    this.faces.push(y),
                    this.faceVertexUvs[0].push([s[m].clone(), s[g].clone(), s[v].clone()])
                }
            this.computeFaceNormals()
        }
        ,
        i.TorusGeometry.prototype = Object.create(i.Geometry.prototype),
        i.TorusGeometry.prototype.constructor = i.TorusGeometry,
        i.TorusKnotGeometry = function(t, e, r, n, o, a, s) {
            function h(t, e, r, n, o) {
                var a = Math.cos(t)
                  , s = Math.sin(t)
                  , h = e / r * t
                  , c = Math.cos(h)
                  , l = n * (2 + c) * .5 * a
                  , u = n * (2 + c) * s * .5
                  , p = o * n * Math.sin(h) * .5;
                return new i.Vector3(l,u,p)
            }
            i.Geometry.call(this),
            this.type = "TorusKnotGeometry",
            this.parameters = {
                radius: t,
                tube: e,
                radialSegments: r,
                tubularSegments: n,
                p: o,
                q: a,
                heightScale: s
            },
            t = t || 100,
            e = e || 40,
            r = r || 64,
            n = n || 8,
            o = o || 2,
            a = a || 3,
            s = s || 1;
            for (var c = new Array(r), l = new i.Vector3, u = new i.Vector3, p = new i.Vector3, d = 0; d < r; ++d) {
                c[d] = new Array(n);
                var f = d / r * 2 * o * Math.PI
                  , m = h(f, a, o, t, s)
                  , g = h(f + .01, a, o, t, s);
                l.subVectors(g, m),
                u.addVectors(g, m),
                p.crossVectors(l, u),
                u.crossVectors(p, l),
                p.normalize(),
                u.normalize();
                for (var v = 0; v < n; ++v) {
                    var y = v / n * 2 * Math.PI
                      , x = -e * Math.cos(y)
                      , b = e * Math.sin(y)
                      , w = new i.Vector3;
                    w.x = m.x + x * u.x + b * p.x,
                    w.y = m.y + x * u.y + b * p.y,
                    w.z = m.z + x * u.z + b * p.z,
                    c[d][v] = this.vertices.push(w) - 1
                }
            }
            for (var d = 0; d < r; ++d)
                for (var v = 0; v < n; ++v) {
                    var _ = (d + 1) % r
                      , M = (v + 1) % n
                      , S = c[d][v]
                      , E = c[_][v]
                      , T = c[_][M]
                      , A = c[d][M]
                      , L = new i.Vector2(d / r,v / n)
                      , C = new i.Vector2((d + 1) / r,v / n)
                      , R = new i.Vector2((d + 1) / r,(v + 1) / n)
                      , P = new i.Vector2(d / r,(v + 1) / n);
                    this.faces.push(new i.Face3(S,E,A)),
                    this.faceVertexUvs[0].push([L, C, P]),
                    this.faces.push(new i.Face3(E,T,A)),
                    this.faceVertexUvs[0].push([C.clone(), R, P.clone()])
                }
            this.computeFaceNormals(),
            this.computeVertexNormals()
        }
        ,
        i.TorusKnotGeometry.prototype = Object.create(i.Geometry.prototype),
        i.TorusKnotGeometry.prototype.constructor = i.TorusKnotGeometry,
        i.TubeGeometry = function(t, e, r, n, o, a) {
            function s(t, e, r) {
                return R.vertices.push(new i.Vector3(t,e,r)) - 1
            }
            i.Geometry.call(this),
            this.type = "TubeGeometry",
            this.parameters = {
                path: t,
                segments: e,
                radius: r,
                radialSegments: n,
                closed: o,
                taper: a
            },
            e = e || 64,
            r = r || 1,
            n = n || 8,
            o = o || !1,
            a = a || i.TubeGeometry.NoTaper;
            var h, c, l, u, p, d, f, m, g, v, y, x, b, w, _, M, S, E, T, A, L, C = [], R = this, P = e + 1, U = new i.Vector3, I = new i.TubeGeometry.FrenetFrames(t,e,o), D = I.tangents, O = I.normals, N = I.binormals;
            for (this.tangents = D,
            this.normals = O,
            this.binormals = N,
            v = 0; v < P; v++)
                for (C[v] = [],
                u = v / (P - 1),
                g = t.getPointAt(u),
                h = D[v],
                c = O[v],
                l = N[v],
                d = r * a(u),
                y = 0; y < n; y++)
                    p = y / n * 2 * Math.PI,
                    f = -d * Math.cos(p),
                    m = d * Math.sin(p),
                    U.copy(g),
                    U.x += f * c.x + m * l.x,
                    U.y += f * c.y + m * l.y,
                    U.z += f * c.z + m * l.z,
                    C[v][y] = s(U.x, U.y, U.z);
            for (v = 0; v < e; v++)
                for (y = 0; y < n; y++)
                    x = o ? (v + 1) % e : v + 1,
                    b = (y + 1) % n,
                    w = C[v][y],
                    _ = C[x][y],
                    M = C[x][b],
                    S = C[v][b],
                    E = new i.Vector2(v / e,y / n),
                    T = new i.Vector2((v + 1) / e,y / n),
                    A = new i.Vector2((v + 1) / e,(y + 1) / n),
                    L = new i.Vector2(v / e,(y + 1) / n),
                    this.faces.push(new i.Face3(w,_,S)),
                    this.faceVertexUvs[0].push([E, T, L]),
                    this.faces.push(new i.Face3(_,M,S)),
                    this.faceVertexUvs[0].push([T.clone(), A, L.clone()]);
            this.computeFaceNormals(),
            this.computeVertexNormals()
        }
        ,
        i.TubeGeometry.prototype = Object.create(i.Geometry.prototype),
        i.TubeGeometry.prototype.constructor = i.TubeGeometry,
        i.TubeGeometry.NoTaper = function(t) {
            return 1
        }
        ,
        i.TubeGeometry.SinusoidalTaper = function(t) {
            return Math.sin(Math.PI * t)
        }
        ,
        i.TubeGeometry.FrenetFrames = function(t, e, r) {
            function n() {
                f[0] = new i.Vector3,
                m[0] = new i.Vector3,
                a = Number.MAX_VALUE,
                s = Math.abs(d[0].x),
                h = Math.abs(d[0].y),
                c = Math.abs(d[0].z),
                s <= a && (a = s,
                p.set(1, 0, 0)),
                h <= a && (a = h,
                p.set(0, 1, 0)),
                c <= a && p.set(0, 0, 1),
                g.crossVectors(d[0], p).normalize(),
                f[0].crossVectors(d[0], g),
                m[0].crossVectors(d[0], f[0])
            }
            var o, a, s, h, c, l, u, p = new i.Vector3, d = [], f = [], m = [], g = new i.Vector3, v = new i.Matrix4, y = e + 1;
            for (this.tangents = d,
            this.normals = f,
            this.binormals = m,
            l = 0; l < y; l++)
                u = l / (y - 1),
                d[l] = t.getTangentAt(u),
                d[l].normalize();
            for (n(),
            l = 1; l < y; l++)
                f[l] = f[l - 1].clone(),
                m[l] = m[l - 1].clone(),
                g.crossVectors(d[l - 1], d[l]),
                g.length() > Number.EPSILON && (g.normalize(),
                o = Math.acos(i.Math.clamp(d[l - 1].dot(d[l]), -1, 1)),
                f[l].applyMatrix4(v.makeRotationAxis(g, o))),
                m[l].crossVectors(d[l], f[l]);
            if (r)
                for (o = Math.acos(i.Math.clamp(f[0].dot(f[y - 1]), -1, 1)),
                o /= y - 1,
                d[0].dot(g.crossVectors(f[0], f[y - 1])) > 0 && (o = -o),
                l = 1; l < y; l++)
                    f[l].applyMatrix4(v.makeRotationAxis(d[l], o * l)),
                    m[l].crossVectors(d[l], f[l])
        }
        ,
        i.PolyhedronGeometry = function(t, e, r, n) {
            function o(t) {
                var e = t.normalize().clone();
                e.index = u.vertices.push(e) - 1;
                var r = h(t) / 2 / Math.PI + .5
                  , n = c(t) / Math.PI + .5;
                return e.uv = new i.Vector2(r,1 - n),
                e
            }
            function a(t, e, r, n) {
                var o = new i.Face3(t.index,e.index,r.index,[t.clone(), e.clone(), r.clone()],(void 0),n);
                u.faces.push(o),
                b.copy(t).add(e).add(r).divideScalar(3);
                var a = h(b);
                u.faceVertexUvs[0].push([l(t.uv, t, a), l(e.uv, e, a), l(r.uv, r, a)])
            }
            function s(t, e) {
                for (var r = Math.pow(2, e), i = o(u.vertices[t.a]), n = o(u.vertices[t.b]), s = o(u.vertices[t.c]), h = [], c = t.materialIndex, l = 0; l <= r; l++) {
                    h[l] = [];
                    for (var p = o(i.clone().lerp(s, l / r)), d = o(n.clone().lerp(s, l / r)), f = r - l, m = 0; m <= f; m++)
                        0 === m && l === r ? h[l][m] = p : h[l][m] = o(p.clone().lerp(d, m / f))
                }
                for (var l = 0; l < r; l++)
                    for (var m = 0; m < 2 * (r - l) - 1; m++) {
                        var g = Math.floor(m / 2);
                        m % 2 === 0 ? a(h[l][g + 1], h[l + 1][g], h[l][g], c) : a(h[l][g + 1], h[l + 1][g + 1], h[l + 1][g], c)
                    }
            }
            function h(t) {
                return Math.atan2(t.z, -t.x)
            }
            function c(t) {
                return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
            }
            function l(t, e, r) {
                return r < 0 && 1 === t.x && (t = new i.Vector2(t.x - 1,t.y)),
                0 === e.x && 0 === e.z && (t = new i.Vector2(r / 2 / Math.PI + .5,t.y)),
                t.clone()
            }
            i.Geometry.call(this),
            this.type = "PolyhedronGeometry",
            this.parameters = {
                vertices: t,
                indices: e,
                radius: r,
                detail: n
            },
            r = r || 1,
            n = n || 0;
            for (var u = this, p = 0, d = t.length; p < d; p += 3)
                o(new i.Vector3(t[p],t[p + 1],t[p + 2]));
            for (var f = this.vertices, m = [], p = 0, g = 0, d = e.length; p < d; p += 3,
            g++) {
                var v = f[e[p]]
                  , y = f[e[p + 1]]
                  , x = f[e[p + 2]];
                m[g] = new i.Face3(v.index,y.index,x.index,[v.clone(), y.clone(), x.clone()],(void 0),g)
            }
            for (var b = new i.Vector3, p = 0, d = m.length; p < d; p++)
                s(m[p], n);
            for (var p = 0, d = this.faceVertexUvs[0].length; p < d; p++) {
                var w = this.faceVertexUvs[0][p]
                  , _ = w[0].x
                  , M = w[1].x
                  , S = w[2].x
                  , E = Math.max(_, M, S)
                  , T = Math.min(_, M, S);
                E > .9 && T < .1 && (_ < .2 && (w[0].x += 1),
                M < .2 && (w[1].x += 1),
                S < .2 && (w[2].x += 1))
            }
            for (var p = 0, d = this.vertices.length; p < d; p++)
                this.vertices[p].multiplyScalar(r);
            this.mergeVertices(),
            this.computeFaceNormals(),
            this.boundingSphere = new i.Sphere(new i.Vector3,r)
        }
        ,
        i.PolyhedronGeometry.prototype = Object.create(i.Geometry.prototype),
        i.PolyhedronGeometry.prototype.constructor = i.PolyhedronGeometry,
        i.DodecahedronGeometry = function(t, e) {
            var r = (1 + Math.sqrt(5)) / 2
              , n = 1 / r
              , o = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -r, 0, -n, r, 0, n, -r, 0, n, r, -n, -r, 0, -n, r, 0, n, -r, 0, n, r, 0, -r, 0, -n, r, 0, -n, -r, 0, n, r, 0, n]
              , a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
            i.PolyhedronGeometry.call(this, o, a, t, e),
            this.type = "DodecahedronGeometry",
            this.parameters = {
                radius: t,
                detail: e
            }
        }
        ,
        i.DodecahedronGeometry.prototype = Object.create(i.PolyhedronGeometry.prototype),
        i.DodecahedronGeometry.prototype.constructor = i.DodecahedronGeometry,
        i.IcosahedronGeometry = function(t, e) {
            var r = (1 + Math.sqrt(5)) / 2
              , n = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1]
              , o = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
            i.PolyhedronGeometry.call(this, n, o, t, e),
            this.type = "IcosahedronGeometry",
            this.parameters = {
                radius: t,
                detail: e
            }
        }
        ,
        i.IcosahedronGeometry.prototype = Object.create(i.PolyhedronGeometry.prototype),
        i.IcosahedronGeometry.prototype.constructor = i.IcosahedronGeometry,
        i.OctahedronGeometry = function(t, e) {
            var r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
              , n = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
            i.PolyhedronGeometry.call(this, r, n, t, e),
            this.type = "OctahedronGeometry",
            this.parameters = {
                radius: t,
                detail: e
            }
        }
        ,
        i.OctahedronGeometry.prototype = Object.create(i.PolyhedronGeometry.prototype);
        i.OctahedronGeometry.prototype.constructor = i.OctahedronGeometry;
        i.TetrahedronGeometry = function(t, e) {
            var r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
              , n = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
            i.PolyhedronGeometry.call(this, r, n, t, e),
            this.type = "TetrahedronGeometry",
            this.parameters = {
                radius: t,
                detail: e
            }
        }
        ,
        i.TetrahedronGeometry.prototype = Object.create(i.PolyhedronGeometry.prototype),
        i.TetrahedronGeometry.prototype.constructor = i.TetrahedronGeometry,
        i.ParametricGeometry = function(t, e, r) {
            i.Geometry.call(this),
            this.type = "ParametricGeometry",
            this.parameters = {
                func: t,
                slices: e,
                stacks: r
            };
            var n, o, a, s, h, c = this.vertices, l = this.faces, u = this.faceVertexUvs[0], p = e + 1;
            for (n = 0; n <= r; n++)
                for (h = n / r,
                o = 0; o <= e; o++)
                    s = o / e,
                    a = t(s, h),
                    c.push(a);
            var d, f, m, g, v, y, x, b;
            for (n = 0; n < r; n++)
                for (o = 0; o < e; o++)
                    d = n * p + o,
                    f = n * p + o + 1,
                    m = (n + 1) * p + o + 1,
                    g = (n + 1) * p + o,
                    v = new i.Vector2(o / e,n / r),
                    y = new i.Vector2((o + 1) / e,n / r),
                    x = new i.Vector2((o + 1) / e,(n + 1) / r),
                    b = new i.Vector2(o / e,(n + 1) / r),
                    l.push(new i.Face3(d,f,g)),
                    u.push([v, y, b]),
                    l.push(new i.Face3(f,m,g)),
                    u.push([y.clone(), x, b.clone()]);
            this.computeFaceNormals(),
            this.computeVertexNormals()
        }
        ,
        i.ParametricGeometry.prototype = Object.create(i.Geometry.prototype),
        i.ParametricGeometry.prototype.constructor = i.ParametricGeometry,
        i.WireframeGeometry = function(t) {
            function e(t, e) {
                return t - e
            }
            i.BufferGeometry.call(this);
            var r = [0, 0]
              , n = {}
              , o = ["a", "b", "c"];
            if (t instanceof i.Geometry) {
                for (var a = t.vertices, s = t.faces, h = 0, c = new Uint32Array(6 * s.length), l = 0, u = s.length; l < u; l++)
                    for (var p = s[l], d = 0; d < 3; d++) {
                        r[0] = p[o[d]],
                        r[1] = p[o[(d + 1) % 3]],
                        r.sort(e);
                        var f = r.toString();
                        void 0 === n[f] && (c[2 * h] = r[0],
                        c[2 * h + 1] = r[1],
                        n[f] = !0,
                        h++)
                    }
                for (var m = new Float32Array(2 * h * 3), l = 0, u = h; l < u; l++)
                    for (var d = 0; d < 2; d++) {
                        var g = a[c[2 * l + d]]
                          , v = 6 * l + 3 * d;
                        m[v + 0] = g.x,
                        m[v + 1] = g.y,
                        m[v + 2] = g.z
                    }
                this.addAttribute("position", new i.BufferAttribute(m,3))
            } else if (t instanceof i.BufferGeometry)
                if (null !== t.index) {
                    var y = t.index.array
                      , a = t.attributes.position
                      , x = t.groups
                      , h = 0;
                    0 === x.length && t.addGroup(0, y.length);
                    for (var c = new Uint32Array(2 * y.length), b = 0, w = x.length; b < w; ++b)
                        for (var _ = x[b], M = _.start, S = _.count, l = M, E = M + S; l < E; l += 3)
                            for (var d = 0; d < 3; d++) {
                                r[0] = y[l + d],
                                r[1] = y[l + (d + 1) % 3],
                                r.sort(e);
                                var f = r.toString();
                                void 0 === n[f] && (c[2 * h] = r[0],
                                c[2 * h + 1] = r[1],
                                n[f] = !0,
                                h++)
                            }
                    for (var m = new Float32Array(2 * h * 3), l = 0, u = h; l < u; l++)
                        for (var d = 0; d < 2; d++) {
                            var v = 6 * l + 3 * d
                              , T = c[2 * l + d];
                            m[v + 0] = a.getX(T),
                            m[v + 1] = a.getY(T),
                            m[v + 2] = a.getZ(T)
                        }
                    this.addAttribute("position", new i.BufferAttribute(m,3))
                } else {
                    for (var a = t.attributes.position.array, h = a.length / 3, A = h / 3, m = new Float32Array(2 * h * 3), l = 0, u = A; l < u; l++)
                        for (var d = 0; d < 3; d++) {
                            var v = 18 * l + 6 * d
                              , L = 9 * l + 3 * d;
                            m[v + 0] = a[L],
                            m[v + 1] = a[L + 1],
                            m[v + 2] = a[L + 2];
                            var T = 9 * l + 3 * ((d + 1) % 3);
                            m[v + 3] = a[T],
                            m[v + 4] = a[T + 1],
                            m[v + 5] = a[T + 2]
                        }
                    this.addAttribute("position", new i.BufferAttribute(m,3))
                }
        }
        ,
        i.WireframeGeometry.prototype = Object.create(i.BufferGeometry.prototype),
        i.WireframeGeometry.prototype.constructor = i.WireframeGeometry,
        i.AxisHelper = function(t) {
            t = t || 1;
            var e = new Float32Array([0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t])
              , r = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1])
              , n = new i.BufferGeometry;
            n.addAttribute("position", new i.BufferAttribute(e,3)),
            n.addAttribute("color", new i.BufferAttribute(r,3));
            var o = new i.LineBasicMaterial({
                vertexColors: i.VertexColors
            });
            i.LineSegments.call(this, n, o)
        }
        ,
        i.AxisHelper.prototype = Object.create(i.LineSegments.prototype),
        i.AxisHelper.prototype.constructor = i.AxisHelper,
        i.ArrowHelper = function() {
            var t = new i.Geometry;
            t.vertices.push(new i.Vector3(0,0,0), new i.Vector3(0,1,0));
            var e = new i.CylinderGeometry(0,.5,1,5,1);
            return e.translate(0, -.5, 0),
            function(r, n, o, a, s, h) {
                i.Object3D.call(this),
                void 0 === a && (a = 16776960),
                void 0 === o && (o = 1),
                void 0 === s && (s = .2 * o),
                void 0 === h && (h = .2 * s),
                this.position.copy(n),
                this.line = new i.Line(t,new i.LineBasicMaterial({
                    color: a
                })),
                this.line.matrixAutoUpdate = !1,
                this.add(this.line),
                this.cone = new i.Mesh(e,new i.MeshBasicMaterial({
                    color: a
                })),
                this.cone.matrixAutoUpdate = !1,
                this.add(this.cone),
                this.setDirection(r),
                this.setLength(o, s, h)
            }
        }(),
        i.ArrowHelper.prototype = Object.create(i.Object3D.prototype),
        i.ArrowHelper.prototype.constructor = i.ArrowHelper,
        i.ArrowHelper.prototype.setDirection = function() {
            var t, e = new i.Vector3;
            return function(r) {
                r.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : r.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(r.z, 0, -r.x).normalize(),
                t = Math.acos(r.y),
                this.quaternion.setFromAxisAngle(e, t))
            }
        }(),
        i.ArrowHelper.prototype.setLength = function(t, e, r) {
            void 0 === e && (e = .2 * t),
            void 0 === r && (r = .2 * e),
            this.line.scale.set(1, Math.max(0, t - e), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(r, e, r),
            this.cone.position.y = t,
            this.cone.updateMatrix()
        }
        ,
        i.ArrowHelper.prototype.setColor = function(t) {
            this.line.material.color.set(t),
            this.cone.material.color.set(t)
        }
        ,
        i.BoxHelper = function(t) {
            var e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
              , r = new Float32Array(24)
              , n = new i.BufferGeometry;
            n.setIndex(new i.BufferAttribute(e,1)),
            n.addAttribute("position", new i.BufferAttribute(r,3)),
            i.LineSegments.call(this, n, new i.LineBasicMaterial({
                color: 16776960
            })),
            void 0 !== t && this.update(t)
        }
        ,
        i.BoxHelper.prototype = Object.create(i.LineSegments.prototype),
        i.BoxHelper.prototype.constructor = i.BoxHelper,
        i.BoxHelper.prototype.update = function() {
            var t = new i.Box3;
            return function(e) {
                if (t.setFromObject(e),
                !t.isEmpty()) {
                    var r = t.min
                      , i = t.max
                      , n = this.geometry.attributes.position
                      , o = n.array;
                    o[0] = i.x,
                    o[1] = i.y,
                    o[2] = i.z,
                    o[3] = r.x,
                    o[4] = i.y,
                    o[5] = i.z,
                    o[6] = r.x,
                    o[7] = r.y,
                    o[8] = i.z,
                    o[9] = i.x,
                    o[10] = r.y,
                    o[11] = i.z,
                    o[12] = i.x,
                    o[13] = i.y,
                    o[14] = r.z,
                    o[15] = r.x,
                    o[16] = i.y,
                    o[17] = r.z,
                    o[18] = r.x,
                    o[19] = r.y,
                    o[20] = r.z,
                    o[21] = i.x,
                    o[22] = r.y,
                    o[23] = r.z,
                    n.needsUpdate = !0,
                    this.geometry.computeBoundingSphere()
                }
            }
        }(),
        i.BoundingBoxHelper = function(t, e) {
            var r = void 0 !== e ? e : 8947848;
            this.object = t,
            this.box = new i.Box3,
            i.Mesh.call(this, new i.BoxGeometry(1,1,1), new i.MeshBasicMaterial({
                color: r,
                wireframe: !0
            }))
        }
        ,
        i.BoundingBoxHelper.prototype = Object.create(i.Mesh.prototype),
        i.BoundingBoxHelper.prototype.constructor = i.BoundingBoxHelper,
        i.BoundingBoxHelper.prototype.update = function() {
            this.box.setFromObject(this.object),
            this.box.size(this.scale),
            this.box.center(this.position)
        }
        ,
        i.CameraHelper = function(t) {
            function e(t, e, i) {
                r(t, i),
                r(e, i)
            }
            function r(t, e) {
                n.vertices.push(new i.Vector3),
                n.colors.push(new i.Color(e)),
                void 0 === a[t] && (a[t] = []),
                a[t].push(n.vertices.length - 1)
            }
            var n = new i.Geometry
              , o = new i.LineBasicMaterial({
                color: 16777215,
                vertexColors: i.FaceColors
            })
              , a = {}
              , s = 16755200
              , h = 16711680
              , c = 43775
              , l = 16777215
              , u = 3355443;
            e("n1", "n2", s),
            e("n2", "n4", s),
            e("n4", "n3", s),
            e("n3", "n1", s),
            e("f1", "f2", s),
            e("f2", "f4", s),
            e("f4", "f3", s),
            e("f3", "f1", s),
            e("n1", "f1", s),
            e("n2", "f2", s),
            e("n3", "f3", s),
            e("n4", "f4", s),
            e("p", "n1", h),
            e("p", "n2", h),
            e("p", "n3", h),
            e("p", "n4", h),
            e("u1", "u2", c),
            e("u2", "u3", c),
            e("u3", "u1", c),
            e("c", "t", l),
            e("p", "c", u),
            e("cn1", "cn2", u),
            e("cn3", "cn4", u),
            e("cf1", "cf2", u),
            e("cf3", "cf4", u),
            i.LineSegments.call(this, n, o),
            this.camera = t,
            this.camera.updateProjectionMatrix(),
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1,
            this.pointMap = a,
            this.update()
        }
        ,
        i.CameraHelper.prototype = Object.create(i.LineSegments.prototype),
        i.CameraHelper.prototype.constructor = i.CameraHelper,
        i.CameraHelper.prototype.update = function() {
            function t(t, i, a, s) {
                n.set(i, a, s).unproject(o);
                var h = r[t];
                if (void 0 !== h)
                    for (var c = 0, l = h.length; c < l; c++)
                        e.vertices[h[c]].copy(n)
            }
            var e, r, n = new i.Vector3, o = new i.Camera;
            return function() {
                e = this.geometry,
                r = this.pointMap;
                var i = 1
                  , n = 1;
                o.projectionMatrix.copy(this.camera.projectionMatrix),
                t("c", 0, 0, -1),
                t("t", 0, 0, 1),
                t("n1", -i, -n, -1),
                t("n2", i, -n, -1),
                t("n3", -i, n, -1),
                t("n4", i, n, -1),
                t("f1", -i, -n, 1),
                t("f2", i, -n, 1),
                t("f3", -i, n, 1),
                t("f4", i, n, 1),
                t("u1", .7 * i, 1.1 * n, -1),
                t("u2", .7 * -i, 1.1 * n, -1),
                t("u3", 0, 2 * n, -1),
                t("cf1", -i, 0, 1),
                t("cf2", i, 0, 1),
                t("cf3", 0, -n, 1),
                t("cf4", 0, n, 1),
                t("cn1", -i, 0, -1),
                t("cn2", i, 0, -1),
                t("cn3", 0, -n, -1),
                t("cn4", 0, n, -1),
                e.verticesNeedUpdate = !0
            }
        }(),
        i.DirectionalLightHelper = function(t, e) {
            i.Object3D.call(this),
            this.light = t,
            this.light.updateMatrixWorld(),
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1,
            e = e || 1;
            var r = new i.Geometry;
            r.vertices.push(new i.Vector3((-e),e,0), new i.Vector3(e,e,0), new i.Vector3(e,(-e),0), new i.Vector3((-e),(-e),0), new i.Vector3((-e),e,0));
            var n = new i.LineBasicMaterial({
                fog: !1
            });
            n.color.copy(this.light.color).multiplyScalar(this.light.intensity),
            this.lightPlane = new i.Line(r,n),
            this.add(this.lightPlane),
            r = new i.Geometry,
            r.vertices.push(new i.Vector3, new i.Vector3),
            n = new i.LineBasicMaterial({
                fog: !1
            }),
            n.color.copy(this.light.color).multiplyScalar(this.light.intensity),
            this.targetLine = new i.Line(r,n),
            this.add(this.targetLine),
            this.update()
        }
        ,
        i.DirectionalLightHelper.prototype = Object.create(i.Object3D.prototype),
        i.DirectionalLightHelper.prototype.constructor = i.DirectionalLightHelper,
        i.DirectionalLightHelper.prototype.dispose = function() {
            this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose()
        }
        ,
        i.DirectionalLightHelper.prototype.update = function() {
            var t = new i.Vector3
              , e = new i.Vector3
              , r = new i.Vector3;
            return function() {
                t.setFromMatrixPosition(this.light.matrixWorld),
                e.setFromMatrixPosition(this.light.target.matrixWorld),
                r.subVectors(e, t),
                this.lightPlane.lookAt(r),
                this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                this.targetLine.geometry.vertices[1].copy(r),
                this.targetLine.geometry.verticesNeedUpdate = !0,
                this.targetLine.material.color.copy(this.lightPlane.material.color)
            }
        }(),
        i.EdgesHelper = function(t, e, r) {
            var n = void 0 !== e ? e : 16777215;
            i.LineSegments.call(this, new i.EdgesGeometry(t.geometry,r), new i.LineBasicMaterial({
                color: n
            })),
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1
        }
        ,
        i.EdgesHelper.prototype = Object.create(i.LineSegments.prototype),
        i.EdgesHelper.prototype.constructor = i.EdgesHelper,
        i.FaceNormalsHelper = function(t, e, r, n) {
            this.object = t,
            this.size = void 0 !== e ? e : 1;
            var o = void 0 !== r ? r : 16776960
              , a = void 0 !== n ? n : 1
              , s = 0
              , h = this.object.geometry;
            h instanceof i.Geometry ? s = h.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
            var c = new i.BufferGeometry
              , l = new i.Float32Attribute(2 * s * 3,3);
            c.addAttribute("position", l),
            i.LineSegments.call(this, c, new i.LineBasicMaterial({
                color: o,
                linewidth: a
            })),
            this.matrixAutoUpdate = !1,
            this.update()
        }
        ,
        i.FaceNormalsHelper.prototype = Object.create(i.LineSegments.prototype),
        i.FaceNormalsHelper.prototype.constructor = i.FaceNormalsHelper,
        i.FaceNormalsHelper.prototype.update = function() {
            var t = new i.Vector3
              , e = new i.Vector3
              , r = new i.Matrix3;
            return function() {
                this.object.updateMatrixWorld(!0),
                r.getNormalMatrix(this.object.matrixWorld);
                for (var i = this.object.matrixWorld, n = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, h = 0, c = 0, l = s.length; c < l; c++) {
                    var u = s[c]
                      , p = u.normal;
                    t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(i),
                    e.copy(p).applyMatrix3(r).normalize().multiplyScalar(this.size).add(t),
                    n.setXYZ(h, t.x, t.y, t.z),
                    h += 1,
                    n.setXYZ(h, e.x, e.y, e.z),
                    h += 1
                }
                return n.needsUpdate = !0,
                this
            }
        }(),
        i.GridHelper = function(t, e) {
            var r = new i.Geometry
              , n = new i.LineBasicMaterial({
                vertexColors: i.VertexColors
            });
            this.color1 = new i.Color(4473924),
            this.color2 = new i.Color(8947848);
            for (var o = -t; o <= t; o += e) {
                r.vertices.push(new i.Vector3((-t),0,o), new i.Vector3(t,0,o), new i.Vector3(o,0,(-t)), new i.Vector3(o,0,t));
                var a = 0 === o ? this.color1 : this.color2;
                r.colors.push(a, a, a, a)
            }
            i.LineSegments.call(this, r, n)
        }
        ,
        i.GridHelper.prototype = Object.create(i.LineSegments.prototype),
        i.GridHelper.prototype.constructor = i.GridHelper,
        i.GridHelper.prototype.setColors = function(t, e) {
            this.color1.set(t),
            this.color2.set(e),
            this.geometry.colorsNeedUpdate = !0
        }
        ,
        i.HemisphereLightHelper = function(t, e) {
            i.Object3D.call(this),
            this.light = t,
            this.light.updateMatrixWorld(),
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1,
            this.colors = [new i.Color, new i.Color];
            var r = new i.SphereGeometry(e,4,2);
            r.rotateX(-Math.PI / 2);
            for (var n = 0, o = 8; n < o; n++)
                r.faces[n].color = this.colors[n < 4 ? 0 : 1];
            var a = new i.MeshBasicMaterial({
                vertexColors: i.FaceColors,
                wireframe: !0
            });
            this.lightSphere = new i.Mesh(r,a),
            this.add(this.lightSphere),
            this.update()
        }
        ,
        i.HemisphereLightHelper.prototype = Object.create(i.Object3D.prototype),
        i.HemisphereLightHelper.prototype.constructor = i.HemisphereLightHelper,
        i.HemisphereLightHelper.prototype.dispose = function() {
            this.lightSphere.geometry.dispose(),
            this.lightSphere.material.dispose()
        }
        ,
        i.HemisphereLightHelper.prototype.update = function() {
            var t = new i.Vector3;
            return function() {
                this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity),
                this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity),
                this.lightSphere.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()),
                this.lightSphere.geometry.colorsNeedUpdate = !0
            }
        }(),
        i.PointLightHelper = function(t, e) {
            this.light = t,
            this.light.updateMatrixWorld();
            var r = new i.SphereGeometry(e,4,2)
              , n = new i.MeshBasicMaterial({
                wireframe: !0,
                fog: !1
            });
            n.color.copy(this.light.color).multiplyScalar(this.light.intensity),
            i.Mesh.call(this, r, n),
            this.matrix = this.light.matrixWorld,
            this.matrixAutoUpdate = !1
        }
        ,
        i.PointLightHelper.prototype = Object.create(i.Mesh.prototype),
        i.PointLightHelper.prototype.constructor = i.PointLightHelper,
        i.PointLightHelper.prototype.dispose = function() {
            this.geometry.dispose(),
            this.material.dispose()
        }
        ,
        i.PointLightHelper.prototype.update = function() {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }
        ,
        i.SkeletonHelper = function(t) {
            this.bones = this.getBoneList(t);
            for (var e = new i.Geometry, r = 0; r < this.bones.length; r++) {
                var n = this.bones[r];
                n.parent instanceof i.Bone && (e.vertices.push(new i.Vector3),
                e.vertices.push(new i.Vector3),
                e.colors.push(new i.Color(0,0,1)),
                e.colors.push(new i.Color(0,1,0)))
            }
            e.dynamic = !0;
            var o = new i.LineBasicMaterial({
                vertexColors: i.VertexColors,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            });
            i.LineSegments.call(this, e, o),
            this.root = t,
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1,
            this.update()
        }
        ,
        i.SkeletonHelper.prototype = Object.create(i.LineSegments.prototype),
        i.SkeletonHelper.prototype.constructor = i.SkeletonHelper,
        i.SkeletonHelper.prototype.getBoneList = function(t) {
            var e = [];
            t instanceof i.Bone && e.push(t);
            for (var r = 0; r < t.children.length; r++)
                e.push.apply(e, this.getBoneList(t.children[r]));
            return e
        }
        ,
        i.SkeletonHelper.prototype.update = function() {
            for (var t = this.geometry, e = (new i.Matrix4).getInverse(this.root.matrixWorld), r = new i.Matrix4, n = 0, o = 0; o < this.bones.length; o++) {
                var a = this.bones[o];
                a.parent instanceof i.Bone && (r.multiplyMatrices(e, a.matrixWorld),
                t.vertices[n].setFromMatrixPosition(r),
                r.multiplyMatrices(e, a.parent.matrixWorld),
                t.vertices[n + 1].setFromMatrixPosition(r),
                n += 2)
            }
            t.verticesNeedUpdate = !0,
            t.computeBoundingSphere()
        }
        ,
        i.SpotLightHelper = function(t) {
            i.Object3D.call(this),
            this.light = t,
            this.light.updateMatrixWorld(),
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1;
            var e = new i.CylinderGeometry(0,1,1,8,1,(!0));
            e.translate(0, -.5, 0),
            e.rotateX(-Math.PI / 2);
            var r = new i.MeshBasicMaterial({
                wireframe: !0,
                fog: !1
            });
            this.cone = new i.Mesh(e,r),
            this.add(this.cone),
            this.update()
        }
        ,
        i.SpotLightHelper.prototype = Object.create(i.Object3D.prototype),
        i.SpotLightHelper.prototype.constructor = i.SpotLightHelper,
        i.SpotLightHelper.prototype.dispose = function() {
            this.cone.geometry.dispose(),
            this.cone.material.dispose()
        }
        ,
        i.SpotLightHelper.prototype.update = function() {
            var t = new i.Vector3
              , e = new i.Vector3;
            return function() {
                var r = this.light.distance ? this.light.distance : 1e4
                  , i = r * Math.tan(this.light.angle);
                this.cone.scale.set(i, i, r),
                t.setFromMatrixPosition(this.light.matrixWorld),
                e.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(e.sub(t)),
                this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
            }
        }(),
        i.VertexNormalsHelper = function(t, e, r, n) {
            this.object = t,
            this.size = void 0 !== e ? e : 1;
            var o = void 0 !== r ? r : 16711680
              , a = void 0 !== n ? n : 1
              , s = 0
              , h = this.object.geometry;
            h instanceof i.Geometry ? s = 3 * h.faces.length : h instanceof i.BufferGeometry && (s = h.attributes.normal.count);
            var c = new i.BufferGeometry
              , l = new i.Float32Attribute(2 * s * 3,3);
            c.addAttribute("position", l),
            i.LineSegments.call(this, c, new i.LineBasicMaterial({
                color: o,
                linewidth: a
            })),
            this.matrixAutoUpdate = !1,
            this.update()
        }
        ,
        i.VertexNormalsHelper.prototype = Object.create(i.LineSegments.prototype),
        i.VertexNormalsHelper.prototype.constructor = i.VertexNormalsHelper,
        i.VertexNormalsHelper.prototype.update = function() {
            var t = new i.Vector3
              , e = new i.Vector3
              , r = new i.Matrix3;
            return function() {
                var n = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0),
                r.getNormalMatrix(this.object.matrixWorld);
                var o = this.object.matrixWorld
                  , a = this.geometry.attributes.position
                  , s = this.object.geometry;
                if (s instanceof i.Geometry)
                    for (var h = s.vertices, c = s.faces, l = 0, u = 0, p = c.length; u < p; u++)
                        for (var d = c[u], f = 0, m = d.vertexNormals.length; f < m; f++) {
                            var g = h[d[n[f]]]
                              , v = d.vertexNormals[f];
                            t.copy(g).applyMatrix4(o),
                            e.copy(v).applyMatrix3(r).normalize().multiplyScalar(this.size).add(t),
                            a.setXYZ(l, t.x, t.y, t.z),
                            l += 1,
                            a.setXYZ(l, e.x, e.y, e.z),
                            l += 1
                        }
                else if (s instanceof i.BufferGeometry)
                    for (var y = s.attributes.position, x = s.attributes.normal, l = 0, f = 0, m = y.count; f < m; f++)
                        t.set(y.getX(f), y.getY(f), y.getZ(f)).applyMatrix4(o),
                        e.set(x.getX(f), x.getY(f), x.getZ(f)),
                        e.applyMatrix3(r).normalize().multiplyScalar(this.size).add(t),
                        a.setXYZ(l, t.x, t.y, t.z),
                        l += 1,
                        a.setXYZ(l, e.x, e.y, e.z),
                        l += 1;
                return a.needsUpdate = !0,
                this
            }
        }(),
        i.WireframeHelper = function(t, e) {
            var r = void 0 !== e ? e : 16777215;
            i.LineSegments.call(this, new i.WireframeGeometry(t.geometry), new i.LineBasicMaterial({
                color: r
            })),
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1
        }
        ,
        i.WireframeHelper.prototype = Object.create(i.LineSegments.prototype),
        i.WireframeHelper.prototype.constructor = i.WireframeHelper,
        i.ImmediateRenderObject = function(t) {
            i.Object3D.call(this),
            this.material = t,
            this.render = function(t) {}
        }
        ,
        i.ImmediateRenderObject.prototype = Object.create(i.Object3D.prototype),
        i.ImmediateRenderObject.prototype.constructor = i.ImmediateRenderObject,
        i.MorphBlendMesh = function(t, e) {
            i.Mesh.call(this, t, e),
            this.animationsMap = {},
            this.animationsList = [];
            var r = this.geometry.morphTargets.length
              , n = "__default"
              , o = 0
              , a = r - 1
              , s = r / 1;
            this.createAnimation(n, o, a, s),
            this.setAnimationWeight(n, 1)
        }
        ,
        i.MorphBlendMesh.prototype = Object.create(i.Mesh.prototype),
        i.MorphBlendMesh.prototype.constructor = i.MorphBlendMesh,
        i.MorphBlendMesh.prototype.createAnimation = function(t, e, r, i) {
            var n = {
                start: e,
                end: r,
                length: r - e + 1,
                fps: i,
                duration: (r - e) / i,
                lastFrame: 0,
                currentFrame: 0,
                active: !1,
                time: 0,
                direction: 1,
                weight: 1,
                directionBackwards: !1,
                mirroredLoop: !1
            };
            this.animationsMap[t] = n,
            this.animationsList.push(n)
        }
        ,
        i.MorphBlendMesh.prototype.autoCreateAnimations = function(t) {
            for (var e, r = /([a-z]+)_?(\d+)/i, i = {}, n = this.geometry, o = 0, a = n.morphTargets.length; o < a; o++) {
                var s = n.morphTargets[o]
                  , h = s.name.match(r);
                if (h && h.length > 1) {
                    var c = h[1];
                    i[c] || (i[c] = {
                        start: 1 / 0,
                        end: -(1 / 0)
                    });
                    var l = i[c];
                    o < l.start && (l.start = o),
                    o > l.end && (l.end = o),
                    e || (e = c)
                }
            }
            for (var c in i) {
                var l = i[c];
                this.createAnimation(c, l.start, l.end, t)
            }
            this.firstAnimation = e
        }
        ,
        i.MorphBlendMesh.prototype.setAnimationDirectionForward = function(t) {
            var e = this.animationsMap[t];
            e && (e.direction = 1,
            e.directionBackwards = !1)
        }
        ,
        i.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(t) {
            var e = this.animationsMap[t];
            e && (e.direction = -1,
            e.directionBackwards = !0)
        }
        ,
        i.MorphBlendMesh.prototype.setAnimationFPS = function(t, e) {
            var r = this.animationsMap[t];
            r && (r.fps = e,
            r.duration = (r.end - r.start) / r.fps)
        }
        ,
        i.MorphBlendMesh.prototype.setAnimationDuration = function(t, e) {
            var r = this.animationsMap[t];
            r && (r.duration = e,
            r.fps = (r.end - r.start) / r.duration)
        }
        ,
        i.MorphBlendMesh.prototype.setAnimationWeight = function(t, e) {
            var r = this.animationsMap[t];
            r && (r.weight = e)
        }
        ,
        i.MorphBlendMesh.prototype.setAnimationTime = function(t, e) {
            var r = this.animationsMap[t];
            r && (r.time = e)
        }
        ,
        i.MorphBlendMesh.prototype.getAnimationTime = function(t) {
            var e = 0
              , r = this.animationsMap[t];
            return r && (e = r.time),
            e
        }
        ,
        i.MorphBlendMesh.prototype.getAnimationDuration = function(t) {
            var e = -1
              , r = this.animationsMap[t];
            return r && (e = r.duration),
            e
        }
        ,
        i.MorphBlendMesh.prototype.playAnimation = function(t) {
            var e = this.animationsMap[t];
            e ? (e.time = 0,
            e.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()")
        }
        ,
        i.MorphBlendMesh.prototype.stopAnimation = function(t) {
            var e = this.animationsMap[t];
            e && (e.active = !1)
        }
        ,
        i.MorphBlendMesh.prototype.update = function(t) {
            for (var e = 0, r = this.animationsList.length; e < r; e++) {
                var n = this.animationsList[e];
                if (n.active) {
                    var o = n.duration / n.length;
                    n.time += n.direction * t,
                    n.mirroredLoop ? (n.time > n.duration || n.time < 0) && (n.direction *= -1,
                    n.time > n.duration && (n.time = n.duration,
                    n.directionBackwards = !0),
                    n.time < 0 && (n.time = 0,
                    n.directionBackwards = !1)) : (n.time = n.time % n.duration,
                    n.time < 0 && (n.time += n.duration));
                    var a = n.start + i.Math.clamp(Math.floor(n.time / o), 0, n.length - 1)
                      , s = n.weight;
                    a !== n.currentFrame && (this.morphTargetInfluences[n.lastFrame] = 0,
                    this.morphTargetInfluences[n.currentFrame] = 1 * s,
                    this.morphTargetInfluences[a] = 0,
                    n.lastFrame = n.currentFrame,
                    n.currentFrame = a);
                    var h = n.time % o / o;
                    n.directionBackwards && (h = 1 - h),
                    n.currentFrame !== n.lastFrame ? (this.morphTargetInfluences[n.currentFrame] = h * s,
                    this.morphTargetInfluences[n.lastFrame] = (1 - h) * s) : this.morphTargetInfluences[n.currentFrame] = s
                }
            }
        }
        ,
        "undefined" != typeof r ? ("undefined" != typeof e && e.exports && (r = e.exports = i),
        r.THREE = i) : this.THREE = i
    }
    , {}],
    9: [function(t, e, r) {
        !function(t, i) {
            "object" == typeof r && "undefined" != typeof e ? i(r) : "function" == typeof define && define.amd ? define(["exports"], i) : i(t.THREE = t.THREE || {})
        }(this, function(t) {
            "use strict";
            function e() {}
            function r(t, e) {
                this.x = t || 0,
                this.y = e || 0
            }
            function i(e, o, a, s, h, c, l, u, p, d) {
                Object.defineProperty(this, "id", {
                    value: n()
                }),
                this.uuid = t.Math.generateUUID(),
                this.name = "",
                this.sourceFile = "",
                this.image = void 0 !== e ? e : i.DEFAULT_IMAGE,
                this.mipmaps = [],
                this.mapping = void 0 !== o ? o : i.DEFAULT_MAPPING,
                this.wrapS = void 0 !== a ? a : wo,
                this.wrapT = void 0 !== s ? s : wo,
                this.magFilter = void 0 !== h ? h : To,
                this.minFilter = void 0 !== c ? c : Lo,
                this.anisotropy = void 0 !== p ? p : 1,
                this.format = void 0 !== l ? l : jo,
                this.type = void 0 !== u ? u : Co,
                this.offset = new r(0,0),
                this.repeat = new r(1,1),
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                this.encoding = void 0 !== d ? d : ga,
                this.version = 0,
                this.onUpdate = null
            }
            function n() {
                return Ta++
            }
            function o() {
                this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
                arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            function a(t, e, r, i) {
                this._x = t || 0,
                this._y = e || 0,
                this._z = r || 0,
                this._w = void 0 !== i ? i : 1
            }
            function s(t, e, r) {
                this.x = t || 0,
                this.y = e || 0,
                this.z = r || 0
            }
            function h(t, e) {
                function r() {
                    var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1])
                      , e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    h = f.createBuffer(),
                    c = f.createBuffer(),
                    f.bindBuffer(f.ARRAY_BUFFER, h),
                    f.bufferData(f.ARRAY_BUFFER, t, f.STATIC_DRAW),
                    f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c),
                    f.bufferData(f.ELEMENT_ARRAY_BUFFER, e, f.STATIC_DRAW),
                    l = n(),
                    u = {
                        position: f.getAttribLocation(l, "position"),
                        uv: f.getAttribLocation(l, "uv")
                    },
                    p = {
                        uvOffset: f.getUniformLocation(l, "uvOffset"),
                        uvScale: f.getUniformLocation(l, "uvScale"),
                        rotation: f.getUniformLocation(l, "rotation"),
                        scale: f.getUniformLocation(l, "scale"),
                        color: f.getUniformLocation(l, "color"),
                        map: f.getUniformLocation(l, "map"),
                        opacity: f.getUniformLocation(l, "opacity"),
                        modelViewMatrix: f.getUniformLocation(l, "modelViewMatrix"),
                        projectionMatrix: f.getUniformLocation(l, "projectionMatrix"),
                        fogType: f.getUniformLocation(l, "fogType"),
                        fogDensity: f.getUniformLocation(l, "fogDensity"),
                        fogNear: f.getUniformLocation(l, "fogNear"),
                        fogFar: f.getUniformLocation(l, "fogFar"),
                        fogColor: f.getUniformLocation(l, "fogColor"),
                        alphaTest: f.getUniformLocation(l, "alphaTest")
                    };
                    var r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    r.width = 8,
                    r.height = 8;
                    var o = r.getContext("2d");
                    o.fillStyle = "white",
                    o.fillRect(0, 0, 8, 8),
                    d = new i(r),
                    d.needsUpdate = !0
                }
                function n() {
                    var e = f.createProgram()
                      , r = f.createShader(f.VERTEX_SHADER)
                      , i = f.createShader(f.FRAGMENT_SHADER);
                    return f.shaderSource(r, ["precision " + t.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")),
                    f.shaderSource(i, ["precision " + t.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")),
                    f.compileShader(r),
                    f.compileShader(i),
                    f.attachShader(e, r),
                    f.attachShader(e, i),
                    f.linkProgram(e),
                    e
                }
                function o(t, e) {
                    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
                }
                var h, c, l, u, p, d, f = t.context, m = t.state, g = new s, v = new a, y = new s;
                this.render = function(i, n) {
                    if (0 !== e.length) {
                        void 0 === l && r(),
                        f.useProgram(l),
                        m.initAttributes(),
                        m.enableAttribute(u.position),
                        m.enableAttribute(u.uv),
                        m.disableUnusedAttributes(),
                        m.disable(f.CULL_FACE),
                        m.enable(f.BLEND),
                        f.bindBuffer(f.ARRAY_BUFFER, h),
                        f.vertexAttribPointer(u.position, 2, f.FLOAT, !1, 16, 0),
                        f.vertexAttribPointer(u.uv, 2, f.FLOAT, !1, 16, 8),
                        f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c),
                        f.uniformMatrix4fv(p.projectionMatrix, !1, n.projectionMatrix.elements),
                        m.activeTexture(f.TEXTURE0),
                        f.uniform1i(p.map, 0);
                        var a = 0
                          , s = 0
                          , x = i.fog;
                        x ? (f.uniform3f(p.fogColor, x.color.r, x.color.g, x.color.b),
                        x && x.isFog ? (f.uniform1f(p.fogNear, x.near),
                        f.uniform1f(p.fogFar, x.far),
                        f.uniform1i(p.fogType, 1),
                        a = 1,
                        s = 1) : x && x.isFogExp2 && (f.uniform1f(p.fogDensity, x.density),
                        f.uniform1i(p.fogType, 2),
                        a = 2,
                        s = 2)) : (f.uniform1i(p.fogType, 0),
                        a = 0,
                        s = 0);
                        for (var b = 0, w = e.length; b < w; b++) {
                            var _ = e[b];
                            _.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, _.matrixWorld),
                            _.z = -_.modelViewMatrix.elements[14]
                        }
                        e.sort(o);
                        for (var M = [], b = 0, w = e.length; b < w; b++) {
                            var _ = e[b]
                              , S = _.material;
                            if (S.visible !== !1) {
                                f.uniform1f(p.alphaTest, S.alphaTest),
                                f.uniformMatrix4fv(p.modelViewMatrix, !1, _.modelViewMatrix.elements),
                                _.matrixWorld.decompose(g, v, y),
                                M[0] = y.x,
                                M[1] = y.y;
                                var E = 0;
                                i.fog && S.fog && (E = s),
                                a !== E && (f.uniform1i(p.fogType, E),
                                a = E),
                                null !== S.map ? (f.uniform2f(p.uvOffset, S.map.offset.x, S.map.offset.y),
                                f.uniform2f(p.uvScale, S.map.repeat.x, S.map.repeat.y)) : (f.uniform2f(p.uvOffset, 0, 0),
                                f.uniform2f(p.uvScale, 1, 1)),
                                f.uniform1f(p.opacity, S.opacity),
                                f.uniform3f(p.color, S.color.r, S.color.g, S.color.b),
                                f.uniform1f(p.rotation, S.rotation),
                                f.uniform2fv(p.scale, M),
                                m.setBlending(S.blending, S.blendEquation, S.blendSrc, S.blendDst),
                                m.setDepthTest(S.depthTest),
                                m.setDepthWrite(S.depthWrite),
                                S.map ? t.setTexture2D(S.map, 0) : t.setTexture2D(d, 0),
                                f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0)
                            }
                        }
                        m.enable(f.CULL_FACE),
                        t.resetGLState()
                    }
                }
            }
            function c(t, e) {
                this.min = void 0 !== t ? t : new r((+(1 / 0)),(+(1 / 0))),
                this.max = void 0 !== e ? e : new r((-(1 / 0)),(-(1 / 0)))
            }
            function l(t, e) {
                function i() {
                    var t = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1])
                      , e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    o = m.createBuffer(),
                    a = m.createBuffer(),
                    m.bindBuffer(m.ARRAY_BUFFER, o),
                    m.bufferData(m.ARRAY_BUFFER, t, m.STATIC_DRAW),
                    m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, a),
                    m.bufferData(m.ELEMENT_ARRAY_BUFFER, e, m.STATIC_DRAW),
                    d = m.createTexture(),
                    f = m.createTexture(),
                    g.bindTexture(m.TEXTURE_2D, d),
                    m.texImage2D(m.TEXTURE_2D, 0, m.RGB, 16, 16, 0, m.RGB, m.UNSIGNED_BYTE, null),
                    m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE),
                    m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE),
                    m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
                    m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
                    g.bindTexture(m.TEXTURE_2D, f),
                    m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, 16, 16, 0, m.RGBA, m.UNSIGNED_BYTE, null),
                    m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE),
                    m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE),
                    m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
                    m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
                    h = {
                        vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                        fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                    },
                    l = n(h),
                    u = {
                        vertex: m.getAttribLocation(l, "position"),
                        uv: m.getAttribLocation(l, "uv")
                    },
                    p = {
                        renderType: m.getUniformLocation(l, "renderType"),
                        map: m.getUniformLocation(l, "map"),
                        occlusionMap: m.getUniformLocation(l, "occlusionMap"),
                        opacity: m.getUniformLocation(l, "opacity"),
                        color: m.getUniformLocation(l, "color"),
                        scale: m.getUniformLocation(l, "scale"),
                        rotation: m.getUniformLocation(l, "rotation"),
                        screenPosition: m.getUniformLocation(l, "screenPosition")
                    }
                }
                function n(e) {
                    var r = m.createProgram()
                      , i = m.createShader(m.FRAGMENT_SHADER)
                      , n = m.createShader(m.VERTEX_SHADER)
                      , o = "precision " + t.getPrecision() + " float;\n";
                    return m.shaderSource(i, o + e.fragmentShader),
                    m.shaderSource(n, o + e.vertexShader),
                    m.compileShader(i),
                    m.compileShader(n),
                    m.attachShader(r, i),
                    m.attachShader(r, n),
                    m.linkProgram(r),
                    r
                }
                var o, a, h, l, u, p, d, f, m = t.context, g = t.state;
                this.render = function(n, h, v) {
                    if (0 !== e.length) {
                        var y = new s
                          , x = v.w / v.z
                          , b = .5 * v.z
                          , w = .5 * v.w
                          , _ = 16 / v.w
                          , M = new r(_ * x,_)
                          , S = new s(1,1,0)
                          , E = new r(1,1)
                          , T = new c;
                        T.min.set(0, 0),
                        T.max.set(v.z - 16, v.w - 16),
                        void 0 === l && i(),
                        m.useProgram(l),
                        g.initAttributes(),
                        g.enableAttribute(u.vertex),
                        g.enableAttribute(u.uv),
                        g.disableUnusedAttributes(),
                        m.uniform1i(p.occlusionMap, 0),
                        m.uniform1i(p.map, 1),
                        m.bindBuffer(m.ARRAY_BUFFER, o),
                        m.vertexAttribPointer(u.vertex, 2, m.FLOAT, !1, 16, 0),
                        m.vertexAttribPointer(u.uv, 2, m.FLOAT, !1, 16, 8),
                        m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, a),
                        g.disable(m.CULL_FACE),
                        g.setDepthWrite(!1);
                        for (var A = 0, L = e.length; A < L; A++) {
                            _ = 16 / v.w,
                            M.set(_ * x, _);
                            var C = e[A];
                            if (y.set(C.matrixWorld.elements[12], C.matrixWorld.elements[13], C.matrixWorld.elements[14]),
                            y.applyMatrix4(h.matrixWorldInverse),
                            y.applyProjection(h.projectionMatrix),
                            S.copy(y),
                            E.x = v.x + S.x * b + b - 8,
                            E.y = v.y + S.y * w + w - 8,
                            T.containsPoint(E) === !0) {
                                g.activeTexture(m.TEXTURE0),
                                g.bindTexture(m.TEXTURE_2D, null),
                                g.activeTexture(m.TEXTURE1),
                                g.bindTexture(m.TEXTURE_2D, d),
                                m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGB, E.x, E.y, 16, 16, 0),
                                m.uniform1i(p.renderType, 0),
                                m.uniform2f(p.scale, M.x, M.y),
                                m.uniform3f(p.screenPosition, S.x, S.y, S.z),
                                g.disable(m.BLEND),
                                g.enable(m.DEPTH_TEST),
                                m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                                g.activeTexture(m.TEXTURE0),
                                g.bindTexture(m.TEXTURE_2D, f),
                                m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGBA, E.x, E.y, 16, 16, 0),
                                m.uniform1i(p.renderType, 1),
                                g.disable(m.DEPTH_TEST),
                                g.activeTexture(m.TEXTURE1),
                                g.bindTexture(m.TEXTURE_2D, d),
                                m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                                C.positionScreen.copy(S),
                                C.customUpdateCallback ? C.customUpdateCallback(C) : C.updateLensFlares(),
                                m.uniform1i(p.renderType, 2),
                                g.enable(m.BLEND);
                                for (var R = 0, P = C.lensFlares.length; R < P; R++) {
                                    var U = C.lensFlares[R];
                                    U.opacity > .001 && U.scale > .001 && (S.x = U.x,
                                    S.y = U.y,
                                    S.z = U.z,
                                    _ = U.size * U.scale / v.w,
                                    M.x = _ * x,
                                    M.y = _,
                                    m.uniform3f(p.screenPosition, S.x, S.y, S.z),
                                    m.uniform2f(p.scale, M.x, M.y),
                                    m.uniform1f(p.rotation, U.rotation),
                                    m.uniform1f(p.opacity, U.opacity),
                                    m.uniform3f(p.color, U.color.r, U.color.g, U.color.b),
                                    g.setBlending(U.blending, U.blendEquation, U.blendSrc, U.blendDst),
                                    t.setTexture2D(U.texture, 1),
                                    m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0))
                                }
                            }
                        }
                        g.enable(m.CULL_FACE),
                        g.enable(m.DEPTH_TEST),
                        g.setDepthWrite(!0),
                        t.resetGLState()
                    }
                }
            }
            function u(t, e, r, n, o, a, s, h, c, l) {
                t = void 0 !== t ? t : [],
                e = void 0 !== e ? e : po,
                i.call(this, t, e, r, n, o, a, s, h, c, l),
                this.flipY = !1
            }
            function p() {
                this.seq = [],
                this.map = {}
            }
            function d(t, e, r) {
                var i = t[0];
                if (i <= 0 || i > 0)
                    return t;
                var n = e * r
                  , o = Ca[n];
                if (void 0 === o && (o = new Float32Array(n),
                Ca[n] = o),
                0 !== e) {
                    i.toArray(o, 0);
                    for (var a = 1, s = 0; a !== e; ++a)
                        s += r,
                        t[a].toArray(o, s)
                }
                return o
            }
            function f(t, e) {
                var r = Ra[e];
                void 0 === r && (r = new Int32Array(e),
                Ra[e] = r);
                for (var i = 0; i !== e; ++i)
                    r[i] = t.allocTextureUnit();
                return r
            }
            function m(t, e) {
                t.uniform1f(this.addr, e)
            }
            function g(t, e) {
                t.uniform1i(this.addr, e)
            }
            function v(t, e) {
                void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
            }
            function y(t, e) {
                void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
            }
            function x(t, e) {
                void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
            }
            function b(t, e) {
                t.uniformMatrix2fv(this.addr, !1, e.elements || e)
            }
            function w(t, e) {
                t.uniformMatrix3fv(this.addr, !1, e.elements || e)
            }
            function _(t, e) {
                t.uniformMatrix4fv(this.addr, !1, e.elements || e)
            }
            function M(t, e, r) {
                var i = r.allocTextureUnit();
                t.uniform1i(this.addr, i),
                r.setTexture2D(e || Aa, i)
            }
            function S(t, e, r) {
                var i = r.allocTextureUnit();
                t.uniform1i(this.addr, i),
                r.setTextureCube(e || La, i)
            }
            function E(t, e) {
                t.uniform2iv(this.addr, e)
            }
            function T(t, e) {
                t.uniform3iv(this.addr, e)
            }
            function A(t, e) {
                t.uniform4iv(this.addr, e)
            }
            function L(t) {
                switch (t) {
                case 5126:
                    return m;
                case 35664:
                    return v;
                case 35665:
                    return y;
                case 35666:
                    return x;
                case 35674:
                    return b;
                case 35675:
                    return w;
                case 35676:
                    return _;
                case 35678:
                    return M;
                case 35680:
                    return S;
                case 5124:
                case 35670:
                    return g;
                case 35667:
                case 35671:
                    return E;
                case 35668:
                case 35672:
                    return T;
                case 35669:
                case 35673:
                    return A
                }
            }
            function C(t, e) {
                t.uniform1fv(this.addr, e)
            }
            function R(t, e) {
                t.uniform1iv(this.addr, e)
            }
            function P(t, e) {
                t.uniform2fv(this.addr, d(e, this.size, 2))
            }
            function U(t, e) {
                t.uniform3fv(this.addr, d(e, this.size, 3))
            }
            function I(t, e) {
                t.uniform4fv(this.addr, d(e, this.size, 4))
            }
            function D(t, e) {
                t.uniformMatrix2fv(this.addr, !1, d(e, this.size, 4))
            }
            function O(t, e) {
                t.uniformMatrix3fv(this.addr, !1, d(e, this.size, 9))
            }
            function N(t, e) {
                t.uniformMatrix4fv(this.addr, !1, d(e, this.size, 16))
            }
            function B(t, e, r) {
                var i = e.length
                  , n = f(r, i);
                t.uniform1iv(this.addr, n);
                for (var o = 0; o !== i; ++o)
                    r.setTexture2D(e[o] || Aa, n[o])
            }
            function F(t, e, r) {
                var i = e.length
                  , n = f(r, i);
                t.uniform1iv(this.addr, n);
                for (var o = 0; o !== i; ++o)
                    r.setTextureCube(e[o] || La, n[o])
            }
            function k(t) {
                switch (t) {
                case 5126:
                    return C;
                case 35664:
                    return P;
                case 35665:
                    return U;
                case 35666:
                    return I;
                case 35674:
                    return D;
                case 35675:
                    return O;
                case 35676:
                    return N;
                case 35678:
                    return B;
                case 35680:
                    return F;
                case 5124:
                case 35670:
                    return R;
                case 35667:
                case 35671:
                    return E;
                case 35668:
                case 35672:
                    return T;
                case 35669:
                case 35673:
                    return A
                }
            }
            function z(t, e, r) {
                this.id = t,
                this.addr = r,
                this.setValue = L(e.type)
            }
            function V(t, e, r) {
                this.id = t,
                this.addr = r,
                this.size = e.size,
                this.setValue = k(e.type)
            }
            function G(t) {
                this.id = t,
                p.call(this)
            }
            function j(t, e) {
                t.seq.push(e),
                t.map[e.id] = e
            }
            function H(t, e, r) {
                var i = t.name
                  , n = i.length;
                for (Pa.lastIndex = 0; ; ) {
                    var o = Pa.exec(i)
                      , a = Pa.lastIndex
                      , s = o[1]
                      , h = "]" === o[2]
                      , c = o[3];
                    if (h && (s = 0 | s),
                    void 0 === c || "[" === c && a + 2 === n) {
                        j(r, void 0 === c ? new z(s,t,e) : new V(s,t,e));
                        break
                    }
                    var l = r.map
                      , u = l[s];
                    void 0 === u && (u = new G(s),
                    j(r, u)),
                    r = u
                }
            }
            function W(t, e, r) {
                p.call(this),
                this.renderer = r;
                for (var i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), n = 0; n !== i; ++n) {
                    var o = t.getActiveUniform(e, n)
                      , a = o.name
                      , s = t.getUniformLocation(e, a);
                    H(o, s, this)
                }
            }
            function X(e, r, i, n, o, a, s) {
                function h(t, e) {
                    if (t.width > e || t.height > e) {
                        var r = e / Math.max(t.width, t.height)
                          , i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        i.width = Math.floor(t.width * r),
                        i.height = Math.floor(t.height * r);
                        var n = i.getContext("2d");
                        return n.drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height),
                        console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height, t),
                        i
                    }
                    return t
                }
                function c(e) {
                    return t.Math.isPowerOfTwo(e.width) && t.Math.isPowerOfTwo(e.height)
                }
                function l(e) {
                    if (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement) {
                        var r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        r.width = t.Math.nearestPowerOfTwo(e.width),
                        r.height = t.Math.nearestPowerOfTwo(e.height);
                        var i = r.getContext("2d");
                        return i.drawImage(e, 0, 0, r.width, r.height),
                        console.warn("THREE.WebGLRenderer: image is not power of two (" + e.width + "x" + e.height + "). Resized to " + r.width + "x" + r.height, e),
                        r
                    }
                    return e
                }
                function u(t) {
                    return t.wrapS !== wo || t.wrapT !== wo || t.minFilter !== Mo && t.minFilter !== To
                }
                function p(t) {
                    return t === Mo || t === So || t === Eo ? e.NEAREST : e.LINEAR
                }
                function d(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", d),
                    m(e),
                    L.textures--
                }
                function f(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", f),
                    g(e),
                    L.textures--
                }
                function m(t) {
                    var r = n.get(t);
                    if (t.image && r.__image__webglTextureCube)
                        e.deleteTexture(r.__image__webglTextureCube);
                    else {
                        if (void 0 === r.__webglInit)
                            return;
                        e.deleteTexture(r.__webglTexture)
                    }
                    n.delete(t)
                }
                function g(t) {
                    var r = n.get(t)
                      , i = n.get(t.texture);
                    if (t) {
                        if (void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture),
                        t.depthTexture && t.depthTexture.dispose(),
                        t && t.isWebGLRenderTargetCube)
                            for (var o = 0; o < 6; o++)
                                e.deleteFramebuffer(r.__webglFramebuffer[o]),
                                r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[o]);
                        else
                            e.deleteFramebuffer(r.__webglFramebuffer),
                            r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer);
                        n.delete(t.texture),
                        n.delete(t)
                    }
                }
                function v(t, r) {
                    var o = n.get(t);
                    if (t.version > 0 && o.__version !== t.version) {
                        var a = t.image;
                        if (void 0 === a)
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", t);
                        else {
                            if (a.complete !== !1)
                                return void w(o, t, r);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", t)
                        }
                    }
                    i.activeTexture(e.TEXTURE0 + r),
                    i.bindTexture(e.TEXTURE_2D, o.__webglTexture)
                }
                function y(t, r) {
                    var s = n.get(t);
                    if (6 === t.image.length)
                        if (t.version > 0 && s.__version !== t.version) {
                            s.__image__webglTextureCube || (t.addEventListener("dispose", d),
                            s.__image__webglTextureCube = e.createTexture(),
                            L.textures++),
                            i.activeTexture(e.TEXTURE0 + r),
                            i.bindTexture(e.TEXTURE_CUBE_MAP, s.__image__webglTextureCube),
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t.flipY);
                            for (var l = t && t.isCompressedTexture, u = t.image[0] && t.image[0].isDataTexture, p = [], f = 0; f < 6; f++)
                                l || u ? p[f] = u ? t.image[f].image : t.image[f] : p[f] = h(t.image[f], o.maxCubemapSize);
                            var m = p[0]
                              , g = c(m)
                              , v = a(t.format)
                              , y = a(t.type);
                            b(e.TEXTURE_CUBE_MAP, t, g);
                            for (var f = 0; f < 6; f++)
                                if (l)
                                    for (var x, w = p[f].mipmaps, _ = 0, M = w.length; _ < M; _++)
                                        x = w[_],
                                        t.format !== jo && t.format !== Go ? i.getCompressedTextureFormats().indexOf(v) > -1 ? i.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + f, _, v, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + f, _, v, x.width, x.height, 0, v, y, x.data);
                                else
                                    u ? i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, v, p[f].width, p[f].height, 0, v, y, p[f].data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, v, v, y, p[f]);
                            t.generateMipmaps && g && e.generateMipmap(e.TEXTURE_CUBE_MAP),
                            s.__version = t.version,
                            t.onUpdate && t.onUpdate(t)
                        } else
                            i.activeTexture(e.TEXTURE0 + r),
                            i.bindTexture(e.TEXTURE_CUBE_MAP, s.__image__webglTextureCube)
                }
                function x(t, r) {
                    i.activeTexture(e.TEXTURE0 + r),
                    i.bindTexture(e.TEXTURE_CUBE_MAP, n.get(t).__webglTexture)
                }
                function b(t, i, s) {
                    var h;
                    if (s ? (e.texParameteri(t, e.TEXTURE_WRAP_S, a(i.wrapS)),
                    e.texParameteri(t, e.TEXTURE_WRAP_T, a(i.wrapT)),
                    e.texParameteri(t, e.TEXTURE_MAG_FILTER, a(i.magFilter)),
                    e.texParameteri(t, e.TEXTURE_MIN_FILTER, a(i.minFilter))) : (e.texParameteri(t, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                    e.texParameteri(t, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                    i.wrapS === wo && i.wrapT === wo || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", i),
                    e.texParameteri(t, e.TEXTURE_MAG_FILTER, p(i.magFilter)),
                    e.texParameteri(t, e.TEXTURE_MIN_FILTER, p(i.minFilter)),
                    i.minFilter !== Mo && i.minFilter !== To && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", i)),
                    h = r.get("EXT_texture_filter_anisotropic")) {
                        if (i.type === Oo && null === r.get("OES_texture_float_linear"))
                            return;
                        if (i.type === No && null === r.get("OES_texture_half_float_linear"))
                            return;
                        (i.anisotropy > 1 || n.get(i).__currentAnisotropy) && (e.texParameterf(t, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i.anisotropy, o.getMaxAnisotropy())),
                        n.get(i).__currentAnisotropy = i.anisotropy)
                    }
                }
                function w(t, r, n) {
                    void 0 === t.__webglInit && (t.__webglInit = !0,
                    r.addEventListener("dispose", d),
                    t.__webglTexture = e.createTexture(),
                    L.textures++),
                    i.activeTexture(e.TEXTURE0 + n),
                    i.bindTexture(e.TEXTURE_2D, t.__webglTexture),
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, r.flipY),
                    e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
                    e.pixelStorei(e.UNPACK_ALIGNMENT, r.unpackAlignment);
                    var s = h(r.image, o.maxTextureSize);
                    u(r) && c(s) === !1 && (s = l(s));
                    var p = c(s)
                      , f = a(r.format)
                      , m = a(r.type);
                    b(e.TEXTURE_2D, r, p);
                    var g, v = r.mipmaps;
                    if (r && r.isDepthTexture) {
                        var y = e.DEPTH_COMPONENT;
                        if (r.type === Oo) {
                            if (!C)
                                throw new Error("Float Depth Texture only supported in WebGL2.0");
                            y = e.DEPTH_COMPONENT32F
                        } else
                            C && (y = e.DEPTH_COMPONENT16);
                        r.format === qo && (y = e.DEPTH_STENCIL),
                        i.texImage2D(e.TEXTURE_2D, 0, y, s.width, s.height, 0, f, m, null)
                    } else if (r && r.isDataTexture)
                        if (v.length > 0 && p) {
                            for (var x = 0, w = v.length; x < w; x++)
                                g = v[x],
                                i.texImage2D(e.TEXTURE_2D, x, f, g.width, g.height, 0, f, m, g.data);
                            r.generateMipmaps = !1
                        } else
                            i.texImage2D(e.TEXTURE_2D, 0, f, s.width, s.height, 0, f, m, s.data);
                    else if (r && r.isCompressedTexture)
                        for (var x = 0, w = v.length; x < w; x++)
                            g = v[x],
                            r.format !== jo && r.format !== Go ? i.getCompressedTextureFormats().indexOf(f) > -1 ? i.compressedTexImage2D(e.TEXTURE_2D, x, f, g.width, g.height, 0, g.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(e.TEXTURE_2D, x, f, g.width, g.height, 0, f, m, g.data);
                    else if (v.length > 0 && p) {
                        for (var x = 0, w = v.length; x < w; x++)
                            g = v[x],
                            i.texImage2D(e.TEXTURE_2D, x, f, f, m, g);
                        r.generateMipmaps = !1
                    } else
                        i.texImage2D(e.TEXTURE_2D, 0, f, f, m, s);
                    r.generateMipmaps && p && e.generateMipmap(e.TEXTURE_2D),
                    t.__version = r.version,
                    r.onUpdate && r.onUpdate(r)
                }
                function _(t, r, o, s) {
                    var h = a(r.texture.format)
                      , c = a(r.texture.type);
                    i.texImage2D(s, 0, h, r.width, r.height, 0, h, c, null),
                    e.bindFramebuffer(e.FRAMEBUFFER, t),
                    e.framebufferTexture2D(e.FRAMEBUFFER, o, s, n.get(r.texture).__webglTexture, 0),
                    e.bindFramebuffer(e.FRAMEBUFFER, null)
                }
                function M(t, r) {
                    e.bindRenderbuffer(e.RENDERBUFFER, t),
                    r.depthBuffer && !r.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, r.width, r.height),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)) : r.depthBuffer && r.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, r.width, r.height),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)) : e.renderbufferStorage(e.RENDERBUFFER, e.RGBA4, r.width, r.height),
                    e.bindRenderbuffer(e.RENDERBUFFER, null)
                }
                function S(t, r) {
                    var i = r && r.isWebGLRenderTargetCube;
                    if (i)
                        throw new Error("Depth Texture with cube render targets is not supported!");
                    if (e.bindFramebuffer(e.FRAMEBUFFER, t),
                    !r.depthTexture || !r.depthTexture.isDepthTexture)
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                    r.depthTexture.image.height = r.height,
                    r.depthTexture.needsUpdate = !0),
                    v(r.depthTexture, 0);
                    var o = n.get(r.depthTexture).__webglTexture;
                    if (r.depthTexture.format === Yo)
                        e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0);
                    else {
                        if (r.depthTexture.format !== qo)
                            throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0)
                    }
                }
                function E(t) {
                    var r = n.get(t)
                      , i = t && t.isWebGLRenderTargetCube;
                    if (t.depthTexture) {
                        if (i)
                            throw new Error("target.depthTexture not supported in Cube render targets");
                        S(r.__webglFramebuffer, t)
                    } else if (i) {
                        r.__webglDepthbuffer = [];
                        for (var o = 0; o < 6; o++)
                            e.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[o]),
                            r.__webglDepthbuffer[o] = e.createRenderbuffer(),
                            M(r.__webglDepthbuffer[o], t)
                    } else
                        e.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer),
                        r.__webglDepthbuffer = e.createRenderbuffer(),
                        M(r.__webglDepthbuffer, t);
                    e.bindFramebuffer(e.FRAMEBUFFER, null)
                }
                function T(t) {
                    var r = n.get(t)
                      , o = n.get(t.texture);
                    t.addEventListener("dispose", f),
                    o.__webglTexture = e.createTexture(),
                    L.textures++;
                    var a = t && t.isWebGLRenderTargetCube
                      , s = c(t);
                    if (a) {
                        r.__webglFramebuffer = [];
                        for (var h = 0; h < 6; h++)
                            r.__webglFramebuffer[h] = e.createFramebuffer()
                    } else
                        r.__webglFramebuffer = e.createFramebuffer();
                    if (a) {
                        i.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture),
                        b(e.TEXTURE_CUBE_MAP, t.texture, s);
                        for (var h = 0; h < 6; h++)
                            _(r.__webglFramebuffer[h], t, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + h);
                        t.texture.generateMipmaps && s && e.generateMipmap(e.TEXTURE_CUBE_MAP),
                        i.bindTexture(e.TEXTURE_CUBE_MAP, null)
                    } else
                        i.bindTexture(e.TEXTURE_2D, o.__webglTexture),
                        b(e.TEXTURE_2D, t.texture, s),
                        _(r.__webglFramebuffer, t, e.COLOR_ATTACHMENT0, e.TEXTURE_2D),
                        t.texture.generateMipmaps && s && e.generateMipmap(e.TEXTURE_2D),
                        i.bindTexture(e.TEXTURE_2D, null);
                    t.depthBuffer && E(t)
                }
                function A(t) {
                    var r = t.texture;
                    if (r.generateMipmaps && c(t) && r.minFilter !== Mo && r.minFilter !== To) {
                        var o = t && t.isWebGLRenderTargetCube ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D
                          , a = n.get(r).__webglTexture;
                        i.bindTexture(o, a),
                        e.generateMipmap(o),
                        i.bindTexture(o, null)
                    }
                }
                var L = s.memory
                  , C = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext;
                this.setTexture2D = v,
                this.setTextureCube = y,
                this.setTextureCubeDynamic = x,
                this.setupRenderTarget = T,
                this.updateRenderTargetMipmap = A
            }
            function Y(t, e, r, i) {
                this.x = t || 0,
                this.y = e || 0,
                this.z = r || 0,
                this.w = void 0 !== i ? i : 1
            }
            function q(t, e, r) {
                function i() {
                    var e = !1
                      , r = new Y
                      , i = null
                      , n = new Y;
                    return {
                        setMask: function(r) {
                            i === r || e || (t.colorMask(r, r, r, r),
                            i = r)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, i, o, a) {
                            r.set(e, i, o, a),
                            n.equals(r) === !1 && (t.clearColor(e, i, o, a),
                            n.copy(r))
                        },
                        reset: function() {
                            e = !1,
                            i = null,
                            n.set(0, 0, 0, 1)
                        }
                    }
                }
                function n() {
                    var e = !1
                      , r = null
                      , i = null
                      , n = null;
                    return {
                        setTest: function(e) {
                            e ? p(t.DEPTH_TEST) : d(t.DEPTH_TEST)
                        },
                        setMask: function(i) {
                            r === i || e || (t.depthMask(i),
                            r = i)
                        },
                        setFunc: function(e) {
                            if (i !== e) {
                                if (e)
                                    switch (e) {
                                    case Zn:
                                        t.depthFunc(t.NEVER);
                                        break;
                                    case Qn:
                                        t.depthFunc(t.ALWAYS);
                                        break;
                                    case Jn:
                                        t.depthFunc(t.LESS);
                                        break;
                                    case Kn:
                                        t.depthFunc(t.LEQUAL);
                                        break;
                                    case $n:
                                        t.depthFunc(t.EQUAL);
                                        break;
                                    case to:
                                        t.depthFunc(t.GEQUAL);
                                        break;
                                    case eo:
                                        t.depthFunc(t.GREATER);
                                        break;
                                    case ro:
                                        t.depthFunc(t.NOTEQUAL);
                                        break;
                                    default:
                                        t.depthFunc(t.LEQUAL)
                                    }
                                else
                                    t.depthFunc(t.LEQUAL);
                                i = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            n !== e && (t.clearDepth(e),
                            n = e)
                        },
                        reset: function() {
                            e = !1,
                            r = null,
                            i = null,
                            n = null
                        }
                    }
                }
                function o() {
                    var e = !1
                      , r = null
                      , i = null
                      , n = null
                      , o = null
                      , a = null
                      , s = null
                      , h = null
                      , c = null;
                    return {
                        setTest: function(e) {
                            e ? p(t.STENCIL_TEST) : d(t.STENCIL_TEST)
                        },
                        setMask: function(i) {
                            r === i || e || (t.stencilMask(i),
                            r = i)
                        },
                        setFunc: function(e, r, a) {
                            i === e && n === r && o === a || (t.stencilFunc(e, r, a),
                            i = e,
                            n = r,
                            o = a)
                        },
                        setOp: function(e, r, i) {
                            a === e && s === r && h === i || (t.stencilOp(e, r, i),
                            a = e,
                            s = r,
                            h = i)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            c !== e && (t.clearStencil(e),
                            c = e)
                        },
                        reset: function() {
                            e = !1,
                            r = null,
                            i = null,
                            n = null,
                            o = null,
                            a = null,
                            s = null,
                            h = null,
                            c = null
                        }
                    }
                }
                function a(e, r, i) {
                    var n = new Uint8Array(4)
                      , o = t.createTexture();
                    t.bindTexture(e, o),
                    t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
                    t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                    for (var a = 0; a < i; a++)
                        t.texImage2D(r + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, n);
                    return o
                }
                function s() {
                    D(0, 0, 0, 1),
                    O(1),
                    N(0),
                    p(t.DEPTH_TEST),
                    x(Kn),
                    S(!1),
                    E(un),
                    p(t.CULL_FACE),
                    p(t.BLEND),
                    m(Ln)
                }
                function h() {
                    for (var t = 0, e = H.length; t < e; t++)
                        H[t] = 0
                }
                function c(r) {
                    if (H[r] = 1,
                    0 === W[r] && (t.enableVertexAttribArray(r),
                    W[r] = 1),
                    0 !== X[r]) {
                        var i = e.get("ANGLE_instanced_arrays");
                        i.vertexAttribDivisorANGLE(r, 0),
                        X[r] = 0
                    }
                }
                function l(e, r, i) {
                    H[e] = 1,
                    0 === W[e] && (t.enableVertexAttribArray(e),
                    W[e] = 1),
                    X[e] !== r && (i.vertexAttribDivisorANGLE(e, r),
                    X[e] = r)
                }
                function u() {
                    for (var e = 0, r = W.length; e !== r; ++e)
                        W[e] !== H[e] && (t.disableVertexAttribArray(e),
                        W[e] = 0)
                }
                function p(e) {
                    q[e] !== !0 && (t.enable(e),
                    q[e] = !0)
                }
                function d(e) {
                    q[e] !== !1 && (t.disable(e),
                    q[e] = !1)
                }
                function f() {
                    if (null === Z && (Z = [],
                    e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1")))
                        for (var r = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), i = 0; i < r.length; i++)
                            Z.push(r[i]);
                    return Z
                }
                function m(e, i, n, o, a, s, h, c) {
                    return e === An ? (d(t.BLEND),
                    void (Q = e)) : (p(t.BLEND),
                    e === Q && c === it || (e === Cn ? c ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                    t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD),
                    t.blendFunc(t.SRC_ALPHA, t.ONE)) : e === Rn ? c ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                    t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD),
                    t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : e === Pn ? c ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                    t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD),
                    t.blendFunc(t.ZERO, t.SRC_COLOR)) : c ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                    t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                    t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)),
                    Q = e,
                    it = c),
                    void (e === Un ? (a = a || i,
                    s = s || n,
                    h = h || o,
                    i === J && a === tt || (t.blendEquationSeparate(r(i), r(a)),
                    J = i,
                    tt = a),
                    n === K && o === $ && s === et && h === rt || (t.blendFuncSeparate(r(n), r(o), r(s), r(h)),
                    K = n,
                    $ = o,
                    et = s,
                    rt = h)) : (J = null,
                    K = null,
                    $ = null,
                    tt = null,
                    et = null,
                    rt = null)))
                }
                function g(t) {
                    z.setMask(t)
                }
                function v(t) {
                    V.setTest(t)
                }
                function y(t) {
                    V.setMask(t)
                }
                function x(t) {
                    V.setFunc(t)
                }
                function b(t) {
                    G.setTest(t)
                }
                function w(t) {
                    G.setMask(t)
                }
                function _(t, e, r) {
                    G.setFunc(t, e, r)
                }
                function M(t, e, r) {
                    G.setOp(t, e, r)
                }
                function S(e) {
                    nt !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
                    nt = e)
                }
                function E(e) {
                    e !== ln ? (p(t.CULL_FACE),
                    e !== ot && (e === un ? t.cullFace(t.BACK) : e === pn ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : d(t.CULL_FACE),
                    ot = e
                }
                function T(e) {
                    e !== at && (t.lineWidth(e),
                    at = e)
                }
                function A(e, r, i) {
                    e ? (p(t.POLYGON_OFFSET_FILL),
                    st === r && ht === i || (t.polygonOffset(r, i),
                    st = r,
                    ht = i)) : d(t.POLYGON_OFFSET_FILL)
                }
                function L() {
                    return ct
                }
                function C(e) {
                    ct = e,
                    e ? p(t.SCISSOR_TEST) : d(t.SCISSOR_TEST)
                }
                function R(e) {
                    void 0 === e && (e = t.TEXTURE0 + lt - 1),
                    ut !== e && (t.activeTexture(e),
                    ut = e)
                }
                function P(e, r) {
                    null === ut && R();
                    var i = pt[ut];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    },
                    pt[ut] = i),
                    i.type === e && i.texture === r || (t.bindTexture(e, r || mt[e]),
                    i.type = e,
                    i.texture = r)
                }
                function U() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error(t)
                    }
                }
                function I() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error(t)
                    }
                }
                function D(t, e, r, i) {
                    z.setClear(t, e, r, i)
                }
                function O(t) {
                    V.setClear(t)
                }
                function N(t) {
                    G.setClear(t)
                }
                function B(e) {
                    dt.equals(e) === !1 && (t.scissor(e.x, e.y, e.z, e.w),
                    dt.copy(e))
                }
                function F(e) {
                    ft.equals(e) === !1 && (t.viewport(e.x, e.y, e.z, e.w),
                    ft.copy(e))
                }
                function k() {
                    for (var e = 0; e < W.length; e++)
                        1 === W[e] && (t.disableVertexAttribArray(e),
                        W[e] = 0);
                    q = {},
                    Z = null,
                    ut = null,
                    pt = {},
                    Q = null,
                    nt = null,
                    ot = null,
                    z.reset(),
                    V.reset(),
                    G.reset()
                }
                var z = new i
                  , V = new n
                  , G = new o
                  , j = t.getParameter(t.MAX_VERTEX_ATTRIBS)
                  , H = new Uint8Array(j)
                  , W = new Uint8Array(j)
                  , X = new Uint8Array(j)
                  , q = {}
                  , Z = null
                  , Q = null
                  , J = null
                  , K = null
                  , $ = null
                  , tt = null
                  , et = null
                  , rt = null
                  , it = !1
                  , nt = null
                  , ot = null
                  , at = null
                  , st = null
                  , ht = null
                  , ct = null
                  , lt = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
                  , ut = null
                  , pt = {}
                  , dt = new Y
                  , ft = new Y
                  , mt = {};
                return mt[t.TEXTURE_2D] = a(t.TEXTURE_2D, t.TEXTURE_2D, 1),
                mt[t.TEXTURE_CUBE_MAP] = a(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                {
                    buffers: {
                        color: z,
                        depth: V,
                        stencil: G
                    },
                    init: s,
                    initAttributes: h,
                    enableAttribute: c,
                    enableAttributeAndDivisor: l,
                    disableUnusedAttributes: u,
                    enable: p,
                    disable: d,
                    getCompressedTextureFormats: f,
                    setBlending: m,
                    setColorWrite: g,
                    setDepthTest: v,
                    setDepthWrite: y,
                    setDepthFunc: x,
                    setStencilTest: b,
                    setStencilWrite: w,
                    setStencilFunc: _,
                    setStencilOp: M,
                    setFlipSided: S,
                    setCullFace: E,
                    setLineWidth: T,
                    setPolygonOffset: A,
                    getScissorTest: L,
                    setScissorTest: C,
                    activeTexture: R,
                    bindTexture: P,
                    compressedTexImage2D: U,
                    texImage2D: I,
                    clearColor: D,
                    clearDepth: O,
                    clearStencil: N,
                    scissor: B,
                    viewport: F,
                    reset: k
                }
            }
            function Z(e, r, n) {
                this.uuid = t.Math.generateUUID(),
                this.width = e,
                this.height = r,
                this.scissor = new Y(0,0,e,r),
                this.scissorTest = !1,
                this.viewport = new Y(0,0,e,r),
                n = n || {},
                void 0 === n.minFilter && (n.minFilter = To),
                this.texture = new i((void 0),(void 0),n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
                this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
                this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer,
                this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }
            function Q() {
                Object.defineProperty(this, "id", {
                    value: J()
                }),
                this.uuid = t.Math.generateUUID(),
                this.name = "",
                this.type = "Material",
                this.fog = !0,
                this.lights = !0,
                this.blending = Ln,
                this.side = xn,
                this.shading = Mn,
                this.vertexColors = Sn,
                this.opacity = 1,
                this.transparent = !1,
                this.blendSrc = Gn,
                this.blendDst = jn,
                this.blendEquation = In,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.depthFunc = Kn,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.clippingPlanes = null,
                this.clipShadows = !1,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.alphaTest = 0,
                this.premultipliedAlpha = !1,
                this.overdraw = 0,
                this.visible = !0,
                this._needsUpdate = !0
            }
            function J() {
                return Ua++
            }
            function K(t) {
                Q.call(this),
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                },
                this.index0AttributeName = void 0,
                void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
                this.setValues(t))
            }
            function $(t, e, r) {
                return void 0 === e && void 0 === r ? this.set(t) : this.setRGB(t, e, r)
            }
            function tt(t) {
                Q.call(this),
                this.type = "MeshDepthMaterial",
                this.depthPacking = Sa,
                this.skinning = !1,
                this.morphTargets = !1,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.setValues(t)
            }
            function et(t, e) {
                this.min = void 0 !== t ? t : new s((+(1 / 0)),(+(1 / 0)),(+(1 / 0))),
                this.max = void 0 !== e ? e : new s((-(1 / 0)),(-(1 / 0)),(-(1 / 0)))
            }
            function rt(t, e) {
                this.center = void 0 !== t ? t : new s,
                this.radius = void 0 !== e ? e : 0
            }
            function it() {
                this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]),
                arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            function nt(t, e) {
                this.normal = void 0 !== t ? t : new s(1,0,0),
                this.constant = void 0 !== e ? e : 0
            }
            function ot(t, e, r, i, n, o) {
                this.planes = [void 0 !== t ? t : new nt, void 0 !== e ? e : new nt, void 0 !== r ? r : new nt, void 0 !== i ? i : new nt, void 0 !== n ? n : new nt, void 0 !== o ? o : new nt]
            }
            function at(e, i, n, a) {
                function h(t, r, i, n) {
                    var o = t.geometry
                      , a = null
                      , s = M
                      , h = t.customDepthMaterial;
                    if (i && (s = S,
                    h = t.customDistanceMaterial),
                    h)
                        a = h;
                    else {
                        var c = !1;
                        r.morphTargets && (o && o.isBufferGeometry ? c = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (c = o.morphTargets && o.morphTargets.length > 0));
                        var l = t.isSkinnedMesh && r.skinning
                          , u = 0;
                        c && (u |= b),
                        l && (u |= w),
                        a = s[u]
                    }
                    if (e.localClippingEnabled && r.clipShadows === !0 && 0 !== r.clippingPlanes.length) {
                        var p = a.uuid
                          , d = r.uuid
                          , f = E[p];
                        void 0 === f && (f = {},
                        E[p] = f);
                        var m = f[d];
                        void 0 === m && (m = a.clone(),
                        f[d] = m),
                        a = m
                    }
                    a.visible = r.visible,
                    a.wireframe = r.wireframe;
                    var g = r.side;
                    return B.renderSingleSided && g == wn && (g = xn),
                    B.renderReverseSided && (g === xn ? g = bn : g === bn && (g = xn)),
                    a.side = g,
                    a.clipShadows = r.clipShadows,
                    a.clippingPlanes = r.clippingPlanes,
                    a.wireframeLinewidth = r.wireframeLinewidth,
                    a.linewidth = r.linewidth,
                    i && void 0 !== a.uniforms.lightPos && a.uniforms.lightPos.value.copy(n),
                    a
                }
                function c(t, e, r) {
                    if (t.visible !== !1) {
                        var i = 0 !== (t.layers.mask & e.layers.mask);
                        if (i && (t.isMesh || t.isLine || t.isPoints) && t.castShadow && (t.frustumCulled === !1 || p.intersectsObject(t) === !0)) {
                            var n = t.material;
                            n.visible === !0 && (t.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, t.matrixWorld),
                            x.push(t))
                        }
                        for (var o = t.children, a = 0, s = o.length; a < s; a++)
                            c(o[a], e, r)
                    }
                }
                var l = e.context
                  , u = e.state
                  , p = new ot
                  , d = new o
                  , f = i.shadows
                  , m = new r
                  , g = new r(a.maxTextureSize,a.maxTextureSize)
                  , v = new s
                  , y = new s
                  , x = []
                  , b = 1
                  , w = 2
                  , _ = (b | w) + 1
                  , M = new Array(_)
                  , S = new Array(_)
                  , E = {}
                  , T = [new s(1,0,0), new s((-1),0,0), new s(0,0,1), new s(0,0,(-1)), new s(0,1,0), new s(0,(-1),0)]
                  , A = [new s(0,1,0), new s(0,1,0), new s(0,1,0), new s(0,1,0), new s(0,0,1), new s(0,0,(-1))]
                  , L = [new Y, new Y, new Y, new Y, new Y, new Y]
                  , C = new tt;
                C.depthPacking = Ea,
                C.clipping = !0;
                for (var R = Uh.distanceRGBA, P = t.UniformsUtils.clone(R.uniforms), U = 0; U !== _; ++U) {
                    var I = 0 !== (U & b)
                      , D = 0 !== (U & w)
                      , O = C.clone();
                    O.morphTargets = I,
                    O.skinning = D,
                    M[U] = O;
                    var N = new K({
                        defines: {
                            USE_SHADOWMAP: ""
                        },
                        uniforms: P,
                        vertexShader: R.vertexShader,
                        fragmentShader: R.fragmentShader,
                        morphTargets: I,
                        skinning: D,
                        clipping: !0
                    });
                    S[U] = N
                }
                var B = this;
                this.enabled = !1,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this.type = vn,
                this.renderReverseSided = !0,
                this.renderSingleSided = !0,
                this.render = function(t, r) {
                    if (B.enabled !== !1 && (B.autoUpdate !== !1 || B.needsUpdate !== !1) && 0 !== f.length) {
                        u.clearColor(1, 1, 1, 1),
                        u.disable(l.BLEND),
                        u.setDepthTest(!0),
                        u.setScissorTest(!1);
                        for (var i, o, a = 0, s = f.length; a < s; a++) {
                            var b = f[a]
                              , w = b.shadow;
                            if (void 0 !== w) {
                                var _ = w.camera;
                                if (m.copy(w.mapSize),
                                m.min(g),
                                b && b.isPointLight) {
                                    i = 6,
                                    o = !0;
                                    var M = m.x
                                      , S = m.y;
                                    L[0].set(2 * M, S, M, S),
                                    L[1].set(0, S, M, S),
                                    L[2].set(3 * M, S, M, S),
                                    L[3].set(M, S, M, S),
                                    L[4].set(3 * M, 0, M, S),
                                    L[5].set(M, 0, M, S),
                                    m.x *= 4,
                                    m.y *= 2
                                } else
                                    i = 1,
                                    o = !1;
                                if (null === w.map) {
                                    var E = {
                                        minFilter: Mo,
                                        magFilter: Mo,
                                        format: jo
                                    };
                                    w.map = new Z(m.x,m.y,E),
                                    _.updateProjectionMatrix()
                                }
                                w && w.isSpotLightShadow && w.update(b);
                                var C = w.map
                                  , R = w.matrix;
                                y.setFromMatrixPosition(b.matrixWorld),
                                _.position.copy(y),
                                e.setRenderTarget(C),
                                e.clear();
                                for (var P = 0; P < i; P++) {
                                    if (o) {
                                        v.copy(_.position),
                                        v.add(T[P]),
                                        _.up.copy(A[P]),
                                        _.lookAt(v);
                                        var U = L[P];
                                        u.viewport(U)
                                    } else
                                        v.setFromMatrixPosition(b.target.matrixWorld),
                                        _.lookAt(v);
                                    _.updateMatrixWorld(),
                                    _.matrixWorldInverse.getInverse(_.matrixWorld),
                                    R.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                                    R.multiply(_.projectionMatrix),
                                    R.multiply(_.matrixWorldInverse),
                                    d.multiplyMatrices(_.projectionMatrix, _.matrixWorldInverse),
                                    p.setFromMatrix(d),
                                    x.length = 0,
                                    c(t, r, _);
                                    for (var I = 0, D = x.length; I < D; I++) {
                                        var O = x[I]
                                          , N = n.update(O)
                                          , F = O.material;
                                        if (F && F.isMultiMaterial)
                                            for (var k = N.groups, z = F.materials, V = 0, G = k.length; V < G; V++) {
                                                var j = k[V]
                                                  , H = z[j.materialIndex];
                                                if (H.visible === !0) {
                                                    var W = h(O, H, o, y);
                                                    e.renderBufferDirect(_, null, N, W, O, j)
                                                }
                                            }
                                        else {
                                            var W = h(O, F, o, y);
                                            e.renderBufferDirect(_, null, N, W, O, null)
                                        }
                                    }
                                }
                            } else
                                console.warn("THREE.WebGLShadowMap:", b, "has no shadow.")
                        }
                        var X = e.getClearColor()
                          , Y = e.getClearAlpha();
                        e.setClearColor(X, Y),
                        B.needsUpdate = !1
                    }
                }
            }
            function st(t) {
                for (var e = t.split("\n"), r = 0; r < e.length; r++)
                    e[r] = r + 1 + ": " + e[r];
                return e.join("\n")
            }
            function ht(t, e, r) {
                var i = t.createShader(e);
                return t.shaderSource(i, r),
                t.compileShader(i),
                t.getShaderParameter(i, t.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."),
                "" !== t.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(i), st(r)),
                i
            }
            function ct() {
                var t = {};
                return {
                    get: function(e) {
                        var r = e.uuid
                          , i = t[r];
                        return void 0 === i && (i = {},
                        t[r] = i),
                        i
                    },
                    delete: function(e) {
                        delete t[e.uuid]
                    },
                    clear: function() {
                        t = {}
                    }
                }
            }
            function lt(t) {
                switch (t) {
                case ga:
                    return ["Linear", "( value )"];
                case va:
                    return ["sRGB", "( value )"];
                case xa:
                    return ["RGBE", "( value )"];
                case wa:
                    return ["RGBM", "( value, 7.0 )"];
                case _a:
                    return ["RGBM", "( value, 16.0 )"];
                case Ma:
                    return ["RGBD", "( value, 256.0 )"];
                case ya:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    throw new Error("unsupported encoding: " + t)
                }
            }
            function ut(t, e) {
                var r = lt(e);
                return "vec4 " + t + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }"
            }
            function pt(t, e) {
                var r = lt(e);
                return "vec4 " + t + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }"
            }
            function dt(t, e) {
                var r;
                switch (e) {
                case so:
                    r = "Linear";
                    break;
                case ho:
                    r = "Reinhard";
                    break;
                case co:
                    r = "Uncharted2";
                    break;
                case lo:
                    r = "OptimizedCineon";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + e)
                }
                return "vec3 " + t + "( vec3 color ) { return " + r + "ToneMapping( color ); }"
            }
            function ft(t, e, r) {
                t = t || {};
                var i = [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && r.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && r.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && r.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                return i.filter(vt).join("\n")
            }
            function mt(t) {
                var e = [];
                for (var r in t) {
                    var i = t[r];
                    i !== !1 && e.push("#define " + r + " " + i)
                }
                return e.join("\n")
            }
            function gt(t, e, r) {
                for (var i = {}, n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), o = 0; o < n; o++) {
                    var a = t.getActiveAttrib(e, o)
                      , s = a.name;
                    i[s] = t.getAttribLocation(e, s)
                }
                return i
            }
            function vt(t) {
                return "" !== t
            }
            function yt(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            }
            function xt(t) {
                function e(t, e) {
                    var r = Rh[e];
                    if (void 0 === r)
                        throw new Error("Can not resolve #include <" + e + ">");
                    return xt(r)
                }
                var r = /#include +<([\w\d.]+)>/g;
                return t.replace(r, e)
            }
            function bt(t) {
                function e(t, e, r, i) {
                    for (var n = "", o = parseInt(e); o < parseInt(r); o++)
                        n += i.replace(/\[ i \]/g, "[ " + o + " ]");
                    return n
                }
                var r = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
                return t.replace(r, e)
            }
            function wt(t, e, r, i) {
                var n = t.context
                  , o = r.extensions
                  , a = r.defines
                  , s = r.__webglShader.vertexShader
                  , h = r.__webglShader.fragmentShader
                  , c = "SHADOWMAP_TYPE_BASIC";
                i.shadowMapType === vn ? c = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === yn && (c = "SHADOWMAP_TYPE_PCF_SOFT");
                var l = "ENVMAP_TYPE_CUBE"
                  , u = "ENVMAP_MODE_REFLECTION"
                  , p = "ENVMAP_BLENDING_MULTIPLY";
                if (i.envMap) {
                    switch (r.envMap.mapping) {
                    case po:
                    case fo:
                        l = "ENVMAP_TYPE_CUBE";
                        break;
                    case yo:
                    case xo:
                        l = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case mo:
                    case go:
                        l = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case vo:
                        l = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (r.envMap.mapping) {
                    case fo:
                    case go:
                        u = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (r.combine) {
                    case io:
                        p = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case no:
                        p = "ENVMAP_BLENDING_MIX";
                        break;
                    case oo:
                        p = "ENVMAP_BLENDING_ADD"
                    }
                }
                var d, f, m = t.gammaFactor > 0 ? t.gammaFactor : 1, g = ft(o, i, t.extensions), v = mt(a), y = n.createProgram();
                r.isRawShaderMaterial ? (d = [v, "\n"].filter(vt).join("\n"),
                f = [g, v, "\n"].filter(vt).join("\n")) : (d = ["precision " + i.precision + " float;", "precision " + i.precision + " int;", "#define SHADER_NAME " + r.__webglShader.name, v, i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + i.maxBones, i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + u : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && i.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + i.numClippingPlanes, i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + c : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(vt).join("\n"),
                f = [g, "precision " + i.precision + " float;", "precision " + i.precision + " int;", "#define SHADER_NAME " + r.__webglShader.name, v, i.alphaTest ? "#define ALPHATEST " + i.alphaTest : "", "#define GAMMA_FACTOR " + m, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + l : "", i.envMap ? "#define " + u : "", i.envMap ? "#define " + p : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + i.numClippingPlanes, i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + c : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", i.envMap && t.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", i.toneMapping !== ao ? "#define TONE_MAPPING" : "", i.toneMapping !== ao ? Rh.tonemapping_pars_fragment : "", i.toneMapping !== ao ? dt("toneMapping", i.toneMapping) : "", i.outputEncoding || i.mapEncoding || i.envMapEncoding || i.emissiveMapEncoding ? Rh.encodings_pars_fragment : "", i.mapEncoding ? ut("mapTexelToLinear", i.mapEncoding) : "", i.envMapEncoding ? ut("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMapEncoding ? ut("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.outputEncoding ? pt("linearToOutputTexel", i.outputEncoding) : "", i.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(vt).join("\n")),
                s = xt(s, i),
                s = yt(s, i),
                h = xt(h, i),
                h = yt(h, i),
                r.isShaderMaterial || (s = bt(s),
                h = bt(h));
                var x = d + s
                  , b = f + h
                  , w = ht(n, n.VERTEX_SHADER, x)
                  , _ = ht(n, n.FRAGMENT_SHADER, b);
                n.attachShader(y, w),
                n.attachShader(y, _),
                void 0 !== r.index0AttributeName ? n.bindAttribLocation(y, 0, r.index0AttributeName) : i.morphTargets === !0 && n.bindAttribLocation(y, 0, "position"),
                n.linkProgram(y);
                var M = n.getProgramInfoLog(y)
                  , S = n.getShaderInfoLog(w)
                  , E = n.getShaderInfoLog(_)
                  , T = !0
                  , A = !0;
                n.getProgramParameter(y, n.LINK_STATUS) === !1 ? (T = !1,
                console.error("THREE.WebGLProgram: shader error: ", n.getError(), "gl.VALIDATE_STATUS", n.getProgramParameter(y, n.VALIDATE_STATUS), "gl.getProgramInfoLog", M, S, E)) : "" !== M ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", M) : "" !== S && "" !== E || (A = !1),
                A && (this.diagnostics = {
                    runnable: T,
                    material: r,
                    programLog: M,
                    vertexShader: {
                        log: S,
                        prefix: d
                    },
                    fragmentShader: {
                        log: E,
                        prefix: f
                    }
                }),
                n.deleteShader(w),
                n.deleteShader(_);
                var L;
                this.getUniforms = function() {
                    return void 0 === L && (L = new W(n,y,t)),
                    L
                }
                ;
                var C;
                return this.getAttributes = function() {
                    return void 0 === C && (C = gt(n, y)),
                    C
                }
                ,
                this.destroy = function() {
                    n.deleteProgram(y),
                    this.program = void 0
                }
                ,
                Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                            this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                            this.getAttributes()
                        }
                    }
                }),
                this.id = Ih++,
                this.code = e,
                this.usedTimes = 1,
                this.program = y,
                this.vertexShader = w,
                this.fragmentShader = _,
                this
            }
            function _t(t, e) {
                function r(t) {
                    if (e.floatVertexTextures && t && t.skeleton && t.skeleton.useVertexTexture)
                        return 1024;
                    var r = e.maxVertexUniforms
                      , i = Math.floor((r - 20) / 4)
                      , n = i;
                    return void 0 !== t && t && t.isSkinnedMesh && (n = Math.min(t.skeleton.bones.length, n),
                    n < t.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + t.skeleton.bones.length + ", this GPU supports just " + n + " (try OpenGL instead of ANGLE)")),
                    n
                }
                function i(t, e) {
                    var r;
                    return t ? t && t.isTexture ? r = t.encoding : t && t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
                    r = t.texture.encoding) : r = ga,
                    r === ga && e && (r = ya),
                    r
                }
                var n = []
                  , o = {
                    MeshDepthMaterial: "depth",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points"
                }
                  , a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"];
                this.getParameters = function(n, a, s, h, c) {
                    var l = o[n.type]
                      , u = r(c)
                      , p = t.getPrecision();
                    null !== n.precision && (p = e.getMaxPrecision(n.precision),
                    p !== n.precision && console.warn("THREE.WebGLProgram.getParameters:", n.precision, "not supported, using", p, "instead."));
                    var d = t.getCurrentRenderTarget()
                      , f = {
                        shaderID: l,
                        precision: p,
                        supportsVertexTextures: e.vertexTextures,
                        outputEncoding: i(d ? d.texture : null, t.gammaOutput),
                        map: !!n.map,
                        mapEncoding: i(n.map, t.gammaInput),
                        envMap: !!n.envMap,
                        envMapMode: n.envMap && n.envMap.mapping,
                        envMapEncoding: i(n.envMap, t.gammaInput),
                        envMapCubeUV: !!n.envMap && (n.envMap.mapping === yo || n.envMap.mapping === xo),
                        lightMap: !!n.lightMap,
                        aoMap: !!n.aoMap,
                        emissiveMap: !!n.emissiveMap,
                        emissiveMapEncoding: i(n.emissiveMap, t.gammaInput),
                        bumpMap: !!n.bumpMap,
                        normalMap: !!n.normalMap,
                        displacementMap: !!n.displacementMap,
                        roughnessMap: !!n.roughnessMap,
                        metalnessMap: !!n.metalnessMap,
                        specularMap: !!n.specularMap,
                        alphaMap: !!n.alphaMap,
                        combine: n.combine,
                        vertexColors: n.vertexColors,
                        fog: !!s,
                        useFog: n.fog,
                        fogExp: s && s.isFogExp2,
                        flatShading: n.shading === _n,
                        sizeAttenuation: n.sizeAttenuation,
                        logarithmicDepthBuffer: e.logarithmicDepthBuffer,
                        skinning: n.skinning,
                        maxBones: u,
                        useVertexTexture: e.floatVertexTextures && c && c.skeleton && c.skeleton.useVertexTexture,
                        morphTargets: n.morphTargets,
                        morphNormals: n.morphNormals,
                        maxMorphTargets: t.maxMorphTargets,
                        maxMorphNormals: t.maxMorphNormals,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numHemiLights: a.hemi.length,
                        numClippingPlanes: h,
                        shadowMapEnabled: t.shadowMap.enabled && c.receiveShadow && a.shadows.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: t.toneMapping,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: n.premultipliedAlpha,
                        alphaTest: n.alphaTest,
                        doubleSided: n.side === wn,
                        flipSided: n.side === bn,
                        depthPacking: void 0 !== n.depthPacking && n.depthPacking
                    };
                    return f
                }
                ,
                this.getProgramCode = function(t, e) {
                    var r = [];
                    if (e.shaderID ? r.push(e.shaderID) : (r.push(t.fragmentShader),
                    r.push(t.vertexShader)),
                    void 0 !== t.defines)
                        for (var i in t.defines)
                            r.push(i),
                            r.push(t.defines[i]);
                    for (var n = 0; n < a.length; n++)
                        r.push(e[a[n]]);
                    return r.join()
                }
                ,
                this.acquireProgram = function(e, r, i) {
                    for (var o, a = 0, s = n.length; a < s; a++) {
                        var h = n[a];
                        if (h.code === i) {
                            o = h,
                            ++o.usedTimes;
                            break
                        }
                    }
                    return void 0 === o && (o = new wt(t,i,e,r),
                    n.push(o)),
                    o
                }
                ,
                this.releaseProgram = function(t) {
                    if (0 === --t.usedTimes) {
                        var e = n.indexOf(t);
                        n[e] = n[n.length - 1],
                        n.pop(),
                        t.destroy()
                    }
                }
                ,
                this.programs = n
            }
            function Mt(e, r, i) {
                if (Array.isArray(e))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.uuid = t.Math.generateUUID(),
                this.array = e,
                this.itemSize = r,
                this.normalized = i === !0,
                this.dynamic = !1,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0
            }
            function St(t, e) {
                return new Mt(new Int8Array(t),e)
            }
            function Et(t, e) {
                return new Mt(new Uint8Array(t),e)
            }
            function Tt(t, e) {
                return new Mt(new Uint8ClampedArray(t),e)
            }
            function At(t, e) {
                return new Mt(new Int16Array(t),e)
            }
            function Lt(t, e) {
                return new Mt(new Uint16Array(t),e)
            }
            function Ct(t, e) {
                return new Mt(new Int32Array(t),e)
            }
            function Rt(t, e) {
                return new Mt(new Uint32Array(t),e)
            }
            function Pt(t, e) {
                return new Mt(new Float32Array(t),e)
            }
            function Ut(t, e) {
                return new Mt(new Float64Array(t),e)
            }
            function It(t, e) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
                new Mt(t,e).setDynamic(!0)
            }
            function Dt(t, e, r, i, n, o) {
                this.a = t,
                this.b = e,
                this.c = r,
                this.normal = i && i.isVector3 ? i : new s,
                this.vertexNormals = Array.isArray(i) ? i : [],
                this.color = n && n.isColor ? n : new $,
                this.vertexColors = Array.isArray(n) ? n : [],
                this.materialIndex = void 0 !== o ? o : 0
            }
            function Ot(t, e, r, i) {
                this._x = t || 0,
                this._y = e || 0,
                this._z = r || 0,
                this._order = i || Ot.DefaultOrder
            }
            function Nt() {
                this.mask = 1
            }
            function Bt() {
                function e() {
                    h.setFromEuler(n, !1)
                }
                function r() {
                    n.setFromQuaternion(h, void 0, !1)
                }
                Object.defineProperty(this, "id", {
                    value: Ft()
                }),
                this.uuid = t.Math.generateUUID(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = Bt.DefaultUp.clone();
                var i = new s
                  , n = new Ot
                  , h = new a
                  , c = new s(1,1,1);
                n.onChange(e),
                h.onChange(r),
                Object.defineProperties(this, {
                    position: {
                        enumerable: !0,
                        value: i
                    },
                    rotation: {
                        enumerable: !0,
                        value: n
                    },
                    quaternion: {
                        enumerable: !0,
                        value: h
                    },
                    scale: {
                        enumerable: !0,
                        value: c
                    },
                    modelViewMatrix: {
                        value: new o
                    },
                    normalMatrix: {
                        value: new it
                    }
                }),
                this.matrix = new o,
                this.matrixWorld = new o,
                this.matrixAutoUpdate = Bt.DefaultMatrixAutoUpdate,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new Nt,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.userData = {}
            }
            function Ft() {
                return Dh++
            }
            function kt() {
                Object.defineProperty(this, "id", {
                    value: zt()
                }),
                this.uuid = t.Math.generateUUID(),
                this.name = "",
                this.type = "Geometry",
                this.vertices = [],
                this.colors = [],
                this.faces = [],
                this.faceVertexUvs = [[]],
                this.morphTargets = [],
                this.morphNormals = [],
                this.skinWeights = [],
                this.skinIndices = [],
                this.lineDistances = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.elementsNeedUpdate = !1,
                this.verticesNeedUpdate = !1,
                this.uvsNeedUpdate = !1,
                this.normalsNeedUpdate = !1,
                this.colorsNeedUpdate = !1,
                this.lineDistancesNeedUpdate = !1,
                this.groupsNeedUpdate = !1
            }
            function zt() {
                return Oh++
            }
            function Vt() {
                Object.defineProperty(this, "id", {
                    value: zt()
                }),
                this.uuid = t.Math.generateUUID(),
                this.name = "",
                this.type = "DirectGeometry",
                this.indices = [],
                this.vertices = [],
                this.normals = [],
                this.colors = [],
                this.uvs = [],
                this.uvs2 = [],
                this.groups = [],
                this.morphTargets = {},
                this.skinWeights = [],
                this.skinIndices = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.verticesNeedUpdate = !1,
                this.normalsNeedUpdate = !1,
                this.colorsNeedUpdate = !1,
                this.uvsNeedUpdate = !1,
                this.groupsNeedUpdate = !1
            }
            function Gt() {
                Object.defineProperty(this, "id", {
                    value: zt()
                }),
                this.uuid = t.Math.generateUUID(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }
            }
            function jt(t, e, r) {
                function i(t) {
                    var n = t.target
                      , s = h[n.id];
                    null !== s.index && o(s.index),
                    a(s.attributes),
                    n.removeEventListener("dispose", i),
                    delete h[n.id];
                    var c = e.get(n);
                    c.wireframe && o(c.wireframe),
                    e.delete(n);
                    var l = e.get(s);
                    l.wireframe && o(l.wireframe),
                    e.delete(s),
                    r.memory.geometries--
                }
                function n(t) {
                    return t.isInterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer
                }
                function o(e) {
                    var r = n(e);
                    void 0 !== r && (t.deleteBuffer(r),
                    s(e))
                }
                function a(t) {
                    for (var e in t)
                        o(t[e])
                }
                function s(t) {
                    t.isInterleavedBufferAttribute ? e.delete(t.data) : e.delete(t)
                }
                var h = {};
                return {
                    get: function(t) {
                        var e = t.geometry;
                        if (void 0 !== h[e.id])
                            return h[e.id];
                        e.addEventListener("dispose", i);
                        var n;
                        return e.isBufferGeometry ? n = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Gt).setFromObject(t)),
                        n = e._bufferGeometry),
                        h[e.id] = n,
                        r.memory.geometries++,
                        n
                    }
                }
            }
            function Ht(t, e, r) {
                function i(e) {
                    var r = l.get(e);
                    e.geometry.isGeometry && r.updateFromObject(e);
                    var i = r.index
                      , o = r.attributes;
                    null !== i && n(i, t.ELEMENT_ARRAY_BUFFER);
                    for (var a in o)
                        n(o[a], t.ARRAY_BUFFER);
                    var s = r.morphAttributes;
                    for (var a in s)
                        for (var h = s[a], c = 0, u = h.length; c < u; c++)
                            n(h[c], t.ARRAY_BUFFER);
                    return r
                }
                function n(t, r) {
                    var i = t.isInterleavedBufferAttribute ? t.data : t
                      , n = e.get(i);
                    void 0 === n.__webglBuffer ? o(n, i, r) : n.version !== i.version && a(n, i, r)
                }
                function o(e, r, i) {
                    e.__webglBuffer = t.createBuffer(),
                    t.bindBuffer(i, e.__webglBuffer);
                    var n = r.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW;
                    t.bufferData(i, r.array, n),
                    e.version = r.version
                }
                function a(e, r, i) {
                    t.bindBuffer(i, e.__webglBuffer),
                    r.dynamic === !1 || r.updateRange.count === -1 ? t.bufferSubData(i, 0, r.array) : 0 === r.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(i, r.updateRange.offset * r.array.BYTES_PER_ELEMENT, r.array.subarray(r.updateRange.offset, r.updateRange.offset + r.updateRange.count)),
                    r.updateRange.count = 0),
                    e.version = r.version
                }
                function s(t) {
                    return t.isInterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer
                }
                function h(r) {
                    var i = e.get(r);
                    if (void 0 !== i.wireframe)
                        return i.wireframe;
                    var o = []
                      , a = r.index
                      , s = r.attributes
                      , h = s.position;
                    if (null !== a)
                        for (var l = {}, u = a.array, p = 0, d = u.length; p < d; p += 3) {
                            var f = u[p + 0]
                              , m = u[p + 1]
                              , g = u[p + 2];
                            c(l, f, m) && o.push(f, m),
                            c(l, m, g) && o.push(m, g),
                            c(l, g, f) && o.push(g, f)
                        }
                    else
                        for (var u = s.position.array, p = 0, d = u.length / 3 - 1; p < d; p += 3) {
                            var f = p + 0
                              , m = p + 1
                              , g = p + 2;
                            o.push(f, m, m, g, g, f)
                        }
                    var v = h.count > 65535 ? Uint32Array : Uint16Array
                      , y = new Mt(new v(o),1);
                    return n(y, t.ELEMENT_ARRAY_BUFFER),
                    i.wireframe = y,
                    y
                }
                function c(t, e, r) {
                    if (e > r) {
                        var i = e;
                        e = r,
                        r = i
                    }
                    var n = t[e];
                    return void 0 === n ? (t[e] = [r],
                    !0) : n.indexOf(r) === -1 && (n.push(r),
                    !0)
                }
                var l = new jt(t,e,r);
                return {
                    getAttributeBuffer: s,
                    getWireframeAttribute: h,
                    update: i
                }
            }
            function Wt() {
                var t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id])
                            return t[e.id];
                        var i;
                        switch (e.type) {
                        case "DirectionalLight":
                            i = {
                                direction: new s,
                                color: new $,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new r
                            };
                            break;
                        case "SpotLight":
                            i = {
                                position: new s,
                                direction: new s,
                                color: new $,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new r
                            };
                            break;
                        case "PointLight":
                            i = {
                                position: new s,
                                color: new $,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new r
                            };
                            break;
                        case "HemisphereLight":
                            i = {
                                direction: new s,
                                skyColor: new $,
                                groundColor: new $
                            }
                        }
                        return t[e.id] = i,
                        i
                    }
                }
            }
            function Xt(t, e, r) {
                function i() {
                    if (void 0 !== o)
                        return o;
                    var r = e.get("EXT_texture_filter_anisotropic");
                    return o = null !== r ? t.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                }
                function n(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
                            return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                var o, a = void 0 !== r.precision ? r.precision : "highp", s = n(a);
                s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."),
                a = s);
                var h = r.logarithmicDepthBuffer === !0 && !!e.get("EXT_frag_depth")
                  , c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
                  , l = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                  , u = t.getParameter(t.MAX_TEXTURE_SIZE)
                  , p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)
                  , d = t.getParameter(t.MAX_VERTEX_ATTRIBS)
                  , f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)
                  , m = t.getParameter(t.MAX_VARYING_VECTORS)
                  , g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS)
                  , v = l > 0
                  , y = !!e.get("OES_texture_float")
                  , x = v && y;
                return {
                    getMaxAnisotropy: i,
                    getMaxPrecision: n,
                    precision: a,
                    logarithmicDepthBuffer: h,
                    maxTextures: c,
                    maxVertexTextures: l,
                    maxTextureSize: u,
                    maxCubemapSize: p,
                    maxAttributes: d,
                    maxVertexUniforms: f,
                    maxVaryings: m,
                    maxFragmentUniforms: g,
                    vertexTextures: v,
                    floatFragmentTextures: y,
                    floatVertexTextures: x
                }
            }
            function Yt(t) {
                var e = {};
                return {
                    get: function(r) {
                        if (void 0 !== e[r])
                            return e[r];
                        var i;
                        switch (r) {
                        case "WEBGL_depth_texture":
                            i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case "WEBGL_compressed_texture_etc1":
                            i = t.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            i = t.getExtension(r)
                        }
                        return null === i && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."),
                        e[r] = i,
                        i
                    }
                }
            }
            function qt(t, e, r) {
                function i(t) {
                    s = t
                }
                function n(r) {
                    r.array instanceof Uint32Array && e.get("OES_element_index_uint") ? (h = t.UNSIGNED_INT,
                    c = 4) : (h = t.UNSIGNED_SHORT,
                    c = 2)
                }
                function o(e, i) {
                    t.drawElements(s, i, h, e * c),
                    r.calls++,
                    r.vertices += i,
                    s === t.TRIANGLES && (r.faces += i / 3)
                }
                function a(i, n, o) {
                    var a = e.get("ANGLE_instanced_arrays");
                    return null === a ? void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (a.drawElementsInstancedANGLE(s, o, h, n * c, i.maxInstancedCount),
                    r.calls++,
                    r.vertices += o * i.maxInstancedCount,
                    void (s === t.TRIANGLES && (r.faces += i.maxInstancedCount * o / 3)))
                }
                var s, h, c;
                return {
                    setMode: i,
                    setIndex: n,
                    render: o,
                    renderInstances: a
                }
            }
            function Zt() {
                function t() {
                    c.value !== i && (c.value = i,
                    c.needsUpdate = n > 0),
                    r.numPlanes = n
                }
                function e(t, e, i, n) {
                    var o = null !== t ? t.length : 0
                      , a = null;
                    if (0 !== o) {
                        if (a = c.value,
                        n !== !0 || null === a) {
                            var l = i + 4 * o
                              , u = e.matrixWorldInverse;
                            h.getNormalMatrix(u),
                            (null === a || a.length < l) && (a = new Float32Array(l));
                            for (var p = 0, d = i; p !== o; ++p,
                            d += 4)
                                s.copy(t[p]).applyMatrix4(u, h),
                                s.normal.toArray(a, d),
                                a[d + 3] = s.constant
                        }
                        c.value = a,
                        c.needsUpdate = !0
                    }
                    return r.numPlanes = o,
                    a
                }
                var r = this
                  , i = null
                  , n = 0
                  , o = !1
                  , a = !1
                  , s = new nt
                  , h = new it
                  , c = {
                    value: null,
                    needsUpdate: !1
                };
                this.uniform = c,
                this.numPlanes = 0,
                this.init = function(t, r, a) {
                    var s = 0 !== t.length || r || 0 !== n || o;
                    return o = r,
                    i = e(t, a, 0),
                    n = t.length,
                    s
                }
                ,
                this.beginShadows = function() {
                    a = !0,
                    e(null)
                }
                ,
                this.endShadows = function() {
                    a = !1,
                    t()
                }
                ,
                this.setState = function(r, s, h, l, u) {
                    if (!o || null === r || 0 === r.length || a && !s)
                        a ? e(null) : t();
                    else {
                        var p = a ? 0 : n
                          , d = 4 * p
                          , f = l.clippingState || null;
                        c.value = f,
                        f = e(r, h, d, u);
                        for (var m = 0; m !== d; ++m)
                            f[m] = i[m];
                        l.clippingState = f,
                        this.numPlanes += p
                    }
                }
            }
            function Qt(t, e, r) {
                function i(t) {
                    a = t
                }
                function n(e, i) {
                    t.drawArrays(a, e, i),
                    r.calls++,
                    r.vertices += i,
                    a === t.TRIANGLES && (r.faces += i / 3)
                }
                function o(i) {
                    var n = e.get("ANGLE_instanced_arrays");
                    if (null === n)
                        return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    var o = i.attributes.position
                      , s = 0;
                    o && o.isInterleavedBufferAttribute ? (s = o.data.count,
                    n.drawArraysInstancedANGLE(a, 0, s, i.maxInstancedCount)) : (s = o.count,
                    n.drawArraysInstancedANGLE(a, 0, s, i.maxInstancedCount)),
                    r.calls++,
                    r.vertices += s * i.maxInstancedCount,
                    a === t.TRIANGLES && (r.faces += i.maxInstancedCount * s / 3)
                }
                var a;
                return {
                    setMode: i,
                    render: n,
                    renderInstances: o
                }
            }
            function Jt(t, e, r) {
                Z.call(this, t, e, r),
                this.activeCubeFace = 0,
                this.activeMipMapLevel = 0
            }
            function Kt(t, e, r, i, n, o) {
                function a(t, e, r) {
                    var i = 0;
                    return i += (t + 1) * (e + 1) * 2,
                    i += (t + 1) * (r + 1) * 2,
                    i += (r + 1) * (e + 1) * 2
                }
                function h(t, e, r) {
                    var i = 0;
                    return i += t * e * 2,
                    i += t * r * 2,
                    i += r * e * 2,
                    6 * i
                }
                function c(t, e, r, i, n, o, a, h, c, u, p) {
                    for (var _ = o / c, M = a / u, S = o / 2, E = a / 2, T = h / 2, A = c + 1, L = u + 1, C = 0, R = 0, P = new s, U = 0; U < L; U++)
                        for (var I = U * M - E, D = 0; D < A; D++) {
                            var O = D * _ - S;
                            P[t] = O * i,
                            P[e] = I * n,
                            P[r] = T,
                            f[v] = P.x,
                            f[v + 1] = P.y,
                            f[v + 2] = P.z,
                            P[t] = 0,
                            P[e] = 0,
                            P[r] = h > 0 ? 1 : -1,
                            m[v] = P.x,
                            m[v + 1] = P.y,
                            m[v + 2] = P.z,
                            g[y] = D / c,
                            g[y + 1] = 1 - U / u,
                            v += 3,
                            y += 2,
                            C += 1
                        }
                    for (U = 0; U < u; U++)
                        for (D = 0; D < c; D++) {
                            var N = b + D + A * U
                              , B = b + D + A * (U + 1)
                              , F = b + (D + 1) + A * (U + 1)
                              , k = b + (D + 1) + A * U;
                            d[x] = N,
                            d[x + 1] = B,
                            d[x + 2] = k,
                            d[x + 3] = B,
                            d[x + 4] = F,
                            d[x + 5] = k,
                            x += 6,
                            R += 6
                        }
                    l.addGroup(w, R, p),
                    w += R,
                    b += C
                }
                Gt.call(this),
                this.type = "BoxBufferGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    depth: r,
                    widthSegments: i,
                    heightSegments: n,
                    depthSegments: o
                };
                var l = this;
                i = Math.floor(i) || 1,
                n = Math.floor(n) || 1,
                o = Math.floor(o) || 1;
                var u = a(i, n, o)
                  , p = h(i, n, o)
                  , d = new (p > 65535 ? Uint32Array : Uint16Array)(p)
                  , f = new Float32Array(3 * u)
                  , m = new Float32Array(3 * u)
                  , g = new Float32Array(2 * u)
                  , v = 0
                  , y = 0
                  , x = 0
                  , b = 0
                  , w = 0;
                c("z", "y", "x", -1, -1, r, e, t, o, n, 0),
                c("z", "y", "x", 1, -1, r, e, -t, o, n, 1),
                c("x", "z", "y", 1, 1, t, r, e, i, o, 2),
                c("x", "z", "y", 1, -1, t, r, -e, i, o, 3),
                c("x", "y", "z", 1, -1, t, e, r, i, n, 4),
                c("x", "y", "z", -1, -1, t, e, -r, i, n, 5),
                this.setIndex(new Mt(d,1)),
                this.addAttribute("position", new Mt(f,3)),
                this.addAttribute("normal", new Mt(m,3)),
                this.addAttribute("uv", new Mt(g,2))
            }
            function $t(t, e) {
                this.origin = void 0 !== t ? t : new s,
                this.direction = void 0 !== e ? e : new s
            }
            function te(t, e) {
                this.start = void 0 !== t ? t : new s,
                this.end = void 0 !== e ? e : new s
            }
            function ee(t, e, r) {
                this.a = void 0 !== t ? t : new s,
                this.b = void 0 !== e ? e : new s,
                this.c = void 0 !== r ? r : new s
            }
            function re(t) {
                Q.call(this),
                this.type = "MeshBasicMaterial",
                this.color = new $(16777215),
                this.map = null,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = io,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.lights = !1,
                this.setValues(t)
            }
            function ie(t, e) {
                Bt.call(this),
                this.type = "Mesh",
                this.geometry = void 0 !== t ? t : new Gt,
                this.material = void 0 !== e ? e : new re({
                    color: 16777215 * Math.random()
                }),
                this.drawMode = da,
                this.updateMorphTargets()
            }
            function ne(t, e, r, i) {
                Gt.call(this),
                this.type = "PlaneBufferGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: r,
                    heightSegments: i
                };
                for (var n = t / 2, o = e / 2, a = Math.floor(r) || 1, s = Math.floor(i) || 1, h = a + 1, c = s + 1, l = t / a, u = e / s, p = new Float32Array(h * c * 3), d = new Float32Array(h * c * 3), f = new Float32Array(h * c * 2), m = 0, g = 0, v = 0; v < c; v++)
                    for (var y = v * u - o, x = 0; x < h; x++) {
                        var b = x * l - n;
                        p[m] = b,
                        p[m + 1] = -y,
                        d[m + 2] = 1,
                        f[g] = x / a,
                        f[g + 1] = 1 - v / s,
                        m += 3,
                        g += 2
                    }
                m = 0;
                for (var w = new (p.length / 3 > 65535 ? Uint32Array : Uint16Array)(a * s * 6), v = 0; v < s; v++)
                    for (var x = 0; x < a; x++) {
                        var _ = x + h * v
                          , M = x + h * (v + 1)
                          , S = x + 1 + h * (v + 1)
                          , E = x + 1 + h * v;
                        w[m] = _,
                        w[m + 1] = M,
                        w[m + 2] = E,
                        w[m + 3] = M,
                        w[m + 4] = S,
                        w[m + 5] = E,
                        m += 6
                    }
                this.setIndex(new Mt(w,1)),
                this.addAttribute("position", new Mt(p,3)),
                this.addAttribute("normal", new Mt(d,3)),
                this.addAttribute("uv", new Mt(f,2))
            }
            function oe() {
                Bt.call(this),
                this.type = "Camera",
                this.matrixWorldInverse = new o,
                this.projectionMatrix = new o
            }
            function ae(t, e, r, i) {
                oe.call(this),
                this.type = "PerspectiveCamera",
                this.fov = void 0 !== t ? t : 50,
                this.zoom = 1,
                this.near = void 0 !== r ? r : .1,
                this.far = void 0 !== i ? i : 2e3,
                this.focus = 10,
                this.aspect = void 0 !== e ? e : 1,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            function se(t, e, r, i, n, o) {
                oe.call(this),
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = t,
                this.right = e,
                this.top = r,
                this.bottom = i,
                this.near = void 0 !== n ? n : .1,
                this.far = void 0 !== o ? o : 2e3,
                this.updateProjectionMatrix()
            }
            function he(e) {
                function r() {
                    return null === mt ? Ct : 1
                }
                function i(t, e, r, i) {
                    J === !0 && (t *= i,
                    e *= i,
                    r *= i),
                    ee.clearColor(t, e, r, i)
                }
                function n() {
                    ee.init(),
                    ee.scissor(bt.copy(Rt).multiplyScalar(Ct)),
                    ee.viewport(Mt.copy(Ut).multiplyScalar(Ct)),
                    i(Et.r, Et.g, Et.b, Tt)
                }
                function a() {
                    ft = null,
                    xt = null,
                    yt = "",
                    vt = -1,
                    ee.reset()
                }
                function c(t) {
                    t.preventDefault(),
                    a(),
                    n(),
                    oe.clear()
                }
                function u(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", u),
                    p(e)
                }
                function p(t) {
                    d(t),
                    oe.delete(t)
                }
                function d(t) {
                    var e = oe.get(t).program;
                    t.program = void 0,
                    void 0 !== e && le.releaseProgram(e)
                }
                function f(t, e, r, i) {
                    var n;
                    if (r && r.isInstancedBufferGeometry && (n = $t.get("ANGLE_instanced_arrays"),
                    null === n))
                        return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    void 0 === i && (i = 0),
                    ee.initAttributes();
                    var o = r.attributes
                      , a = e.getAttributes()
                      , s = t.defaultAttributeValues;
                    for (var h in a) {
                        var c = a[h];
                        if (c >= 0) {
                            var l = o[h];
                            if (void 0 !== l) {
                                var u = jt.FLOAT
                                  , p = l.array
                                  , d = l.normalized;
                                p instanceof Float32Array ? u = jt.FLOAT : p instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : p instanceof Uint16Array ? u = jt.UNSIGNED_SHORT : p instanceof Int16Array ? u = jt.SHORT : p instanceof Uint32Array ? u = jt.UNSIGNED_INT : p instanceof Int32Array ? u = jt.INT : p instanceof Int8Array ? u = jt.BYTE : p instanceof Uint8Array && (u = jt.UNSIGNED_BYTE);
                                var f = l.itemSize
                                  , m = ce.getAttributeBuffer(l);
                                if (l && l.isInterleavedBufferAttribute) {
                                    var g = l.data
                                      , v = g.stride
                                      , y = l.offset;
                                    g && g.isInstancedInterleavedBuffer ? (ee.enableAttributeAndDivisor(c, g.meshPerAttribute, n),
                                    void 0 === r.maxInstancedCount && (r.maxInstancedCount = g.meshPerAttribute * g.count)) : ee.enableAttribute(c),
                                    jt.bindBuffer(jt.ARRAY_BUFFER, m),
                                    jt.vertexAttribPointer(c, f, u, d, v * g.array.BYTES_PER_ELEMENT, (i * v + y) * g.array.BYTES_PER_ELEMENT)
                                } else
                                    l && l.isInstancedBufferAttribute ? (ee.enableAttributeAndDivisor(c, l.meshPerAttribute, n),
                                    void 0 === r.maxInstancedCount && (r.maxInstancedCount = l.meshPerAttribute * l.count)) : ee.enableAttribute(c),
                                    jt.bindBuffer(jt.ARRAY_BUFFER, m),
                                    jt.vertexAttribPointer(c, f, u, d, 0, i * f * l.array.BYTES_PER_ELEMENT)
                            } else if (void 0 !== s) {
                                var x = s[h];
                                if (void 0 !== x)
                                    switch (x.length) {
                                    case 2:
                                        jt.vertexAttrib2fv(c, x);
                                        break;
                                    case 3:
                                        jt.vertexAttrib3fv(c, x);
                                        break;
                                    case 4:
                                        jt.vertexAttrib4fv(c, x);
                                        break;
                                    default:
                                        jt.vertexAttrib1fv(c, x)
                                    }
                            }
                        }
                    }
                    ee.disableUnusedAttributes()
                }
                function m(t, e) {
                    return Math.abs(e[0]) - Math.abs(t[0])
                }
                function g(t, e) {
                    return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.material.program && e.material.program && t.material.program !== e.material.program ? t.material.program.id - e.material.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                }
                function v(t, e) {
                    return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                }
                function y(t, e, r, i, n) {
                    var o, a;
                    r.transparent ? (o = st,
                    a = ++ht) : (o = it,
                    a = ++nt);
                    var s = o[a];
                    void 0 !== s ? (s.id = t.id,
                    s.object = t,
                    s.geometry = e,
                    s.material = r,
                    s.z = kt.z,
                    s.group = n) : (s = {
                        id: t.id,
                        object: t,
                        geometry: e,
                        material: r,
                        z: kt.z,
                        group: n
                    },
                    o.push(s))
                }
                function x(t) {
                    var e = t.geometry;
                    return null === e.boundingSphere && e.computeBoundingSphere(),
                    Bt.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                    w(Bt)
                }
                function b(t) {
                    return Bt.center.set(0, 0, 0),
                    Bt.radius = .7071067811865476,
                    Bt.applyMatrix4(t.matrixWorld),
                    w(Bt)
                }
                function w(t) {
                    if (!It.intersectsSphere(t))
                        return !1;
                    var e = Dt.numPlanes;
                    if (0 === e)
                        return !0;
                    var r = dt.clippingPlanes
                      , i = t.center
                      , n = -t.radius
                      , o = 0;
                    do
                        if (r[o].distanceToPoint(i) < n)
                            return !1;
                    while (++o !== e);
                    return !0
                }
                function _(t, e) {
                    if (t.visible !== !1) {
                        var r = 0 !== (t.layers.mask & e.layers.mask);
                        if (r)
                            if (t.isLight)
                                et.push(t);
                            else if (t.isSprite)
                                t.frustumCulled !== !1 && b(t) !== !0 || ut.push(t);
                            else if (t.isLensFlare)
                                pt.push(t);
                            else if (t.isImmediateRenderObject)
                                dt.sortObjects === !0 && (kt.setFromMatrixPosition(t.matrixWorld),
                                kt.applyProjection(Ft)),
                                y(t, null, t.material, kt.z, null);
                            else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(),
                            t.frustumCulled === !1 || x(t) === !0)) {
                                var i = t.material;
                                if (i.visible === !0) {
                                    dt.sortObjects === !0 && (kt.setFromMatrixPosition(t.matrixWorld),
                                    kt.applyProjection(Ft));
                                    var n = ce.update(t);
                                    if (i.isMultiMaterial)
                                        for (var o = n.groups, a = i.materials, s = 0, h = o.length; s < h; s++) {
                                            var c = o[s]
                                              , l = a[c.materialIndex];
                                            l.visible === !0 && y(t, n, l, kt.z, c)
                                        }
                                    else
                                        y(t, n, i, kt.z, null)
                                }
                            }
                        for (var u = t.children, s = 0, h = u.length; s < h; s++)
                            _(u[s], e)
                    }
                }
                function M(t, e, r, i) {
                    for (var n = 0, o = t.length; n < o; n++) {
                        var a = t[n]
                          , s = a.object
                          , h = a.geometry
                          , c = void 0 === i ? a.material : i
                          , l = a.group;
                        if (s.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, s.matrixWorld),
                        s.normalMatrix.getNormalMatrix(s.modelViewMatrix),
                        s.isImmediateRenderObject) {
                            E(c);
                            var u = T(e, r, c, s);
                            yt = "",
                            s.render(function(t) {
                                dt.renderBufferImmediate(t, u, c)
                            })
                        } else
                            dt.renderBufferDirect(e, r, h, c, s, l)
                    }
                }
                function S(e, r, i) {
                    var n = oe.get(e)
                      , o = le.getParameters(e, zt, r, Dt.numPlanes, i)
                      , a = le.getProgramCode(e, o)
                      , s = n.program
                      , h = !0;
                    if (void 0 === s)
                        e.addEventListener("dispose", u);
                    else if (s.code !== a)
                        d(e);
                    else {
                        if (void 0 !== o.shaderID)
                            return;
                        h = !1
                    }
                    if (h) {
                        if (o.shaderID) {
                            var c = Uh[o.shaderID];
                            n.__webglShader = {
                                name: e.type,
                                uniforms: t.UniformsUtils.clone(c.uniforms),
                                vertexShader: c.vertexShader,
                                fragmentShader: c.fragmentShader
                            }
                        } else
                            n.__webglShader = {
                                name: e.type,
                                uniforms: e.uniforms,
                                vertexShader: e.vertexShader,
                                fragmentShader: e.fragmentShader
                            };
                        e.__webglShader = n.__webglShader,
                        s = le.acquireProgram(e, o, a),
                        n.program = s,
                        e.program = s
                    }
                    var l = s.getAttributes();
                    if (e.morphTargets) {
                        e.numSupportedMorphTargets = 0;
                        for (var p = 0; p < dt.maxMorphTargets; p++)
                            l["morphTarget" + p] >= 0 && e.numSupportedMorphTargets++
                    }
                    if (e.morphNormals) {
                        e.numSupportedMorphNormals = 0;
                        for (var p = 0; p < dt.maxMorphNormals; p++)
                            l["morphNormal" + p] >= 0 && e.numSupportedMorphNormals++
                    }
                    var f = n.__webglShader.uniforms;
                    !e.isShaderMaterial && !e.isRawShaderMaterial | e.clipping === !0 && (n.numClippingPlanes = Dt.numPlanes,
                    f.clippingPlanes = Dt.uniform),
                    n.fog = r,
                    n.lightsHash = zt.hash,
                    e.lights && (f.ambientLightColor.value = zt.ambient,
                    f.directionalLights.value = zt.directional,
                    f.spotLights.value = zt.spot,
                    f.pointLights.value = zt.point,
                    f.hemisphereLights.value = zt.hemi,
                    f.directionalShadowMap.value = zt.directionalShadowMap,
                    f.directionalShadowMatrix.value = zt.directionalShadowMatrix,
                    f.spotShadowMap.value = zt.spotShadowMap,
                    f.spotShadowMatrix.value = zt.spotShadowMatrix,
                    f.pointShadowMap.value = zt.pointShadowMap,
                    f.pointShadowMatrix.value = zt.pointShadowMatrix);
                    var m = n.program.getUniforms()
                      , g = W.seqWithValue(m.seq, f);
                    n.uniformsList = g,
                    n.dynamicUniforms = W.splitDynamic(g, f)
                }
                function E(t) {
                    t.side === wn ? ee.disable(jt.CULL_FACE) : ee.enable(jt.CULL_FACE),
                    ee.setFlipSided(t.side === bn),
                    t.transparent === !0 ? ee.setBlending(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : ee.setBlending(An),
                    ee.setDepthFunc(t.depthFunc),
                    ee.setDepthTest(t.depthTest),
                    ee.setDepthWrite(t.depthWrite),
                    ee.setColorWrite(t.colorWrite),
                    ee.setPolygonOffset(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                }
                function T(t, e, r, i) {
                    St = 0;
                    var n = oe.get(r);
                    if (Ot && (Nt || t !== xt)) {
                        var o = t === xt && r.id === vt;
                        Dt.setState(r.clippingPlanes, r.clipShadows, t, n, o)
                    }
                    r.needsUpdate === !1 && (void 0 === n.program ? r.needsUpdate = !0 : r.fog && n.fog !== e ? r.needsUpdate = !0 : r.lights && n.lightsHash !== zt.hash ? r.needsUpdate = !0 : void 0 !== n.numClippingPlanes && n.numClippingPlanes !== Dt.numPlanes && (r.needsUpdate = !0)),
                    r.needsUpdate && (S(r, e, i),
                    r.needsUpdate = !1);
                    var a = !1
                      , s = !1
                      , h = !1
                      , c = n.program
                      , l = c.getUniforms()
                      , u = n.__webglShader.uniforms;
                    if (c.id !== ft && (jt.useProgram(c.program),
                    ft = c.id,
                    a = !0,
                    s = !0,
                    h = !0),
                    r.id !== vt && (vt = r.id,
                    s = !0),
                    a || t !== xt) {
                        if (l.set(jt, t, "projectionMatrix"),
                        te.logarithmicDepthBuffer && l.setValue(jt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                        t !== xt && (xt = t,
                        s = !0,
                        h = !0),
                        r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshStandardMaterial || r.envMap) {
                            var p = l.map.cameraPosition;
                            void 0 !== p && p.setValue(jt, kt.setFromMatrixPosition(t.matrixWorld))
                        }
                        (r.isMeshPhongMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.skinning) && l.setValue(jt, "viewMatrix", t.matrixWorldInverse),
                        l.set(jt, dt, "toneMappingExposure"),
                        l.set(jt, dt, "toneMappingWhitePoint")
                    }
                    if (r.skinning) {
                        l.setOptional(jt, i, "bindMatrix"),
                        l.setOptional(jt, i, "bindMatrixInverse");
                        var d = i.skeleton;
                        d && (te.floatVertexTextures && d.useVertexTexture ? (l.set(jt, d, "boneTexture"),
                        l.set(jt, d, "boneTextureWidth"),
                        l.set(jt, d, "boneTextureHeight")) : l.setOptional(jt, d, "boneMatrices"))
                    }
                    s && (r.lights && N(u, h),
                    e && r.fog && P(u, e),
                    (r.isMeshBasicMaterial || r.isMeshLambertMaterial || r.isMeshPhongMaterial || r.isMeshStandardMaterial || r.isMeshDepthMaterial) && A(u, r),
                    r.isLineBasicMaterial ? L(u, r) : r.isLineDashedMaterial ? (L(u, r),
                    C(u, r)) : r.isPointsMaterial ? R(u, r) : r.isMeshLambertMaterial ? U(u, r) : r.isMeshPhongMaterial ? I(u, r) : r.isMeshPhysicalMaterial ? O(u, r) : r.isMeshStandardMaterial ? D(u, r) : r.isMeshDepthMaterial ? r.displacementMap && (u.displacementMap.value = r.displacementMap,
                    u.displacementScale.value = r.displacementScale,
                    u.displacementBias.value = r.displacementBias) : r.isMeshNormalMaterial && (u.opacity.value = r.opacity),
                    W.upload(jt, n.uniformsList, u, dt)),
                    l.set(jt, i, "modelViewMatrix"),
                    l.set(jt, i, "normalMatrix"),
                    l.setValue(jt, "modelMatrix", i.matrixWorld);
                    var f = n.dynamicUniforms;
                    return null !== f && (W.evalDynamic(f, u, i, t),
                    W.upload(jt, f, u, dt)),
                    c
                }
                function A(t, e) {
                    t.opacity.value = e.opacity,
                    t.diffuse.value = e.color,
                    e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
                    t.map.value = e.map,
                    t.specularMap.value = e.specularMap,
                    t.alphaMap.value = e.alphaMap,
                    e.aoMap && (t.aoMap.value = e.aoMap,
                    t.aoMapIntensity.value = e.aoMapIntensity);
                    var r;
                    if (e.map ? r = e.map : e.specularMap ? r = e.specularMap : e.displacementMap ? r = e.displacementMap : e.normalMap ? r = e.normalMap : e.bumpMap ? r = e.bumpMap : e.roughnessMap ? r = e.roughnessMap : e.metalnessMap ? r = e.metalnessMap : e.alphaMap ? r = e.alphaMap : e.emissiveMap && (r = e.emissiveMap),
                    void 0 !== r) {
                        r.isWebGLRenderTarget && (r = r.texture);
                        var i = r.offset
                          , n = r.repeat;
                        t.offsetRepeat.value.set(i.x, i.y, n.x, n.y)
                    }
                    t.envMap.value = e.envMap,
                    t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1,
                    t.reflectivity.value = e.reflectivity,
                    t.refractionRatio.value = e.refractionRatio
                }
                function L(t, e) {
                    t.diffuse.value = e.color,
                    t.opacity.value = e.opacity
                }
                function C(t, e) {
                    t.dashSize.value = e.dashSize,
                    t.totalSize.value = e.dashSize + e.gapSize,
                    t.scale.value = e.scale
                }
                function R(t, e) {
                    if (t.diffuse.value = e.color,
                    t.opacity.value = e.opacity,
                    t.size.value = e.size * Ct,
                    t.scale.value = .5 * V.clientHeight,
                    t.map.value = e.map,
                    null !== e.map) {
                        var r = e.map.offset
                          , i = e.map.repeat;
                        t.offsetRepeat.value.set(r.x, r.y, i.x, i.y)
                    }
                }
                function P(t, e) {
                    t.fogColor.value = e.color,
                    e.isFog ? (t.fogNear.value = e.near,
                    t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                }
                function U(t, e) {
                    e.lightMap && (t.lightMap.value = e.lightMap,
                    t.lightMapIntensity.value = e.lightMapIntensity),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                }
                function I(t, e) {
                    t.specular.value = e.specular,
                    t.shininess.value = Math.max(e.shininess, 1e-4),
                    e.lightMap && (t.lightMap.value = e.lightMap,
                    t.lightMapIntensity.value = e.lightMapIntensity),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale),
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale)),
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }
                function D(t, e) {
                    t.roughness.value = e.roughness,
                    t.metalness.value = e.metalness,
                    e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
                    e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
                    e.lightMap && (t.lightMap.value = e.lightMap,
                    t.lightMapIntensity.value = e.lightMapIntensity),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale),
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale)),
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias),
                    e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                }
                function O(t, e) {
                    t.clearCoat.value = e.clearCoat,
                    t.clearCoatRoughness.value = e.clearCoatRoughness,
                    D(t, e)
                }
                function N(t, e) {
                    t.ambientLightColor.needsUpdate = e,
                    t.directionalLights.needsUpdate = e,
                    t.pointLights.needsUpdate = e,
                    t.spotLights.needsUpdate = e,
                    t.hemisphereLights.needsUpdate = e
                }
                function B(t) {
                    for (var e = 0, r = 0, i = t.length; r < i; r++) {
                        var n = t[r];
                        n.castShadow && (zt.shadows[e++] = n)
                    }
                    zt.shadows.length = e
                }
                function F(t, e) {
                    var r, i, n, a, s, h, c, l = 0, u = 0, p = 0, d = e.matrixWorldInverse, f = 0, m = 0, g = 0, v = 0;
                    for (r = 0,
                    i = t.length; r < i; r++)
                        if (n = t[r],
                        a = n.color,
                        s = n.intensity,
                        h = n.distance,
                        c = n.shadow && n.shadow.map ? n.shadow.map.texture : null,
                        n.isAmbientLight)
                            l += a.r * s,
                            u += a.g * s,
                            p += a.b * s;
                        else if (n.isDirectionalLight) {
                            var y = ue.get(n);
                            y.color.copy(n.color).multiplyScalar(n.intensity),
                            y.direction.setFromMatrixPosition(n.matrixWorld),
                            kt.setFromMatrixPosition(n.target.matrixWorld),
                            y.direction.sub(kt),
                            y.direction.transformDirection(d),
                            y.shadow = n.castShadow,
                            n.castShadow && (y.shadowBias = n.shadow.bias,
                            y.shadowRadius = n.shadow.radius,
                            y.shadowMapSize = n.shadow.mapSize),
                            zt.directionalShadowMap[f] = c,
                            zt.directionalShadowMatrix[f] = n.shadow.matrix,
                            zt.directional[f++] = y
                        } else if (n.isSpotLight) {
                            var y = ue.get(n);
                            y.position.setFromMatrixPosition(n.matrixWorld),
                            y.position.applyMatrix4(d),
                            y.color.copy(a).multiplyScalar(s),
                            y.distance = h,
                            y.direction.setFromMatrixPosition(n.matrixWorld),
                            kt.setFromMatrixPosition(n.target.matrixWorld),
                            y.direction.sub(kt),
                            y.direction.transformDirection(d),
                            y.coneCos = Math.cos(n.angle),
                            y.penumbraCos = Math.cos(n.angle * (1 - n.penumbra)),
                            y.decay = 0 === n.distance ? 0 : n.decay,
                            y.shadow = n.castShadow,
                            n.castShadow && (y.shadowBias = n.shadow.bias,
                            y.shadowRadius = n.shadow.radius,
                            y.shadowMapSize = n.shadow.mapSize),
                            zt.spotShadowMap[g] = c,
                            zt.spotShadowMatrix[g] = n.shadow.matrix,
                            zt.spot[g++] = y
                        } else if (n.isPointLight) {
                            var y = ue.get(n);
                            y.position.setFromMatrixPosition(n.matrixWorld),
                            y.position.applyMatrix4(d),
                            y.color.copy(n.color).multiplyScalar(n.intensity),
                            y.distance = n.distance,
                            y.decay = 0 === n.distance ? 0 : n.decay,
                            y.shadow = n.castShadow,
                            n.castShadow && (y.shadowBias = n.shadow.bias,
                            y.shadowRadius = n.shadow.radius,
                            y.shadowMapSize = n.shadow.mapSize),
                            zt.pointShadowMap[m] = c,
                            void 0 === zt.pointShadowMatrix[m] && (zt.pointShadowMatrix[m] = new o),
                            kt.setFromMatrixPosition(n.matrixWorld).negate(),
                            zt.pointShadowMatrix[m].identity().setPosition(kt),
                            zt.point[m++] = y
                        } else if (n.isHemisphereLight) {
                            var y = ue.get(n);
                            y.direction.setFromMatrixPosition(n.matrixWorld),
                            y.direction.transformDirection(d),
                            y.direction.normalize(),
                            y.skyColor.copy(n.color).multiplyScalar(s),
                            y.groundColor.copy(n.groundColor).multiplyScalar(s),
                            zt.hemi[v++] = y
                        }
                    zt.ambient[0] = l,
                    zt.ambient[1] = u,
                    zt.ambient[2] = p,
                    zt.directional.length = f,
                    zt.spot.length = g,
                    zt.point.length = m,
                    zt.hemi.length = v,
                    zt.hash = f + "," + m + "," + g + "," + v + "," + zt.shadows.length
                }
                function k() {
                    var t = St;
                    return t >= te.maxTextures && console.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + te.maxTextures),
                    St += 1,
                    t
                }
                function z(t) {
                    var e;
                    if (t === bo)
                        return jt.REPEAT;
                    if (t === wo)
                        return jt.CLAMP_TO_EDGE;
                    if (t === _o)
                        return jt.MIRRORED_REPEAT;
                    if (t === Mo)
                        return jt.NEAREST;
                    if (t === So)
                        return jt.NEAREST_MIPMAP_NEAREST;
                    if (t === Eo)
                        return jt.NEAREST_MIPMAP_LINEAR;
                    if (t === To)
                        return jt.LINEAR;
                    if (t === Ao)
                        return jt.LINEAR_MIPMAP_NEAREST;
                    if (t === Lo)
                        return jt.LINEAR_MIPMAP_LINEAR;
                    if (t === Co)
                        return jt.UNSIGNED_BYTE;
                    if (t === Bo)
                        return jt.UNSIGNED_SHORT_4_4_4_4;
                    if (t === Fo)
                        return jt.UNSIGNED_SHORT_5_5_5_1;
                    if (t === ko)
                        return jt.UNSIGNED_SHORT_5_6_5;
                    if (t === Ro)
                        return jt.BYTE;
                    if (t === Po)
                        return jt.SHORT;
                    if (t === Uo)
                        return jt.UNSIGNED_SHORT;
                    if (t === Io)
                        return jt.INT;
                    if (t === Do)
                        return jt.UNSIGNED_INT;
                    if (t === Oo)
                        return jt.FLOAT;
                    if (e = $t.get("OES_texture_half_float"),
                    null !== e && t === No)
                        return e.HALF_FLOAT_OES;
                    if (t === Vo)
                        return jt.ALPHA;
                    if (t === Go)
                        return jt.RGB;
                    if (t === jo)
                        return jt.RGBA;
                    if (t === Ho)
                        return jt.LUMINANCE;
                    if (t === Wo)
                        return jt.LUMINANCE_ALPHA;
                    if (t === Yo)
                        return jt.DEPTH_COMPONENT;
                    if (t === qo)
                        return jt.DEPTH_STENCIL;
                    if (t === In)
                        return jt.FUNC_ADD;
                    if (t === Dn)
                        return jt.FUNC_SUBTRACT;
                    if (t === On)
                        return jt.FUNC_REVERSE_SUBTRACT;
                    if (t === Fn)
                        return jt.ZERO;
                    if (t === kn)
                        return jt.ONE;
                    if (t === zn)
                        return jt.SRC_COLOR;
                    if (t === Vn)
                        return jt.ONE_MINUS_SRC_COLOR;
                    if (t === Gn)
                        return jt.SRC_ALPHA;
                    if (t === jn)
                        return jt.ONE_MINUS_SRC_ALPHA;
                    if (t === Hn)
                        return jt.DST_ALPHA;
                    if (t === Wn)
                        return jt.ONE_MINUS_DST_ALPHA;
                    if (t === Xn)
                        return jt.DST_COLOR;
                    if (t === Yn)
                        return jt.ONE_MINUS_DST_COLOR;
                    if (t === qn)
                        return jt.SRC_ALPHA_SATURATE;
                    if (e = $t.get("WEBGL_compressed_texture_s3tc"),
                    null !== e) {
                        if (t === Zo)
                            return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (t === Qo)
                            return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (t === Jo)
                            return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (t === Ko)
                            return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (e = $t.get("WEBGL_compressed_texture_pvrtc"),
                    null !== e) {
                        if (t === $o)
                            return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (t === ta)
                            return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (t === ea)
                            return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (t === ra)
                            return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (e = $t.get("WEBGL_compressed_texture_etc1"),
                    null !== e && t === ia)
                        return e.COMPRESSED_RGB_ETC1_WEBGL;
                    if (e = $t.get("EXT_blend_minmax"),
                    null !== e) {
                        if (t === Nn)
                            return e.MIN_EXT;
                        if (t === Bn)
                            return e.MAX_EXT
                    }
                    return e = $t.get("WEBGL_depth_texture"),
                    null !== e && t === zo ? e.UNSIGNED_INT_24_8_WEBGL : 0
                }
                console.log("THREE.WebGLRenderer", hn),
                e = e || {};
                var V = void 0 !== e.canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                  , G = void 0 !== e.context ? e.context : null
                  , j = void 0 !== e.alpha && e.alpha
                  , H = void 0 === e.depth || e.depth
                  , Z = void 0 === e.stencil || e.stencil
                  , Q = void 0 !== e.antialias && e.antialias
                  , J = void 0 === e.premultipliedAlpha || e.premultipliedAlpha
                  , tt = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer
                  , et = []
                  , it = []
                  , nt = -1
                  , st = []
                  , ht = -1
                  , lt = new Float32Array(8)
                  , ut = []
                  , pt = [];
                this.domElement = V,
                this.context = null,
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this.gammaFactor = 2,
                this.gammaInput = !1,
                this.gammaOutput = !1,
                this.physicallyCorrectLights = !1,
                this.toneMapping = so,
                this.toneMappingExposure = 1,
                this.toneMappingWhitePoint = 1,
                this.maxMorphTargets = 8,
                this.maxMorphNormals = 4;
                var dt = this
                  , ft = null
                  , mt = null
                  , gt = null
                  , vt = -1
                  , yt = ""
                  , xt = null
                  , bt = new Y
                  , wt = null
                  , Mt = new Y
                  , St = 0
                  , Et = new $(0)
                  , Tt = 0
                  , At = V.width
                  , Lt = V.height
                  , Ct = 1
                  , Rt = new Y(0,0,At,Lt)
                  , Pt = !1
                  , Ut = new Y(0,0,At,Lt)
                  , It = new ot
                  , Dt = new Zt
                  , Ot = !1
                  , Nt = !1
                  , Bt = new rt
                  , Ft = new o
                  , kt = new s
                  , zt = {
                    hash: "",
                    ambient: [0, 0, 0],
                    directional: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    point: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    shadows: []
                }
                  , Vt = {
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0
                };
                this.info = {
                    render: Vt,
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    programs: null
                };
                var jt;
                try {
                    var Jt = {
                        alpha: j,
                        depth: H,
                        stencil: Z,
                        antialias: Q,
                        premultipliedAlpha: J,
                        preserveDrawingBuffer: tt
                    };
                    if (jt = G || V.getContext("webgl", Jt) || V.getContext("experimental-webgl", Jt),
                    null === jt)
                        throw null !== V.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
                    void 0 === jt.getShaderPrecisionFormat && (jt.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    }
                    ),
                    V.addEventListener("webglcontextlost", c, !1)
                } catch (t) {
                    console.error("THREE.WebGLRenderer: " + t)
                }
                var $t = new Yt(jt);
                $t.get("WEBGL_depth_texture"),
                $t.get("OES_texture_float"),
                $t.get("OES_texture_float_linear"),
                $t.get("OES_texture_half_float"),
                $t.get("OES_texture_half_float_linear"),
                $t.get("OES_standard_derivatives"),
                $t.get("ANGLE_instanced_arrays"),
                $t.get("OES_element_index_uint") && (Gt.MaxIndex = 4294967296);
                var te = new Xt(jt,$t,e)
                  , ee = new q(jt,$t,z)
                  , oe = new ct
                  , he = new X(jt,$t,ee,oe,te,z,this.info)
                  , ce = new Ht(jt,oe,this.info)
                  , le = new _t(this,te)
                  , ue = new Wt;
                this.info.programs = le.programs;
                var pe = new Qt(jt,$t,Vt)
                  , de = new qt(jt,$t,Vt)
                  , fe = new se((-1),1,1,(-1),0,1)
                  , me = new ae
                  , ge = new ie(new ne(2,2),new re({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))
                  , ve = Uh.cube
                  , ye = new ie(new Kt(5,5,5),new K({
                    uniforms: ve.uniforms,
                    vertexShader: ve.vertexShader,
                    fragmentShader: ve.fragmentShader,
                    side: bn,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }));
                n(),
                this.context = jt,
                this.capabilities = te,
                this.extensions = $t,
                this.properties = oe,
                this.state = ee;
                var xe = new at(this,zt,ce,te);
                this.shadowMap = xe;
                var be = new h(this,ut)
                  , we = new l(this,pt);
                this.getContext = function() {
                    return jt
                }
                ,
                this.getContextAttributes = function() {
                    return jt.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    $t.get("WEBGL_lose_context").loseContext()
                }
                ,
                this.getMaxAnisotropy = function() {
                    return te.getMaxAnisotropy()
                }
                ,
                this.getPrecision = function() {
                    return te.precision
                }
                ,
                this.getPixelRatio = function() {
                    return Ct
                }
                ,
                this.setPixelRatio = function(t) {
                    void 0 !== t && (Ct = t,
                    this.setSize(Ut.z, Ut.w, !1))
                }
                ,
                this.getSize = function() {
                    return {
                        width: At,
                        height: Lt
                    }
                }
                ,
                this.setSize = function(t, e, r) {
                    At = t,
                    Lt = e,
                    V.width = t * Ct,
                    V.height = e * Ct,
                    r !== !1 && (V.style.width = t + "px",
                    V.style.height = e + "px"),
                    this.setViewport(0, 0, t, e)
                }
                ,
                this.setViewport = function(t, e, r, i) {
                    ee.viewport(Ut.set(t, e, r, i))
                }
                ,
                this.setScissor = function(t, e, r, i) {
                    ee.scissor(Rt.set(t, e, r, i))
                }
                ,
                this.setScissorTest = function(t) {
                    ee.setScissorTest(Pt = t)
                }
                ,
                this.getClearColor = function() {
                    return Et
                }
                ,
                this.setClearColor = function(t, e) {
                    Et.set(t),
                    Tt = void 0 !== e ? e : 1,
                    i(Et.r, Et.g, Et.b, Tt)
                }
                ,
                this.getClearAlpha = function() {
                    return Tt
                }
                ,
                this.setClearAlpha = function(t) {
                    Tt = t,
                    i(Et.r, Et.g, Et.b, Tt)
                }
                ,
                this.clear = function(t, e, r) {
                    var i = 0;
                    (void 0 === t || t) && (i |= jt.COLOR_BUFFER_BIT),
                    (void 0 === e || e) && (i |= jt.DEPTH_BUFFER_BIT),
                    (void 0 === r || r) && (i |= jt.STENCIL_BUFFER_BIT),
                    jt.clear(i)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.clearTarget = function(t, e, r, i) {
                    this.setRenderTarget(t),
                    this.clear(e, r, i)
                }
                ,
                this.resetGLState = a,
                this.dispose = function() {
                    st = [],
                    ht = -1,
                    it = [],
                    nt = -1,
                    V.removeEventListener("webglcontextlost", c, !1)
                }
                ,
                this.renderBufferImmediate = function(t, e, r) {
                    ee.initAttributes();
                    var i = oe.get(t);
                    t.hasPositions && !i.position && (i.position = jt.createBuffer()),
                    t.hasNormals && !i.normal && (i.normal = jt.createBuffer()),
                    t.hasUvs && !i.uv && (i.uv = jt.createBuffer()),
                    t.hasColors && !i.color && (i.color = jt.createBuffer());
                    var n = e.getAttributes();
                    if (t.hasPositions && (jt.bindBuffer(jt.ARRAY_BUFFER, i.position),
                    jt.bufferData(jt.ARRAY_BUFFER, t.positionArray, jt.DYNAMIC_DRAW),
                    ee.enableAttribute(n.position),
                    jt.vertexAttribPointer(n.position, 3, jt.FLOAT, !1, 0, 0)),
                    t.hasNormals) {
                        if (jt.bindBuffer(jt.ARRAY_BUFFER, i.normal),
                        !r.isMeshPhongMaterial && !r.isMeshStandardMaterial && r.shading === _n)
                            for (var o = 0, a = 3 * t.count; o < a; o += 9) {
                                var s = t.normalArray
                                  , h = (s[o + 0] + s[o + 3] + s[o + 6]) / 3
                                  , c = (s[o + 1] + s[o + 4] + s[o + 7]) / 3
                                  , l = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
                                s[o + 0] = h,
                                s[o + 1] = c,
                                s[o + 2] = l,
                                s[o + 3] = h,
                                s[o + 4] = c,
                                s[o + 5] = l,
                                s[o + 6] = h,
                                s[o + 7] = c,
                                s[o + 8] = l
                            }
                        jt.bufferData(jt.ARRAY_BUFFER, t.normalArray, jt.DYNAMIC_DRAW),
                        ee.enableAttribute(n.normal),
                        jt.vertexAttribPointer(n.normal, 3, jt.FLOAT, !1, 0, 0)
                    }
                    t.hasUvs && r.map && (jt.bindBuffer(jt.ARRAY_BUFFER, i.uv),
                    jt.bufferData(jt.ARRAY_BUFFER, t.uvArray, jt.DYNAMIC_DRAW),
                    ee.enableAttribute(n.uv),
                    jt.vertexAttribPointer(n.uv, 2, jt.FLOAT, !1, 0, 0)),
                    t.hasColors && r.vertexColors !== Sn && (jt.bindBuffer(jt.ARRAY_BUFFER, i.color),
                    jt.bufferData(jt.ARRAY_BUFFER, t.colorArray, jt.DYNAMIC_DRAW),
                    ee.enableAttribute(n.color),
                    jt.vertexAttribPointer(n.color, 3, jt.FLOAT, !1, 0, 0)),
                    ee.disableUnusedAttributes(),
                    jt.drawArrays(jt.TRIANGLES, 0, t.count),
                    t.count = 0
                }
                ,
                this.renderBufferDirect = function(t, e, i, n, o, a) {
                    E(n);
                    var s = T(t, e, n, o)
                      , h = !1
                      , c = i.id + "_" + s.id + "_" + n.wireframe;
                    c !== yt && (yt = c,
                    h = !0);
                    var l = o.morphTargetInfluences;
                    if (void 0 !== l) {
                        for (var u = [], p = 0, d = l.length; p < d; p++) {
                            var g = l[p];
                            u.push([g, p])
                        }
                        u.sort(m),
                        u.length > 8 && (u.length = 8);
                        for (var v = i.morphAttributes, p = 0, d = u.length; p < d; p++) {
                            var g = u[p];
                            if (lt[p] = g[0],
                            0 !== g[0]) {
                                var y = g[1];
                                n.morphTargets === !0 && v.position && i.addAttribute("morphTarget" + p, v.position[y]),
                                n.morphNormals === !0 && v.normal && i.addAttribute("morphNormal" + p, v.normal[y])
                            } else
                                n.morphTargets === !0 && i.removeAttribute("morphTarget" + p),
                                n.morphNormals === !0 && i.removeAttribute("morphNormal" + p)
                        }
                        s.getUniforms().setValue(jt, "morphTargetInfluences", lt),
                        h = !0
                    }
                    var y = i.index
                      , x = i.attributes.position;
                    n.wireframe === !0 && (y = ce.getWireframeAttribute(i));
                    var b;
                    null !== y ? (b = de,
                    b.setIndex(y)) : b = pe,
                    h && (f(n, s, i),
                    null !== y && jt.bindBuffer(jt.ELEMENT_ARRAY_BUFFER, ce.getAttributeBuffer(y)));
                    var w = 0
                      , _ = 1 / 0;
                    null !== y ? _ = y.count : void 0 !== x && (_ = x.count);
                    var M = i.drawRange.start
                      , S = i.drawRange.count
                      , A = null !== a ? a.start : 0
                      , L = null !== a ? a.count : 1 / 0
                      , C = Math.max(w, M, A)
                      , R = Math.min(w + _, M + S, A + L) - 1
                      , P = Math.max(0, R - C + 1);
                    if (o.isMesh)
                        if (n.wireframe === !0)
                            ee.setLineWidth(n.wireframeLinewidth * r()),
                            b.setMode(jt.LINES);
                        else
                            switch (o.drawMode) {
                            case da:
                                b.setMode(jt.TRIANGLES);
                                break;
                            case fa:
                                b.setMode(jt.TRIANGLE_STRIP);
                                break;
                            case ma:
                                b.setMode(jt.TRIANGLE_FAN)
                            }
                    else if (o.isLine) {
                        var U = n.linewidth;
                        void 0 === U && (U = 1),
                        ee.setLineWidth(U * r()),
                        o.isLineSegments ? b.setMode(jt.LINES) : b.setMode(jt.LINE_STRIP)
                    } else
                        o.isPoints && b.setMode(jt.POINTS);
                    i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && b.renderInstances(i, C, P) : b.render(C, P)
                }
                ,
                this.render = function(t, e, r, n) {
                    if ((e && e.isCamera) === !1)
                        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    var o = t.fog;
                    yt = "",
                    vt = -1,
                    xt = null,
                    t.autoUpdate === !0 && t.updateMatrixWorld(),
                    null === e.parent && e.updateMatrixWorld(),
                    e.matrixWorldInverse.getInverse(e.matrixWorld),
                    Ft.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                    It.setFromMatrix(Ft),
                    et.length = 0,
                    nt = -1,
                    ht = -1,
                    ut.length = 0,
                    pt.length = 0,
                    Nt = this.localClippingEnabled,
                    Ot = Dt.init(this.clippingPlanes, Nt, e),
                    _(t, e),
                    it.length = nt + 1,
                    st.length = ht + 1,
                    dt.sortObjects === !0 && (it.sort(g),
                    st.sort(v)),
                    Ot && Dt.beginShadows(),
                    B(et),
                    xe.render(t, e),
                    F(et, e),
                    Ot && Dt.endShadows(),
                    Vt.calls = 0,
                    Vt.vertices = 0,
                    Vt.faces = 0,
                    Vt.points = 0,
                    void 0 === r && (r = null),
                    this.setRenderTarget(r);
                    var a = t.background;
                    if (null === a ? i(Et.r, Et.g, Et.b, Tt) : a && a.isColor && (i(a.r, a.g, a.b, 1),
                    n = !0),
                    (this.autoClear || n) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil),
                    a && a.isCubeTexture ? (me.projectionMatrix.copy(e.projectionMatrix),
                    me.matrixWorld.extractRotation(e.matrixWorld),
                    me.matrixWorldInverse.getInverse(me.matrixWorld),
                    ye.material.uniforms.tCube.value = a,
                    ye.modelViewMatrix.multiplyMatrices(me.matrixWorldInverse, ye.matrixWorld),
                    ce.update(ye),
                    dt.renderBufferDirect(me, null, ye.geometry, ye.material, ye, null)) : a && a.isTexture && (ge.material.map = a,
                    ce.update(ge),
                    dt.renderBufferDirect(fe, null, ge.geometry, ge.material, ge, null)),
                    t.overrideMaterial) {
                        var s = t.overrideMaterial;
                        M(it, e, o, s),
                        M(st, e, o, s)
                    } else
                        ee.setBlending(An),
                        M(it, e, o),
                        M(st, e, o);
                    be.render(t, e),
                    we.render(t, e, Mt),
                    r && he.updateRenderTargetMipmap(r),
                    ee.setDepthTest(!0),
                    ee.setDepthWrite(!0),
                    ee.setColorWrite(!0)
                }
                ,
                this.setFaceCulling = function(t, e) {
                    ee.setCullFace(t),
                    ee.setFlipSided(e === fn)
                }
                ,
                this.allocTextureUnit = k,
                this.setTexture2D = function() {
                    var t = !1;
                    return function(e, r) {
                        e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),
                        t = !0),
                        e = e.texture),
                        he.setTexture2D(e, r)
                    }
                }(),
                this.setTexture = function() {
                    var t = !1;
                    return function(e, r) {
                        t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
                        t = !0),
                        he.setTexture2D(e, r)
                    }
                }(),
                this.setTextureCube = function() {
                    var t = !1;
                    return function(e, r) {
                        e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                        t = !0),
                        e = e.texture),
                        e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? he.setTextureCube(e, r) : he.setTextureCubeDynamic(e, r)
                    }
                }(),
                this.getCurrentRenderTarget = function() {
                    return mt
                }
                ,
                this.setRenderTarget = function(t) {
                    mt = t,
                    t && void 0 === oe.get(t).__webglFramebuffer && he.setupRenderTarget(t);
                    var e, r = t && t.isWebGLRenderTargetCube;
                    if (t) {
                        var i = oe.get(t);
                        e = r ? i.__webglFramebuffer[t.activeCubeFace] : i.__webglFramebuffer,
                        bt.copy(t.scissor),
                        wt = t.scissorTest,
                        Mt.copy(t.viewport)
                    } else
                        e = null,
                        bt.copy(Rt).multiplyScalar(Ct),
                        wt = Pt,
                        Mt.copy(Ut).multiplyScalar(Ct);
                    if (gt !== e && (jt.bindFramebuffer(jt.FRAMEBUFFER, e),
                    gt = e),
                    ee.scissor(bt),
                    ee.setScissorTest(wt),
                    ee.viewport(Mt),
                    r) {
                        var n = oe.get(t.texture);
                        jt.framebufferTexture2D(jt.FRAMEBUFFER, jt.COLOR_ATTACHMENT0, jt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, n.__webglTexture, t.activeMipMapLevel)
                    }
                }
                ,
                this.readRenderTargetPixels = function(t, e, r, i, n, o) {
                    if ((t && t.isWebGLRenderTarget) === !1)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    var a = oe.get(t).__webglFramebuffer;
                    if (a) {
                        var s = !1;
                        a !== gt && (jt.bindFramebuffer(jt.FRAMEBUFFER, a),
                        s = !0);
                        try {
                            var h = t.texture
                              , c = h.format
                              , l = h.type;
                            if (c !== jo && z(c) !== jt.getParameter(jt.IMPLEMENTATION_COLOR_READ_FORMAT))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!(l === Co || z(l) === jt.getParameter(jt.IMPLEMENTATION_COLOR_READ_TYPE) || l === Oo && ($t.get("OES_texture_float") || $t.get("WEBGL_color_buffer_float")) || l === No && $t.get("EXT_color_buffer_half_float")))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            jt.checkFramebufferStatus(jt.FRAMEBUFFER) === jt.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && r >= 0 && r <= t.height - n && jt.readPixels(e, r, i, n, z(c), z(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            s && jt.bindFramebuffer(jt.FRAMEBUFFER, gt)
                        }
                    }
                }
            }
            function ce(t, e) {
                this.name = "",
                this.color = new $(t),
                this.density = void 0 !== e ? e : 25e-5
            }
            function le(t, e, r) {
                this.name = "",
                this.color = new $(t),
                this.near = void 0 !== e ? e : 1,
                this.far = void 0 !== r ? r : 1e3
            }
            function ue() {
                Bt.call(this),
                this.type = "Scene",
                this.background = null,
                this.fog = null,
                this.overrideMaterial = null,
                this.autoUpdate = !0
            }
            function pe(t, e, r, i, n) {
                Bt.call(this),
                this.lensFlares = [],
                this.positionScreen = new s,
                this.customUpdateCallback = void 0,
                void 0 !== t && this.add(t, e, r, i, n)
            }
            function de(t) {
                Q.call(this),
                this.type = "SpriteMaterial",
                this.color = new $(16777215),
                this.map = null,
                this.rotation = 0,
                this.fog = !1,
                this.lights = !1,
                this.setValues(t)
            }
            function fe(t) {
                Bt.call(this),
                this.type = "Sprite",
                this.material = void 0 !== t ? t : new de
            }
            function me() {
                Bt.call(this),
                this.type = "LOD",
                Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }
            function ge(t, e, r, n, o, a, s, h, c, l, u, p) {
                i.call(this, null, a, s, h, c, l, n, o, u, p),
                this.image = {
                    data: t,
                    width: e,
                    height: r
                },
                this.magFilter = void 0 !== c ? c : Mo,
                this.minFilter = void 0 !== l ? l : Mo,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
            function ve(e, r, i) {
                if (this.useVertexTexture = void 0 === i || i,
                this.identityMatrix = new o,
                e = e || [],
                this.bones = e.slice(0),
                this.useVertexTexture) {
                    var n = Math.sqrt(4 * this.bones.length);
                    n = t.Math.nextPowerOfTwo(Math.ceil(n)),
                    n = Math.max(n, 4),
                    this.boneTextureWidth = n,
                    this.boneTextureHeight = n,
                    this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4),
                    this.boneTexture = new ge(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,jo,Oo)
                } else
                    this.boneMatrices = new Float32Array(16 * this.bones.length);
                if (void 0 === r)
                    this.calculateInverses();
                else if (this.bones.length === r.length)
                    this.boneInverses = r.slice(0);
                else {
                    console.warn("THREE.Skeleton bonInverses is the wrong length."),
                    this.boneInverses = [];
                    for (var a = 0, s = this.bones.length; a < s; a++)
                        this.boneInverses.push(new o)
                }
            }
            function ye(t) {
                Bt.call(this),
                this.type = "Bone",
                this.skin = t
            }
            function xe(t, e, r) {
                ie.call(this, t, e),
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new o,
                this.bindMatrixInverse = new o;
                var i = [];
                if (this.geometry && void 0 !== this.geometry.bones) {
                    for (var n, a, s = 0, h = this.geometry.bones.length; s < h; ++s)
                        a = this.geometry.bones[s],
                        n = new ye(this),
                        i.push(n),
                        n.name = a.name,
                        n.position.fromArray(a.pos),
                        n.quaternion.fromArray(a.rotq),
                        void 0 !== a.scl && n.scale.fromArray(a.scl);
                    for (var s = 0, h = this.geometry.bones.length; s < h; ++s)
                        a = this.geometry.bones[s],
                        a.parent !== -1 && null !== a.parent && void 0 !== i[a.parent] ? i[a.parent].add(i[s]) : this.add(i[s])
                }
                this.normalizeSkinWeights(),
                this.updateMatrixWorld(!0),
                this.bind(new ve(i,(void 0),r), this.matrixWorld)
            }
            function be(t) {
                Q.call(this),
                this.type = "LineBasicMaterial",
                this.color = new $(16777215),
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.lights = !1,
                this.setValues(t)
            }
            function we(t, e, r) {
                return 1 === r ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
                new _e(t,e)) : (Bt.call(this),
                this.type = "Line",
                this.geometry = void 0 !== t ? t : new Gt,
                void (this.material = void 0 !== e ? e : new be({
                    color: 16777215 * Math.random()
                })))
            }
            function _e(t, e) {
                we.call(this, t, e),
                this.type = "LineSegments"
            }
            function Me(t) {
                Q.call(this),
                this.type = "PointsMaterial",
                this.color = new $(16777215),
                this.map = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.lights = !1,
                this.setValues(t)
            }
            function Se(t, e) {
                Bt.call(this),
                this.type = "Points",
                this.geometry = void 0 !== t ? t : new Gt,
                this.material = void 0 !== e ? e : new Me({
                    color: 16777215 * Math.random()
                })
            }
            function Ee() {
                Bt.call(this),
                this.type = "Group"
            }
            function Te(t, e, r, n, o, a, s, h, c) {
                function l() {
                    requestAnimationFrame(l),
                    t.readyState >= t.HAVE_CURRENT_DATA && (u.needsUpdate = !0)
                }
                i.call(this, t, e, r, n, o, a, s, h, c),
                this.generateMipmaps = !1;
                var u = this;
                l()
            }
            function Ae(t, e, r, n, o, a, s, h, c, l, u, p) {
                i.call(this, null, a, s, h, c, l, n, o, u, p),
                this.image = {
                    width: e,
                    height: r
                },
                this.mipmaps = t,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
            function Le(t, e, r, n, o, a, s, h, c) {
                i.call(this, t, e, r, n, o, a, s, h, c),
                this.needsUpdate = !0
            }
            function Ce(t, e, r, n, o, a, s, h, c, l) {
                if (l = void 0 !== l ? l : Yo,
                l !== Yo && l !== qo)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                i.call(this, null, n, o, a, s, h, l, r, c),
                this.image = {
                    width: t,
                    height: e
                },
                this.type = void 0 !== r ? r : Uo,
                this.magFilter = void 0 !== s ? s : Mo,
                this.minFilter = void 0 !== h ? h : Mo,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
            function Re() {
                K.call(this, {
                    uniforms: t.UniformsUtils.merge([Ph.lights, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Rh.shadow_vert,
                    fragmentShader: Rh.shadow_frag
                }),
                this.lights = !0,
                this.transparent = !0,
                Object.defineProperties(this, {
                    opacity: {
                        enumerable: !0,
                        get: function() {
                            return this.uniforms.opacity.value
                        },
                        set: function(t) {
                            this.uniforms.opacity.value = t
                        }
                    }
                })
            }
            function Pe(t) {
                K.call(this, t),
                this.type = "RawShaderMaterial"
            }
            function Ue(e) {
                this.uuid = t.Math.generateUUID(),
                this.type = "MultiMaterial",
                this.materials = e instanceof Array ? e : [],
                this.visible = !0
            }
            function Ie(t) {
                Q.call(this),
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new $(16777215),
                this.roughness = .5,
                this.metalness = .5,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new $(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalScale = new r(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.setValues(t)
            }
            function De(t) {
                Ie.call(this),
                this.defines = {
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.reflectivity = .5,
                this.clearCoat = 0,
                this.clearCoatRoughness = 0,
                this.setValues(t)
            }
            function Oe(t) {
                Q.call(this),
                this.type = "MeshPhongMaterial",
                this.color = new $(16777215),
                this.specular = new $(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new $(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalScale = new r(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = io,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.setValues(t)
            }
            function Ne(t) {
                Q.call(this, t),
                this.type = "MeshNormalMaterial",
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.morphTargets = !1,
                this.setValues(t)
            }
            function Be(t) {
                Q.call(this),
                this.type = "MeshLambertMaterial",
                this.color = new $(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new $(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = io,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.setValues(t)
            }
            function Fe(t) {
                Q.call(this),
                this.type = "LineDashedMaterial",
                this.color = new $(16777215),
                this.linewidth = 1,
                this.scale = 1,
                this.dashSize = 3,
                this.gapSize = 1,
                this.lights = !1,
                this.setValues(t)
            }
            function ke(t, e, r) {
                var i = this
                  , n = !1
                  , o = 0
                  , a = 0;
                this.onStart = void 0,
                this.onLoad = t,
                this.onProgress = e,
                this.onError = r,
                this.itemStart = function(t) {
                    a++,
                    n === !1 && void 0 !== i.onStart && i.onStart(t, o, a),
                    n = !0
                }
                ,
                this.itemEnd = function(t) {
                    o++,
                    void 0 !== i.onProgress && i.onProgress(t, o, a),
                    o === a && (n = !1,
                    void 0 !== i.onLoad && i.onLoad())
                }
                ,
                this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }
            }
            function ze(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager
            }
            function Ve(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager,
                this._parser = null
            }
            function Ge(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager,
                this._parser = null
            }
            function je(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager
            }
            function He(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager
            }
            function We(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager
            }
            function Xe(t, e) {
                Bt.call(this),
                this.type = "Light",
                this.color = new $(t),
                this.intensity = void 0 !== e ? e : 1,
                this.receiveShadow = void 0
            }
            function Ye(t, e, r) {
                Xe.call(this, t, r),
                this.type = "HemisphereLight",
                this.castShadow = void 0,
                this.position.copy(Bt.DefaultUp),
                this.updateMatrix(),
                this.groundColor = new $(e)
            }
            function qe(t) {
                this.camera = t,
                this.bias = 0,
                this.radius = 1,
                this.mapSize = new r(512,512),
                this.map = null,
                this.matrix = new o
            }
            function Ze() {
                qe.call(this, new ae(50,1,.5,500))
            }
            function Qe(t, e, r, i, n, o) {
                Xe.call(this, t, e),
                this.type = "SpotLight",
                this.position.copy(Bt.DefaultUp),
                this.updateMatrix(),
                this.target = new Bt,
                Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }),
                this.distance = void 0 !== r ? r : 0,
                this.angle = void 0 !== i ? i : Math.PI / 3,
                this.penumbra = void 0 !== n ? n : 0,
                this.decay = void 0 !== o ? o : 1,
                this.shadow = new Ze
            }
            function Je(t, e, r, i) {
                Xe.call(this, t, e),
                this.type = "PointLight",
                Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }),
                this.distance = void 0 !== r ? r : 0,
                this.decay = void 0 !== i ? i : 1,
                this.shadow = new qe(new ae(90,1,.5,500))
            }
            function Ke(t) {
                qe.call(this, new se((-5),5,5,(-5),.5,500))
            }
            function $e(t, e) {
                Xe.call(this, t, e),
                this.type = "DirectionalLight",
                this.position.copy(Bt.DefaultUp),
                this.updateMatrix(),
                this.target = new Bt,
                this.shadow = new Ke
            }
            function tr(t, e) {
                Xe.call(this, t, e),
                this.type = "AmbientLight",
                this.castShadow = void 0
            }
            function er(t, e, r, i) {
                this.parameterPositions = t,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== i ? i : new e.constructor(r),
                this.sampleValues = e,
                this.valueSize = r
            }
            function rr(t, e, r, i) {
                er.call(this, t, e, r, i),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0
            }
            function ir(t, e, r, i) {
                er.call(this, t, e, r, i)
            }
            function nr(t, e, r, i) {
                er.call(this, t, e, r, i)
            }
            function or(e, r, i, n) {
                if (void 0 === e)
                    throw new Error("track name is undefined");
                if (void 0 === r || 0 === r.length)
                    throw new Error("no keyframes in track named " + e);
                this.name = e,
                this.times = t.AnimationUtils.convertArray(r, this.TimeBufferType),
                this.values = t.AnimationUtils.convertArray(i, this.ValueBufferType),
                this.setInterpolation(n || this.DefaultInterpolation),
                this.validate(),
                this.optimize()
            }
            function ar(t, e, r, i) {
                or.call(this, t, e, r, i)
            }
            function sr(t, e, r, i) {
                er.call(this, t, e, r, i)
            }
            function hr(t, e, r, i) {
                or.call(this, t, e, r, i)
            }
            function cr(t, e, r, i) {
                or.call(this, t, e, r, i)
            }
            function lr(t, e, r, i) {
                or.call(this, t, e, r, i)
            }
            function ur(t, e, r) {
                or.call(this, t, e, r)
            }
            function pr(t, e, r, i) {
                or.call(this, t, e, r, i)
            }
            function dr(t, e, r, i) {
                or.apply(this, arguments)
            }
            function fr(e, r, i) {
                this.name = e,
                this.tracks = i,
                this.duration = void 0 !== r ? r : -1,
                this.uuid = t.Math.generateUUID(),
                this.duration < 0 && this.resetDuration(),
                this.trim(),
                this.optimize()
            }
            function mr(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager,
                this.textures = {}
            }
            function gr(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager
            }
            function vr() {
                this.onLoadStart = function() {}
                ,
                this.onLoadProgress = function() {}
                ,
                this.onLoadComplete = function() {}
            }
            function yr(e) {
                "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
                e = void 0),
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager,
                this.withCredentials = !1
            }
            function xr(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager,
                this.texturePath = ""
            }
            function br() {}
            function wr(t, e) {
                this.v1 = t,
                this.v2 = e
            }
            function _r() {
                this.curves = [],
                this.autoClose = !1
            }
            function Mr(t, e, r, i, n, o, a, s) {
                this.aX = t,
                this.aY = e,
                this.xRadius = r,
                this.yRadius = i,
                this.aStartAngle = n,
                this.aEndAngle = o,
                this.aClockwise = a,
                this.aRotation = s || 0
            }
            function Sr(t) {
                this.points = void 0 === t ? [] : t
            }
            function Er(t, e, r, i) {
                this.v0 = t,
                this.v1 = e,
                this.v2 = r,
                this.v3 = i
            }
            function Tr(t, e, r) {
                this.v0 = t,
                this.v1 = e,
                this.v2 = r
            }
            function Ar(t, e, i, n, o, a) {
                function h(t, e, r) {
                    return P.vertices.push(new s(t,e,r)) - 1
                }
                kt.call(this),
                this.type = "TubeGeometry",
                this.parameters = {
                    path: t,
                    segments: e,
                    radius: i,
                    radialSegments: n,
                    closed: o,
                    taper: a
                },
                e = e || 64,
                i = i || 1,
                n = n || 8,
                o = o || !1,
                a = a || Ar.NoTaper;
                var c, l, u, p, d, f, m, g, v, y, x, b, w, _, M, S, E, T, A, L, C, R = [], P = this, U = e + 1, I = new s, D = new Ar.FrenetFrames(t,e,o), O = D.tangents, N = D.normals, B = D.binormals;
                for (this.tangents = O,
                this.normals = N,
                this.binormals = B,
                y = 0; y < U; y++)
                    for (R[y] = [],
                    p = y / (U - 1),
                    v = t.getPointAt(p),
                    c = O[y],
                    l = N[y],
                    u = B[y],
                    f = i * a(p),
                    x = 0; x < n; x++)
                        d = x / n * 2 * Math.PI,
                        m = -f * Math.cos(d),
                        g = f * Math.sin(d),
                        I.copy(v),
                        I.x += m * l.x + g * u.x,
                        I.y += m * l.y + g * u.y,
                        I.z += m * l.z + g * u.z,
                        R[y][x] = h(I.x, I.y, I.z);
                for (y = 0; y < e; y++)
                    for (x = 0; x < n; x++)
                        b = o ? (y + 1) % e : y + 1,
                        w = (x + 1) % n,
                        _ = R[y][x],
                        M = R[b][x],
                        S = R[b][w],
                        E = R[y][w],
                        T = new r(y / e,x / n),
                        A = new r((y + 1) / e,x / n),
                        L = new r((y + 1) / e,(x + 1) / n),
                        C = new r(y / e,(x + 1) / n),
                        this.faces.push(new Dt(_,M,E)),
                        this.faceVertexUvs[0].push([T, A, C]),
                        this.faces.push(new Dt(M,S,E)),
                        this.faceVertexUvs[0].push([A.clone(), L, C.clone()]);
                this.computeFaceNormals(),
                this.computeVertexNormals()
            }
            function Lr(t, e) {
                return "undefined" == typeof t ? void (t = []) : (kt.call(this),
                this.type = "ExtrudeGeometry",
                t = Array.isArray(t) ? t : [t],
                this.addShapeList(t, e),
                void this.computeFaceNormals())
            }
            function Cr(t, e) {
                kt.call(this),
                this.type = "ShapeGeometry",
                Array.isArray(t) === !1 && (t = [t]),
                this.addShapeList(t, e),
                this.computeFaceNormals()
            }
            function Rr() {
                Pr.apply(this, arguments),
                this.holes = []
            }
            function Pr(t) {
                _r.call(this),
                this.currentPoint = new r,
                t && this.fromPoints(t)
            }
            function Ur() {
                this.subPaths = [],
                this.currentPath = null
            }
            function Ir(t) {
                this.data = t
            }
            function Dr(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager
            }
            function Or() {
                return void 0 === kh && (kh = new (window.AudioContext || window.webkitAudioContext)),
                kh
            }
            function Nr(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager
            }
            function Br() {
                this.type = "StereoCamera",
                this.aspect = 1,
                this.eyeSep = .064,
                this.cameraL = new ae,
                this.cameraL.layers.enable(1),
                this.cameraL.matrixAutoUpdate = !1,
                this.cameraR = new ae,
                this.cameraR.layers.enable(2),
                this.cameraR.matrixAutoUpdate = !1
            }
            function Fr(t, e, r) {
                Bt.call(this),
                this.type = "CubeCamera";
                var i = 90
                  , n = 1
                  , o = new ae(i,n,t,e);
                o.up.set(0, -1, 0),
                o.lookAt(new s(1,0,0)),
                this.add(o);
                var a = new ae(i,n,t,e);
                a.up.set(0, -1, 0),
                a.lookAt(new s((-1),0,0)),
                this.add(a);
                var h = new ae(i,n,t,e);
                h.up.set(0, 0, 1),
                h.lookAt(new s(0,1,0)),
                this.add(h);
                var c = new ae(i,n,t,e);
                c.up.set(0, 0, -1),
                c.lookAt(new s(0,(-1),0)),
                this.add(c);
                var l = new ae(i,n,t,e);
                l.up.set(0, -1, 0),
                l.lookAt(new s(0,0,1)),
                this.add(l);
                var u = new ae(i,n,t,e);
                u.up.set(0, -1, 0),
                u.lookAt(new s(0,0,(-1))),
                this.add(u);
                var p = {
                    format: Go,
                    magFilter: To,
                    minFilter: To
                };
                this.renderTarget = new Jt(r,r,p),
                this.updateCubeMap = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    var r = this.renderTarget
                      , i = r.texture.generateMipmaps;
                    r.texture.generateMipmaps = !1,
                    r.activeCubeFace = 0,
                    t.render(e, o, r),
                    r.activeCubeFace = 1,
                    t.render(e, a, r),
                    r.activeCubeFace = 2,
                    t.render(e, h, r),
                    r.activeCubeFace = 3,
                    t.render(e, c, r),
                    r.activeCubeFace = 4,
                    t.render(e, l, r),
                    r.texture.generateMipmaps = i,
                    r.activeCubeFace = 5,
                    t.render(e, u, r),
                    t.setRenderTarget(null)
                }
            }
            function kr() {
                Bt.call(this),
                this.type = "AudioListener",
                this.context = Or(),
                this.gain = this.context.createGain(),
                this.gain.connect(this.context.destination),
                this.filter = null
            }
            function zr(t) {
                Bt.call(this),
                this.type = "Audio",
                this.context = t.context,
                this.source = this.context.createBufferSource(),
                this.source.onended = this.onEnded.bind(this),
                this.gain = this.context.createGain(),
                this.gain.connect(t.getInput()),
                this.autoplay = !1,
                this.startTime = 0,
                this.playbackRate = 1,
                this.isPlaying = !1,
                this.hasPlaybackControl = !0,
                this.sourceType = "empty",
                this.filters = []
            }
            function Vr(t) {
                zr.call(this, t),
                this.panner = this.context.createPanner(),
                this.panner.connect(this.gain)
            }
            function Gr(t, e) {
                this.analyser = t.context.createAnalyser(),
                this.analyser.fftSize = void 0 !== e ? e : 2048,
                this.data = new Uint8Array(this.analyser.frequencyBinCount),
                t.getOutput().connect(this.analyser)
            }
            function jr(t, e, r) {
                this.binding = t,
                this.valueSize = r;
                var i, n = Float64Array;
                switch (e) {
                case "quaternion":
                    i = this._slerp;
                    break;
                case "string":
                case "bool":
                    n = Array,
                    i = this._select;
                    break;
                default:
                    i = this._lerp
                }
                this.buffer = new n(4 * r),
                this._mixBufferRegion = i,
                this.cumulativeWeight = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            function Hr(t, e, r) {
                this.path = e,
                this.parsedPath = r || Hr.parseTrackName(e),
                this.node = Hr.findNode(t, this.parsedPath.nodeName) || t,
                this.rootNode = t
            }
            function Wr(e) {
                this.uuid = t.Math.generateUUID(),
                this._objects = Array.prototype.slice.call(arguments),
                this.nCachedObjects_ = 0;
                var r = {};
                this._indicesByUUID = r;
                for (var i = 0, n = arguments.length; i !== n; ++i)
                    r[arguments[i].uuid] = i;
                this._paths = [],
                this._parsedPaths = [],
                this._bindings = [],
                this._bindingsIndicesByPath = {};
                var o = this;
                this.stats = {
                    objects: {
                        get total() {
                            return o._objects.length
                        },
                        get inUse() {
                            return this.total - o.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return o._bindings.length
                    }
                }
            }
            function Xr(t, e, r) {
                this._mixer = t,
                this._clip = e,
                this._localRoot = r || null;
                for (var i = e.tracks, n = i.length, o = new Array(n), a = {
                    endingStart: la,
                    endingEnd: la
                }, s = 0; s !== n; ++s) {
                    var h = i[s].createInterpolant(null);
                    o[s] = h,
                    h.settings = a
                }
                this._interpolantSettings = a,
                this._interpolants = o,
                this._propertyBindings = new Array(n),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = oa,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            function Yr(t) {
                this._root = t,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            function qr(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
                t = arguments[1]),
                this.value = t,
                this.dynamic = !1
            }
            function Zr() {
                Gt.call(this),
                this.type = "InstancedBufferGeometry",
                this.maxInstancedCount = void 0
            }
            function Qr(e, r, i, n) {
                this.uuid = t.Math.generateUUID(),
                this.data = e,
                this.itemSize = r,
                this.offset = i,
                this.normalized = n === !0
            }
            function Jr(e, r) {
                this.uuid = t.Math.generateUUID(),
                this.array = e,
                this.stride = r,
                this.dynamic = !1,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0
            }
            function Kr(t, e, r) {
                Jr.call(this, t, e),
                this.meshPerAttribute = r || 1
            }
            function $r(t, e, r) {
                Mt.call(this, t, e),
                this.meshPerAttribute = r || 1
            }
            function ti(t, e, r, i) {
                this.ray = new $t(t,e),
                this.near = r || 0,
                this.far = i || 1 / 0,
                this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                },
                Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                            this.Points
                        }
                    }
                })
            }
            function ei(t, e) {
                return t.distance - e.distance
            }
            function ri(t, e, r, i) {
                if (t.visible !== !1 && (t.raycast(e, r),
                i === !0))
                    for (var n = t.children, o = 0, a = n.length; o < a; o++)
                        ri(n[o], e, r, !0)
            }
            function ii(t) {
                this.autoStart = void 0 === t || t,
                this.startTime = 0,
                this.oldTime = 0,
                this.elapsedTime = 0,
                this.running = !1
            }
            function ni(t) {
                function e(t, e, r, i, n, o, a) {
                    var s = .5 * (r - t)
                      , h = .5 * (i - e);
                    return (2 * (e - r) + s + h) * a + (-3 * (e - r) - 2 * s - h) * o + s * n + e
                }
                this.points = t;
                var r, i, n, o, a, h, c, l, u, p = [], d = {
                    x: 0,
                    y: 0,
                    z: 0
                };
                this.initFromArray = function(t) {
                    this.points = [];
                    for (var e = 0; e < t.length; e++)
                        this.points[e] = {
                            x: t[e][0],
                            y: t[e][1],
                            z: t[e][2]
                        }
                }
                ,
                this.getPoint = function(t) {
                    return r = (this.points.length - 1) * t,
                    i = Math.floor(r),
                    n = r - i,
                    p[0] = 0 === i ? i : i - 1,
                    p[1] = i,
                    p[2] = i > this.points.length - 2 ? this.points.length - 1 : i + 1,
                    p[3] = i > this.points.length - 3 ? this.points.length - 1 : i + 2,
                    h = this.points[p[0]],
                    c = this.points[p[1]],
                    l = this.points[p[2]],
                    u = this.points[p[3]],
                    o = n * n,
                    a = n * o,
                    d.x = e(h.x, c.x, l.x, u.x, n, o, a),
                    d.y = e(h.y, c.y, l.y, u.y, n, o, a),
                    d.z = e(h.z, c.z, l.z, u.z, n, o, a),
                    d
                }
                ,
                this.getControlPointsArray = function() {
                    var t, e, r = this.points.length, i = [];
                    for (t = 0; t < r; t++)
                        e = this.points[t],
                        i[t] = [e.x, e.y, e.z];
                    return i
                }
                ,
                this.getLength = function(t) {
                    var e, r, i, n, o = 0, a = 0, h = 0, c = new s, l = new s, u = [], p = 0;
                    for (u[0] = 0,
                    t || (t = 100),
                    i = this.points.length * t,
                    c.copy(this.points[0]),
                    e = 1; e < i; e++)
                        r = e / i,
                        n = this.getPoint(r),
                        l.copy(n),
                        p += l.distanceTo(c),
                        c.copy(n),
                        o = (this.points.length - 1) * r,
                        a = Math.floor(o),
                        a !== h && (u[a] = p,
                        h = a);
                    return u[u.length] = p,
                    {
                        chunks: u,
                        total: p
                    }
                }
                ,
                this.reparametrizeByArcLength = function(t) {
                    var e, r, i, n, o, a, h, c, l = [], u = new s, p = this.getLength();
                    for (l.push(u.copy(this.points[0]).clone()),
                    e = 1; e < this.points.length; e++) {
                        for (a = p.chunks[e] - p.chunks[e - 1],
                        h = Math.ceil(t * a / p.total),
                        n = (e - 1) / (this.points.length - 1),
                        o = e / (this.points.length - 1),
                        r = 1; r < h - 1; r++)
                            i = n + r * (1 / h) * (o - n),
                            c = this.getPoint(i),
                            l.push(u.copy(c).clone());
                        l.push(u.copy(this.points[e]).clone())
                    }
                    this.points = l
                }
            }
            function oi(t, e, r) {
                return this.radius = void 0 !== t ? t : 1,
                this.phi = void 0 !== e ? e : 0,
                this.theta = void 0 !== r ? r : 0,
                this
            }
            function ai(t, e) {
                ie.call(this, t, e),
                this.animationsMap = {},
                this.animationsList = [];
                var r = this.geometry.morphTargets.length
                  , i = "__default"
                  , n = 0
                  , o = r - 1
                  , a = r / 1;
                this.createAnimation(i, n, o, a),
                this.setAnimationWeight(i, 1)
            }
            function si(t) {
                Bt.call(this),
                this.material = t,
                this.render = function(t) {}
            }
            function hi(t) {
                function e(t, e) {
                    return t - e
                }
                Gt.call(this);
                var r = [0, 0]
                  , i = {}
                  , n = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    for (var o = t.vertices, a = t.faces, s = 0, h = new Uint32Array(6 * a.length), c = 0, l = a.length; c < l; c++)
                        for (var u = a[c], p = 0; p < 3; p++) {
                            r[0] = u[n[p]],
                            r[1] = u[n[(p + 1) % 3]],
                            r.sort(e);
                            var d = r.toString();
                            void 0 === i[d] && (h[2 * s] = r[0],
                            h[2 * s + 1] = r[1],
                            i[d] = !0,
                            s++)
                        }
                    for (var f = new Float32Array(2 * s * 3), c = 0, l = s; c < l; c++)
                        for (var p = 0; p < 2; p++) {
                            var m = o[h[2 * c + p]]
                              , g = 6 * c + 3 * p;
                            f[g + 0] = m.x,
                            f[g + 1] = m.y,
                            f[g + 2] = m.z
                        }
                    this.addAttribute("position", new Mt(f,3))
                } else if (t && t.isBufferGeometry)
                    if (null !== t.index) {
                        var v = t.index.array
                          , o = t.attributes.position
                          , y = t.groups
                          , s = 0;
                        0 === y.length && t.addGroup(0, v.length);
                        for (var h = new Uint32Array(2 * v.length), x = 0, b = y.length; x < b; ++x)
                            for (var w = y[x], _ = w.start, M = w.count, c = _, S = _ + M; c < S; c += 3)
                                for (var p = 0; p < 3; p++) {
                                    r[0] = v[c + p],
                                    r[1] = v[c + (p + 1) % 3],
                                    r.sort(e);
                                    var d = r.toString();
                                    void 0 === i[d] && (h[2 * s] = r[0],
                                    h[2 * s + 1] = r[1],
                                    i[d] = !0,
                                    s++)
                                }
                        for (var f = new Float32Array(2 * s * 3), c = 0, l = s; c < l; c++)
                            for (var p = 0; p < 2; p++) {
                                var g = 6 * c + 3 * p
                                  , E = h[2 * c + p];
                                f[g + 0] = o.getX(E),
                                f[g + 1] = o.getY(E),
                                f[g + 2] = o.getZ(E)
                            }
                        this.addAttribute("position", new Mt(f,3))
                    } else {
                        for (var o = t.attributes.position.array, s = o.length / 3, T = s / 3, f = new Float32Array(2 * s * 3), c = 0, l = T; c < l; c++)
                            for (var p = 0; p < 3; p++) {
                                var g = 18 * c + 6 * p
                                  , A = 9 * c + 3 * p;
                                f[g + 0] = o[A],
                                f[g + 1] = o[A + 1],
                                f[g + 2] = o[A + 2];
                                var E = 9 * c + 3 * ((p + 1) % 3);
                                f[g + 3] = o[E],
                                f[g + 4] = o[E + 1],
                                f[g + 5] = o[E + 2]
                            }
                        this.addAttribute("position", new Mt(f,3))
                    }
            }
            function ci(t, e) {
                var r = void 0 !== e ? e : 16777215;
                _e.call(this, new hi(t.geometry), new be({
                    color: r
                })),
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            function li(t, e, r, i) {
                this.object = t,
                this.size = void 0 !== e ? e : 1;
                var n = void 0 !== r ? r : 16711680
                  , o = void 0 !== i ? i : 1
                  , a = 0
                  , s = this.object.geometry;
                s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
                var h = new Gt
                  , c = new Pt(2 * a * 3,3);
                h.addAttribute("position", c),
                _e.call(this, h, new be({
                    color: n,
                    linewidth: o
                })),
                this.matrixAutoUpdate = !1,
                this.update()
            }
            function ui(t) {
                Bt.call(this),
                this.light = t,
                this.light.updateMatrixWorld(),
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1;
                for (var e = new Gt, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, n = 1, o = 32; i < o; i++,
                n++) {
                    var a = i / o * Math.PI * 2
                      , s = n / o * Math.PI * 2;
                    r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
                }
                e.addAttribute("position", new Pt(r,3));
                var h = new be({
                    fog: !1
                });
                this.cone = new _e(e,h),
                this.add(this.cone),
                this.update()
            }
            function pi(t) {
                this.bones = this.getBoneList(t);
                for (var e = new kt, r = 0; r < this.bones.length; r++) {
                    var i = this.bones[r];
                    i.parent && i.parent.isBone && (e.vertices.push(new s),
                    e.vertices.push(new s),
                    e.colors.push(new $(0,0,1)),
                    e.colors.push(new $(0,1,0)))
                }
                e.dynamic = !0;
                var n = new be({
                    vertexColors: Tn,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                _e.call(this, e, n),
                this.root = t,
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.update()
            }
            function di(t, e, r, i, n, o, a) {
                Gt.call(this),
                this.type = "SphereBufferGeometry",
                this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: r,
                    phiStart: i,
                    phiLength: n,
                    thetaStart: o,
                    thetaLength: a
                },
                t = t || 50,
                e = Math.max(3, Math.floor(e) || 8),
                r = Math.max(2, Math.floor(r) || 6),
                i = void 0 !== i ? i : 0,
                n = void 0 !== n ? n : 2 * Math.PI,
                o = void 0 !== o ? o : 0,
                a = void 0 !== a ? a : Math.PI;
                for (var h = o + a, c = (e + 1) * (r + 1), l = new Mt(new Float32Array(3 * c),3), u = new Mt(new Float32Array(3 * c),3), p = new Mt(new Float32Array(2 * c),2), d = 0, f = [], m = new s, g = 0; g <= r; g++) {
                    for (var v = [], y = g / r, x = 0; x <= e; x++) {
                        var b = x / e
                          , w = -t * Math.cos(i + b * n) * Math.sin(o + y * a)
                          , _ = t * Math.cos(o + y * a)
                          , M = t * Math.sin(i + b * n) * Math.sin(o + y * a);
                        m.set(w, _, M).normalize(),
                        l.setXYZ(d, w, _, M),
                        u.setXYZ(d, m.x, m.y, m.z),
                        p.setXY(d, b, 1 - y),
                        v.push(d),
                        d++
                    }
                    f.push(v)
                }
                for (var S = [], g = 0; g < r; g++)
                    for (var x = 0; x < e; x++) {
                        var E = f[g][x + 1]
                          , T = f[g][x]
                          , A = f[g + 1][x]
                          , L = f[g + 1][x + 1];
                        (0 !== g || o > 0) && S.push(E, T, L),
                        (g !== r - 1 || h < Math.PI) && S.push(T, A, L)
                    }
                this.setIndex(new (l.count > 65535 ? Rt : Lt)(S,1)),
                this.addAttribute("position", l),
                this.addAttribute("normal", u),
                this.addAttribute("uv", p),
                this.boundingSphere = new rt(new s,t)
            }
            function fi(t, e) {
                this.light = t,
                this.light.updateMatrixWorld();
                var r = new di(e,4,2)
                  , i = new re({
                    wireframe: !0,
                    fog: !1
                });
                i.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                ie.call(this, r, i),
                this.matrix = this.light.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            function mi(t, e, r, i, n, o, a) {
                kt.call(this),
                this.type = "SphereGeometry",
                this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: r,
                    phiStart: i,
                    phiLength: n,
                    thetaStart: o,
                    thetaLength: a
                },
                this.fromBufferGeometry(new di(t,e,r,i,n,o,a))
            }
            function gi(t, e) {
                Bt.call(this),
                this.light = t,
                this.light.updateMatrixWorld(),
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.colors = [new $, new $];
                var r = new mi(e,4,2);
                r.rotateX(-Math.PI / 2);
                for (var i = 0, n = 8; i < n; i++)
                    r.faces[i].color = this.colors[i < 4 ? 0 : 1];
                var o = new re({
                    vertexColors: En,
                    wireframe: !0
                });
                this.lightSphere = new ie(r,o),
                this.add(this.lightSphere),
                this.update()
            }
            function vi(t, e, r, i) {
                e = e || 1,
                r = new $(void 0 !== r ? r : 4473924),
                i = new $(void 0 !== i ? i : 8947848);
                for (var n = e / 2, o = 2 * t / e, a = [], s = [], h = 0, c = 0, l = -t; h <= e; h++,
                l += o) {
                    a.push(-t, 0, l, t, 0, l),
                    a.push(l, 0, -t, l, 0, t);
                    var u = h === n ? r : i;
                    u.toArray(s, c),
                    c += 3,
                    u.toArray(s, c),
                    c += 3,
                    u.toArray(s, c),
                    c += 3,
                    u.toArray(s, c),
                    c += 3
                }
                var p = new Gt;
                p.addAttribute("position", new Pt(a,3)),
                p.addAttribute("color", new Pt(s,3));
                var d = new be({
                    vertexColors: Tn
                });
                _e.call(this, p, d)
            }
            function yi(t, e, r, i) {
                this.object = t,
                this.size = void 0 !== e ? e : 1;
                var n = void 0 !== r ? r : 16776960
                  , o = void 0 !== i ? i : 1
                  , a = 0
                  , s = this.object.geometry;
                s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var h = new Gt
                  , c = new Pt(2 * a * 3,3);
                h.addAttribute("position", c),
                _e.call(this, h, new be({
                    color: n,
                    linewidth: o
                })),
                this.matrixAutoUpdate = !1,
                this.update()
            }
            function xi(e, r) {
                function i(t, e) {
                    return t - e
                }
                Gt.call(this),
                r = void 0 !== r ? r : 1;
                var n, o = Math.cos(t.Math.DEG2RAD * r), a = [0, 0], s = {}, h = ["a", "b", "c"];
                e && e.isBufferGeometry ? (n = new kt,
                n.fromBufferGeometry(e)) : n = e.clone(),
                n.mergeVertices(),
                n.computeFaceNormals();
                for (var c = n.vertices, l = n.faces, u = 0, p = l.length; u < p; u++)
                    for (var d = l[u], f = 0; f < 3; f++) {
                        a[0] = d[h[f]],
                        a[1] = d[h[(f + 1) % 3]],
                        a.sort(i);
                        var m = a.toString();
                        void 0 === s[m] ? s[m] = {
                            vert1: a[0],
                            vert2: a[1],
                            face1: u,
                            face2: void 0
                        } : s[m].face2 = u
                    }
                var g = [];
                for (var m in s) {
                    var v = s[m];
                    if (void 0 === v.face2 || l[v.face1].normal.dot(l[v.face2].normal) <= o) {
                        var y = c[v.vert1];
                        g.push(y.x),
                        g.push(y.y),
                        g.push(y.z),
                        y = c[v.vert2],
                        g.push(y.x),
                        g.push(y.y),
                        g.push(y.z)
                    }
                }
                this.addAttribute("position", new Mt(new Float32Array(g),3))
            }
            function bi(t, e, r) {
                var i = void 0 !== e ? e : 16777215;
                _e.call(this, new xi(t.geometry,r), new be({
                    color: i
                })),
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            function wi(t, e) {
                Bt.call(this),
                this.light = t,
                this.light.updateMatrixWorld(),
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1,
                void 0 === e && (e = 1);
                var r = new Gt;
                r.addAttribute("position", new Pt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0],3));
                var i = new be({
                    fog: !1
                });
                this.add(new we(r,i)),
                r = new Gt,
                r.addAttribute("position", new Pt([0, 0, 0, 0, 0, 1],3)),
                this.add(new we(r,i)),
                this.update()
            }
            function _i(t) {
                function e(t, e, i) {
                    r(t, i),
                    r(e, i)
                }
                function r(t, e) {
                    i.vertices.push(new s),
                    i.colors.push(new $(e)),
                    void 0 === o[t] && (o[t] = []),
                    o[t].push(i.vertices.length - 1)
                }
                var i = new kt
                  , n = new be({
                    color: 16777215,
                    vertexColors: En
                })
                  , o = {}
                  , a = 16755200
                  , h = 16711680
                  , c = 43775
                  , l = 16777215
                  , u = 3355443;
                e("n1", "n2", a),
                e("n2", "n4", a),
                e("n4", "n3", a),
                e("n3", "n1", a),
                e("f1", "f2", a),
                e("f2", "f4", a),
                e("f4", "f3", a),
                e("f3", "f1", a),
                e("n1", "f1", a),
                e("n2", "f2", a),
                e("n3", "f3", a),
                e("n4", "f4", a),
                e("p", "n1", h),
                e("p", "n2", h),
                e("p", "n3", h),
                e("p", "n4", h),
                e("u1", "u2", c),
                e("u2", "u3", c),
                e("u3", "u1", c),
                e("c", "t", l),
                e("p", "c", u),
                e("cn1", "cn2", u),
                e("cn3", "cn4", u),
                e("cf1", "cf2", u),
                e("cf3", "cf4", u),
                _e.call(this, i, n),
                this.camera = t,
                this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.pointMap = o,
                this.update()
            }
            function Mi(t, e, r, i, n, o) {
                kt.call(this),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    depth: r,
                    widthSegments: i,
                    heightSegments: n,
                    depthSegments: o
                },
                this.fromBufferGeometry(new Kt(t,e,r,i,n,o)),
                this.mergeVertices()
            }
            function Si(t, e) {
                var r = void 0 !== e ? e : 8947848;
                this.object = t,
                this.box = new et,
                ie.call(this, new Mi(1,1,1), new re({
                    color: r,
                    wireframe: !0
                }))
            }
            function Ei(t, e) {
                void 0 === e && (e = 16776960);
                var r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , i = new Float32Array(24)
                  , n = new Gt;
                n.setIndex(new Mt(r,1)),
                n.addAttribute("position", new Mt(i,3)),
                _e.call(this, n, new be({
                    color: e
                })),
                void 0 !== t && this.update(t)
            }
            function Ti(t, e, i, n, o, a, h, c) {
                function l() {
                    var t = (n + 1) * (o + 1);
                    return a === !1 && (t += (n + 1) * m + n * m),
                    t
                }
                function u() {
                    var t = n * o * 2 * 3;
                    return a === !1 && (t += n * m * 3),
                    t
                }
                function p() {
                    var r, a, l = new s, u = new s, p = 0, d = (e - t) / i;
                    for (a = 0; a <= o; a++) {
                        var m = []
                          , g = a / o
                          , v = g * (e - t) + t;
                        for (r = 0; r <= n; r++) {
                            var A = r / n;
                            u.x = v * Math.sin(A * c + h),
                            u.y = -g * i + E,
                            u.z = v * Math.cos(A * c + h),
                            x.setXYZ(_, u.x, u.y, u.z),
                            l.copy(u),
                            (0 === t && 0 === a || 0 === e && a === o) && (l.x = Math.sin(A * c + h),
                            l.z = Math.cos(A * c + h)),
                            l.setY(Math.sqrt(l.x * l.x + l.z * l.z) * d).normalize(),
                            b.setXYZ(_, l.x, l.y, l.z),
                            w.setXY(_, A, 1 - g),
                            m.push(_),
                            _++
                        }
                        S.push(m)
                    }
                    for (r = 0; r < n; r++)
                        for (a = 0; a < o; a++) {
                            var L = S[a][r]
                              , C = S[a + 1][r]
                              , R = S[a + 1][r + 1]
                              , P = S[a][r + 1];
                            y.setX(M, L),
                            M++,
                            y.setX(M, C),
                            M++,
                            y.setX(M, P),
                            M++,
                            y.setX(M, C),
                            M++,
                            y.setX(M, R),
                            M++,
                            y.setX(M, P),
                            M++,
                            p += 6
                        }
                    f.addGroup(T, p, 0),
                    T += p
                }
                function d(i) {
                    var o, a, l, u = new r, p = new s, d = 0, m = i === !0 ? t : e, g = i === !0 ? 1 : -1;
                    for (a = _,
                    o = 1; o <= n; o++)
                        x.setXYZ(_, 0, E * g, 0),
                        b.setXYZ(_, 0, g, 0),
                        u.x = .5,
                        u.y = .5,
                        w.setXY(_, u.x, u.y),
                        _++;
                    for (l = _,
                    o = 0; o <= n; o++) {
                        var v = o / n
                          , S = v * c + h
                          , A = Math.cos(S)
                          , L = Math.sin(S);
                        p.x = m * L,
                        p.y = E * g,
                        p.z = m * A,
                        x.setXYZ(_, p.x, p.y, p.z),
                        b.setXYZ(_, 0, g, 0),
                        u.x = .5 * A + .5,
                        u.y = .5 * L * g + .5,
                        w.setXY(_, u.x, u.y),
                        _++
                    }
                    for (o = 0; o < n; o++) {
                        var C = a + o
                          , R = l + o;
                        i === !0 ? (y.setX(M, R),
                        M++,
                        y.setX(M, R + 1),
                        M++,
                        y.setX(M, C),
                        M++) : (y.setX(M, R + 1),
                        M++,
                        y.setX(M, R),
                        M++,
                        y.setX(M, C),
                        M++),
                        d += 3
                    }
                    f.addGroup(T, d, i === !0 ? 1 : 2),
                    T += d
                }
                Gt.call(this),
                this.type = "CylinderBufferGeometry",
                this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: i,
                    radialSegments: n,
                    heightSegments: o,
                    openEnded: a,
                    thetaStart: h,
                    thetaLength: c
                };
                var f = this;
                t = void 0 !== t ? t : 20,
                e = void 0 !== e ? e : 20,
                i = void 0 !== i ? i : 100,
                n = Math.floor(n) || 8,
                o = Math.floor(o) || 1,
                a = void 0 !== a && a,
                h = void 0 !== h ? h : 0,
                c = void 0 !== c ? c : 2 * Math.PI;
                var m = 0;
                a === !1 && (t > 0 && m++,
                e > 0 && m++);
                var g = l()
                  , v = u()
                  , y = new Mt(new (v > 65535 ? Uint32Array : Uint16Array)(v),1)
                  , x = new Mt(new Float32Array(3 * g),3)
                  , b = new Mt(new Float32Array(3 * g),3)
                  , w = new Mt(new Float32Array(2 * g),2)
                  , _ = 0
                  , M = 0
                  , S = []
                  , E = i / 2
                  , T = 0;
                p(),
                a === !1 && (t > 0 && d(!0),
                e > 0 && d(!1)),
                this.setIndex(y),
                this.addAttribute("position", x),
                this.addAttribute("normal", b),
                this.addAttribute("uv", w)
            }
            function Ai(t, e, r, i, n, o) {
                Bt.call(this),
                void 0 === i && (i = 16776960),
                void 0 === r && (r = 1),
                void 0 === n && (n = .2 * r),
                void 0 === o && (o = .2 * n),
                this.position.copy(e),
                this.line = new we(zh,new be({
                    color: i
                })),
                this.line.matrixAutoUpdate = !1,
                this.add(this.line),
                this.cone = new ie(Vh,new re({
                    color: i
                })),
                this.cone.matrixAutoUpdate = !1,
                this.add(this.cone),
                this.setDirection(t),
                this.setLength(r, n, o)
            }
            function Li(t) {
                t = t || 1;
                var e = new Float32Array([0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t])
                  , r = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1])
                  , i = new Gt;
                i.addAttribute("position", new Mt(e,3)),
                i.addAttribute("color", new Mt(r,3));
                var n = new be({
                    vertexColors: Tn
                });
                _e.call(this, i, n)
            }
            function Ci(t, e, i) {
                kt.call(this),
                this.type = "ParametricGeometry",
                this.parameters = {
                    func: t,
                    slices: e,
                    stacks: i
                };
                var n, o, a, s, h, c = this.vertices, l = this.faces, u = this.faceVertexUvs[0], p = e + 1;
                for (n = 0; n <= i; n++)
                    for (h = n / i,
                    o = 0; o <= e; o++)
                        s = o / e,
                        a = t(s, h),
                        c.push(a);
                var d, f, m, g, v, y, x, b;
                for (n = 0; n < i; n++)
                    for (o = 0; o < e; o++)
                        d = n * p + o,
                        f = n * p + o + 1,
                        m = (n + 1) * p + o + 1,
                        g = (n + 1) * p + o,
                        v = new r(o / e,n / i),
                        y = new r((o + 1) / e,n / i),
                        x = new r((o + 1) / e,(n + 1) / i),
                        b = new r(o / e,(n + 1) / i),
                        l.push(new Dt(d,f,g)),
                        u.push([v, y, b]),
                        l.push(new Dt(f,m,g)),
                        u.push([y.clone(), x, b.clone()]);
                this.computeFaceNormals(),
                this.computeVertexNormals()
            }
            function Ri(t, e, i, n) {
                function o(t) {
                    var e = t.normalize().clone();
                    e.index = p.vertices.push(e) - 1;
                    var i = c(t) / 2 / Math.PI + .5
                      , n = l(t) / Math.PI + .5;
                    return e.uv = new r(i,1 - n),
                    e
                }
                function a(t, e, r) {
                    var i = new Dt(t.index,e.index,r.index,[t.clone(), e.clone(), r.clone()]);
                    p.faces.push(i),
                    w.copy(t).add(e).add(r).divideScalar(3);
                    var n = c(w);
                    p.faceVertexUvs[0].push([u(t.uv, t, n), u(e.uv, e, n), u(r.uv, r, n)])
                }
                function h(t, e) {
                    for (var r = Math.pow(2, e), i = o(p.vertices[t.a]), n = o(p.vertices[t.b]), s = o(p.vertices[t.c]), h = [], c = 0; c <= r; c++) {
                        h[c] = [];
                        for (var l = o(i.clone().lerp(s, c / r)), u = o(n.clone().lerp(s, c / r)), d = r - c, f = 0; f <= d; f++)
                            0 === f && c === r ? h[c][f] = l : h[c][f] = o(l.clone().lerp(u, f / d))
                    }
                    for (var c = 0; c < r; c++)
                        for (var f = 0; f < 2 * (r - c) - 1; f++) {
                            var m = Math.floor(f / 2);
                            f % 2 === 0 ? a(h[c][m + 1], h[c + 1][m], h[c][m]) : a(h[c][m + 1], h[c + 1][m + 1], h[c + 1][m])
                        }
                }
                function c(t) {
                    return Math.atan2(t.z, -t.x)
                }
                function l(t) {
                    return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                }
                function u(t, e, i) {
                    return i < 0 && 1 === t.x && (t = new r(t.x - 1,t.y)),
                    0 === e.x && 0 === e.z && (t = new r(i / 2 / Math.PI + .5,t.y)),
                    t.clone()
                }
                kt.call(this),
                this.type = "PolyhedronGeometry",
                this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: i,
                    detail: n
                },
                i = i || 1,
                n = n || 0;
                for (var p = this, d = 0, f = t.length; d < f; d += 3)
                    o(new s(t[d],t[d + 1],t[d + 2]));
                for (var m = this.vertices, g = [], d = 0, v = 0, f = e.length; d < f; d += 3,
                v++) {
                    var y = m[e[d]]
                      , x = m[e[d + 1]]
                      , b = m[e[d + 2]];
                    g[v] = new Dt(y.index,x.index,b.index,[y.clone(), x.clone(), b.clone()])
                }
                for (var w = new s, d = 0, f = g.length; d < f; d++)
                    h(g[d], n);
                for (var d = 0, f = this.faceVertexUvs[0].length; d < f; d++) {
                    var _ = this.faceVertexUvs[0][d]
                      , M = _[0].x
                      , S = _[1].x
                      , E = _[2].x
                      , T = Math.max(M, S, E)
                      , A = Math.min(M, S, E);
                    T > .9 && A < .1 && (M < .2 && (_[0].x += 1),
                    S < .2 && (_[1].x += 1),
                    E < .2 && (_[2].x += 1))
                }
                for (var d = 0, f = this.vertices.length; d < f; d++)
                    this.vertices[d].multiplyScalar(i);
                this.mergeVertices(),
                this.computeFaceNormals(),
                this.boundingSphere = new rt(new s,i)
            }
            function Pi(t, e) {
                var r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
                  , i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                Ri.call(this, r, i, t, e),
                this.type = "TetrahedronGeometry",
                this.parameters = {
                    radius: t,
                    detail: e
                }
            }
            function Ui(t, e) {
                var r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
                  , i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                Ri.call(this, r, i, t, e),
                this.type = "OctahedronGeometry",
                this.parameters = {
                    radius: t,
                    detail: e
                }
            }
            function Ii(t, e) {
                var r = (1 + Math.sqrt(5)) / 2
                  , i = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1]
                  , n = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                Ri.call(this, i, n, t, e),
                this.type = "IcosahedronGeometry",
                this.parameters = {
                    radius: t,
                    detail: e
                }
            }
            function Di(t, e) {
                var r = (1 + Math.sqrt(5)) / 2
                  , i = 1 / r
                  , n = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, 0, -r, 0, -i, r, 0, -i, -r, 0, i, r, 0, i]
                  , o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                Ri.call(this, n, o, t, e),
                this.type = "DodecahedronGeometry",
                this.parameters = {
                    radius: t,
                    detail: e
                }
            }
            function Oi(t, e, i, n, o, a) {
                function h(t, e, r, i, n) {
                    var o = Math.cos(t)
                      , a = Math.sin(t)
                      , s = r / e * t
                      , h = Math.cos(s);
                    n.x = i * (2 + h) * .5 * o,
                    n.y = i * (2 + h) * a * .5,
                    n.z = i * Math.sin(s) * .5
                }
                Gt.call(this),
                this.type = "TorusKnotBufferGeometry",
                this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: i,
                    radialSegments: n,
                    p: o,
                    q: a
                },
                t = t || 100,
                e = e || 40,
                i = Math.floor(i) || 64,
                n = Math.floor(n) || 8,
                o = o || 2,
                a = a || 3;
                var c, l, u = (n + 1) * (i + 1), p = n * i * 2 * 3, d = new Mt(new (p > 65535 ? Uint32Array : Uint16Array)(p),1), f = new Mt(new Float32Array(3 * u),3), m = new Mt(new Float32Array(3 * u),3), g = new Mt(new Float32Array(2 * u),2), v = 0, y = 0, x = new s, b = new s, w = new r, _ = new s, M = new s, S = new s, E = new s, T = new s;
                for (c = 0; c <= i; ++c) {
                    var A = c / i * o * Math.PI * 2;
                    for (h(A, o, a, t, _),
                    h(A + .01, o, a, t, M),
                    E.subVectors(M, _),
                    T.addVectors(M, _),
                    S.crossVectors(E, T),
                    T.crossVectors(S, E),
                    S.normalize(),
                    T.normalize(),
                    l = 0; l <= n; ++l) {
                        var L = l / n * Math.PI * 2
                          , C = -e * Math.cos(L)
                          , R = e * Math.sin(L);
                        x.x = _.x + (C * T.x + R * S.x),
                        x.y = _.y + (C * T.y + R * S.y),
                        x.z = _.z + (C * T.z + R * S.z),
                        f.setXYZ(v, x.x, x.y, x.z),
                        b.subVectors(x, _).normalize(),
                        m.setXYZ(v, b.x, b.y, b.z),
                        w.x = c / i,
                        w.y = l / n,
                        g.setXY(v, w.x, w.y),
                        v++
                    }
                }
                for (l = 1; l <= i; l++)
                    for (c = 1; c <= n; c++) {
                        var P = (n + 1) * (l - 1) + (c - 1)
                          , U = (n + 1) * l + (c - 1)
                          , I = (n + 1) * l + c
                          , D = (n + 1) * (l - 1) + c;
                        d.setX(y, P),
                        y++,
                        d.setX(y, U),
                        y++,
                        d.setX(y, D),
                        y++,
                        d.setX(y, U),
                        y++,
                        d.setX(y, I),
                        y++,
                        d.setX(y, D),
                        y++
                    }
                this.setIndex(d),
                this.addAttribute("position", f),
                this.addAttribute("normal", m),
                this.addAttribute("uv", g)
            }
            function Ni(t, e, r, i, n, o, a) {
                kt.call(this),
                this.type = "TorusKnotGeometry",
                this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: r,
                    radialSegments: i,
                    p: n,
                    q: o
                },
                void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
                this.fromBufferGeometry(new Oi(t,e,r,i,n,o)),
                this.mergeVertices()
            }
            function Bi(t, e, r, i, n) {
                Gt.call(this),
                this.type = "TorusBufferGeometry",
                this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: r,
                    tubularSegments: i,
                    arc: n
                },
                t = t || 100,
                e = e || 40,
                r = Math.floor(r) || 8,
                i = Math.floor(i) || 6,
                n = n || 2 * Math.PI;
                var o, a, h = (r + 1) * (i + 1), c = r * i * 2 * 3, l = new (c > 65535 ? Uint32Array : Uint16Array)(c), u = new Float32Array(3 * h), p = new Float32Array(3 * h), d = new Float32Array(2 * h), f = 0, m = 0, g = 0, v = new s, y = new s, x = new s;
                for (o = 0; o <= r; o++)
                    for (a = 0; a <= i; a++) {
                        var b = a / i * n
                          , w = o / r * Math.PI * 2;
                        y.x = (t + e * Math.cos(w)) * Math.cos(b),
                        y.y = (t + e * Math.cos(w)) * Math.sin(b),
                        y.z = e * Math.sin(w),
                        u[f] = y.x,
                        u[f + 1] = y.y,
                        u[f + 2] = y.z,
                        v.x = t * Math.cos(b),
                        v.y = t * Math.sin(b),
                        x.subVectors(y, v).normalize(),
                        p[f] = x.x,
                        p[f + 1] = x.y,
                        p[f + 2] = x.z,
                        d[m] = a / i,
                        d[m + 1] = o / r,
                        f += 3,
                        m += 2
                    }
                for (o = 1; o <= r; o++)
                    for (a = 1; a <= i; a++) {
                        var _ = (i + 1) * o + a - 1
                          , M = (i + 1) * (o - 1) + a - 1
                          , S = (i + 1) * (o - 1) + a
                          , E = (i + 1) * o + a;
                        l[g] = _,
                        l[g + 1] = M,
                        l[g + 2] = E,
                        l[g + 3] = M,
                        l[g + 4] = S,
                        l[g + 5] = E,
                        g += 6
                    }
                this.setIndex(new Mt(l,1)),
                this.addAttribute("position", new Mt(u,3)),
                this.addAttribute("normal", new Mt(p,3)),
                this.addAttribute("uv", new Mt(d,2))
            }
            function Fi(t, e, r, i, n) {
                kt.call(this),
                this.type = "TorusGeometry",
                this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: r,
                    tubularSegments: i,
                    arc: n
                },
                this.fromBufferGeometry(new Bi(t,e,r,i,n))
            }
            function ki(t, e) {
                e = e || {};
                var r = e.font;
                if ((r && r.isFont) === !1)
                    return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
                    new kt;
                var i = r.generateShapes(t, e.size, e.curveSegments);
                e.amount = void 0 !== e.height ? e.height : 50,
                void 0 === e.bevelThickness && (e.bevelThickness = 10),
                void 0 === e.bevelSize && (e.bevelSize = 8),
                void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
                Lr.call(this, i, e),
                this.type = "TextGeometry"
            }
            function zi(t, e, i, n, o, a) {
                Gt.call(this),
                this.type = "RingBufferGeometry",
                this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: o,
                    thetaLength: a
                },
                t = t || 20,
                e = e || 50,
                o = void 0 !== o ? o : 0,
                a = void 0 !== a ? a : 2 * Math.PI,
                i = void 0 !== i ? Math.max(3, i) : 8,
                n = void 0 !== n ? Math.max(1, n) : 1;
                var h, c, l, u = (i + 1) * (n + 1), p = i * n * 2 * 3, d = new Mt(new (p > 65535 ? Uint32Array : Uint16Array)(p),1), f = new Mt(new Float32Array(3 * u),3), m = new Mt(new Float32Array(3 * u),3), g = new Mt(new Float32Array(2 * u),2), v = 0, y = 0, x = t, b = (e - t) / n, w = new s, _ = new r;
                for (c = 0; c <= n; c++) {
                    for (l = 0; l <= i; l++)
                        h = o + l / i * a,
                        w.x = x * Math.cos(h),
                        w.y = x * Math.sin(h),
                        f.setXYZ(v, w.x, w.y, w.z),
                        m.setXYZ(v, 0, 0, 1),
                        _.x = (w.x / e + 1) / 2,
                        _.y = (w.y / e + 1) / 2,
                        g.setXY(v, _.x, _.y),
                        v++;
                    x += b
                }
                for (c = 0; c < n; c++) {
                    var M = c * (i + 1);
                    for (l = 0; l < i; l++) {
                        h = l + M;
                        var S = h
                          , E = h + i + 1
                          , T = h + i + 2
                          , A = h + 1;
                        d.setX(y, S),
                        y++,
                        d.setX(y, E),
                        y++,
                        d.setX(y, T),
                        y++,
                        d.setX(y, S),
                        y++,
                        d.setX(y, T),
                        y++,
                        d.setX(y, A),
                        y++
                    }
                }
                this.setIndex(d),
                this.addAttribute("position", f),
                this.addAttribute("normal", m),
                this.addAttribute("uv", g)
            }
            function Vi(t, e, r, i, n, o) {
                kt.call(this),
                this.type = "RingGeometry",
                this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: r,
                    phiSegments: i,
                    thetaStart: n,
                    thetaLength: o
                },
                this.fromBufferGeometry(new zi(t,e,r,i,n,o))
            }
            function Gi(t, e, r, i) {
                kt.call(this),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: r,
                    heightSegments: i
                },
                this.fromBufferGeometry(new ne(t,e,r,i))
            }
            function ji(e, i, n, o) {
                Gt.call(this),
                this.type = "LatheBufferGeometry",
                this.parameters = {
                    points: e,
                    segments: i,
                    phiStart: n,
                    phiLength: o
                },
                i = Math.floor(i) || 12,
                n = n || 0,
                o = o || 2 * Math.PI,
                o = t.Math.clamp(o, 0, 2 * Math.PI);
                var a, h, c, l = (i + 1) * e.length, u = i * e.length * 2 * 3, p = new Mt(new (u > 65535 ? Uint32Array : Uint16Array)(u),1), d = new Mt(new Float32Array(3 * l),3), f = new Mt(new Float32Array(2 * l),2), m = 0, g = 0, v = 1 / i, y = new s, x = new r;
                for (h = 0; h <= i; h++) {
                    var b = n + h * v * o
                      , w = Math.sin(b)
                      , _ = Math.cos(b);
                    for (c = 0; c <= e.length - 1; c++)
                        y.x = e[c].x * w,
                        y.y = e[c].y,
                        y.z = e[c].x * _,
                        d.setXYZ(m, y.x, y.y, y.z),
                        x.x = h / i,
                        x.y = c / (e.length - 1),
                        f.setXY(m, x.x, x.y),
                        m++
                }
                for (h = 0; h < i; h++)
                    for (c = 0; c < e.length - 1; c++) {
                        a = c + h * e.length;
                        var M = a
                          , S = a + e.length
                          , E = a + e.length + 1
                          , T = a + 1;
                        p.setX(g, M),
                        g++,
                        p.setX(g, S),
                        g++,
                        p.setX(g, T),
                        g++,
                        p.setX(g, S),
                        g++,
                        p.setX(g, E),
                        g++,
                        p.setX(g, T),
                        g++
                    }
                if (this.setIndex(p),
                this.addAttribute("position", d),
                this.addAttribute("uv", f),
                this.computeVertexNormals(),
                o === 2 * Math.PI) {
                    var A = this.attributes.normal.array
                      , L = new s
                      , C = new s
                      , R = new s;
                    for (a = i * e.length * 3,
                    h = 0,
                    c = 0; h < e.length; h++,
                    c += 3)
                        L.x = A[c + 0],
                        L.y = A[c + 1],
                        L.z = A[c + 2],
                        C.x = A[a + c + 0],
                        C.y = A[a + c + 1],
                        C.z = A[a + c + 2],
                        R.addVectors(L, C).normalize(),
                        A[c + 0] = A[a + c + 0] = R.x,
                        A[c + 1] = A[a + c + 1] = R.y,
                        A[c + 2] = A[a + c + 2] = R.z
                }
            }
            function Hi(t, e, r, i) {
                kt.call(this),
                this.type = "LatheGeometry",
                this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: r,
                    phiLength: i
                },
                this.fromBufferGeometry(new ji(t,e,r,i)),
                this.mergeVertices()
            }
            function Wi(t, e, r, i, n, o, a, s) {
                kt.call(this),
                this.type = "CylinderGeometry",
                this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: r,
                    radialSegments: i,
                    heightSegments: n,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                },
                this.fromBufferGeometry(new Ti(t,e,r,i,n,o,a,s)),
                this.mergeVertices()
            }
            function Xi(t, e, r, i, n, o, a) {
                Wi.call(this, 0, t, e, r, i, n, o, a),
                this.type = "ConeGeometry",
                this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: n,
                    thetaStart: o,
                    thetaLength: a
                }
            }
            function Yi(t, e, r, i, n, o, a) {
                Ti.call(this, 0, t, e, r, i, n, o, a),
                this.type = "ConeBufferGeometry",
                this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: r,
                    heightSegments: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }
            function qi(t, e, r, i) {
                Gt.call(this),
                this.type = "CircleBufferGeometry",
                this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: r,
                    thetaLength: i
                },
                t = t || 50,
                e = void 0 !== e ? Math.max(3, e) : 8,
                r = void 0 !== r ? r : 0,
                i = void 0 !== i ? i : 2 * Math.PI;
                var n = e + 2
                  , o = new Float32Array(3 * n)
                  , a = new Float32Array(3 * n)
                  , h = new Float32Array(2 * n);
                a[2] = 1,
                h[0] = .5,
                h[1] = .5;
                for (var c = 0, l = 3, u = 2; c <= e; c++,
                l += 3,
                u += 2) {
                    var p = r + c / e * i;
                    o[l] = t * Math.cos(p),
                    o[l + 1] = t * Math.sin(p),
                    a[l + 2] = 1,
                    h[u] = (o[l] / t + 1) / 2,
                    h[u + 1] = (o[l + 1] / t + 1) / 2
                }
                for (var d = [], l = 1; l <= e; l++)
                    d.push(l, l + 1, 0);
                this.setIndex(new Mt(new Uint16Array(d),1)),
                this.addAttribute("position", new Mt(o,3)),
                this.addAttribute("normal", new Mt(a,3)),
                this.addAttribute("uv", new Mt(h,2)),
                this.boundingSphere = new rt(new s,t)
            }
            function Zi(t, e, r, i) {
                kt.call(this),
                this.type = "CircleGeometry",
                this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: r,
                    thetaLength: i
                },
                this.fromBufferGeometry(new qi(t,e,r,i))
            }
            function Qi(e) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."),
                t.CatmullRomCurve3.call(this, e),
                this.type = "catmullrom",
                this.closed = !0
            }
            function Ji(t, e, r, i, n, o) {
                Mr.call(this, t, e, r, r, i, n, o)
            }
            function Ki(t, e, r, i, n, o, a) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
                new Dt(t,e,r,n,o,a)
            }
            function $i(t, e) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
                new Se(t,e)
            }
            function tn(t, e) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
                new Se(t,e)
            }
            function en(t) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
                new Me(t)
            }
            function rn(t) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
                new Me(t)
            }
            function nn(t) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
                new Me(t)
            }
            function on(t, e, r) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
                new s(t,e,r)
            }
            function an() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
                this.projectVector = function(t, e) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."),
                    t.project(e)
                }
                ,
                this.unprojectVector = function(t, e) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
                    t.unproject(e)
                }
                ,
                this.pickingRay = function(t, e) {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }
            function sn() {
                console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),
                this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                this.clear = function() {}
                ,
                this.render = function() {}
                ,
                this.setClearColor = function() {}
                ,
                this.setSize = function() {}
            }
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
            void 0 === Math.sign && (Math.sign = function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : +t
            }
            ),
            void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
                }
            }),
            void 0 === Object.assign && !function() {
                Object.assign = function(t) {
                    if (void 0 === t || null === t)
                        throw new TypeError("Cannot convert undefined or null to object");
                    for (var e = Object(t), r = 1; r < arguments.length; r++) {
                        var i = arguments[r];
                        if (void 0 !== i && null !== i)
                            for (var n in i)
                                Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
                    }
                    return e
                }
            }(),
            Object.assign(e.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var r = this._listeners;
                    void 0 === r[t] && (r[t] = []),
                    r[t].indexOf(e) === -1 && r[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners)
                        return !1;
                    var r = this._listeners;
                    return void 0 !== r[t] && r[t].indexOf(e) !== -1
                },
                removeEventListener: function(t, e) {
                    if (void 0 !== this._listeners) {
                        var r = this._listeners
                          , i = r[t];
                        if (void 0 !== i) {
                            var n = i.indexOf(e);
                            n !== -1 && i.splice(n, 1)
                        }
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 !== this._listeners) {
                        var e = this._listeners
                          , r = e[t.type];
                        if (void 0 !== r) {
                            t.target = this;
                            var i = []
                              , n = 0
                              , o = r.length;
                            for (n = 0; n < o; n++)
                                i[n] = r[n];
                            for (n = 0; n < o; n++)
                                i[n].call(this, t)
                        }
                    }
                }
            });
            var hn = "80"
              , cn = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            }
              , ln = 0
              , un = 1
              , pn = 2
              , dn = 3
              , fn = 0
              , mn = 1
              , gn = 0
              , vn = 1
              , yn = 2
              , xn = 0
              , bn = 1
              , wn = 2
              , _n = 1
              , Mn = 2
              , Sn = 0
              , En = 1
              , Tn = 2
              , An = 0
              , Ln = 1
              , Cn = 2
              , Rn = 3
              , Pn = 4
              , Un = 5
              , In = 100
              , Dn = 101
              , On = 102
              , Nn = 103
              , Bn = 104
              , Fn = 200
              , kn = 201
              , zn = 202
              , Vn = 203
              , Gn = 204
              , jn = 205
              , Hn = 206
              , Wn = 207
              , Xn = 208
              , Yn = 209
              , qn = 210
              , Zn = 0
              , Qn = 1
              , Jn = 2
              , Kn = 3
              , $n = 4
              , to = 5
              , eo = 6
              , ro = 7
              , io = 0
              , no = 1
              , oo = 2
              , ao = 0
              , so = 1
              , ho = 2
              , co = 3
              , lo = 4
              , uo = 300
              , po = 301
              , fo = 302
              , mo = 303
              , go = 304
              , vo = 305
              , yo = 306
              , xo = 307
              , bo = 1e3
              , wo = 1001
              , _o = 1002
              , Mo = 1003
              , So = 1004
              , Eo = 1005
              , To = 1006
              , Ao = 1007
              , Lo = 1008
              , Co = 1009
              , Ro = 1010
              , Po = 1011
              , Uo = 1012
              , Io = 1013
              , Do = 1014
              , Oo = 1015
              , No = 1016
              , Bo = 1017
              , Fo = 1018
              , ko = 1019
              , zo = 1020
              , Vo = 1021
              , Go = 1022
              , jo = 1023
              , Ho = 1024
              , Wo = 1025
              , Xo = jo
              , Yo = 1026
              , qo = 1027
              , Zo = 2001
              , Qo = 2002
              , Jo = 2003
              , Ko = 2004
              , $o = 2100
              , ta = 2101
              , ea = 2102
              , ra = 2103
              , ia = 2151
              , na = 2200
              , oa = 2201
              , aa = 2202
              , sa = 2300
              , ha = 2301
              , ca = 2302
              , la = 2400
              , ua = 2401
              , pa = 2402
              , da = 0
              , fa = 1
              , ma = 2
              , ga = 3e3
              , va = 3001
              , ya = 3007
              , xa = 3002
              , ba = 3003
              , wa = 3004
              , _a = 3005
              , Ma = 3006
              , Sa = 3200
              , Ea = 3201;
            t.Math = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), r = new Array(36), i = 0;
                    return function() {
                        for (var n = 0; n < 36; n++)
                            8 === n || 13 === n || 18 === n || 23 === n ? r[n] = "-" : 14 === n ? r[n] = "4" : (i <= 2 && (i = 33554432 + 16777216 * Math.random() | 0),
                            t = 15 & i,
                            i >>= 4,
                            r[n] = e[19 === n ? 3 & t | 8 : t]);
                        return r.join("")
                    }
                }(),
                clamp: function(t, e, r) {
                    return Math.max(e, Math.min(r, t))
                },
                euclideanModulo: function(t, e) {
                    return (t % e + e) % e
                },
                mapLinear: function(t, e, r, i, n) {
                    return i + (t - e) * (n - i) / (r - e)
                },
                smoothstep: function(t, e, r) {
                    return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e),
                    t * t * (3 - 2 * t))
                },
                smootherstep: function(t, e, r) {
                    return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e),
                    t * t * t * (t * (6 * t - 15) + 10))
                },
                random16: function() {
                    return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."),
                    Math.random()
                },
                randInt: function(t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function(t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function(t) {
                    return t * (.5 - Math.random())
                },
                degToRad: function(e) {
                    return e * t.Math.DEG2RAD
                },
                radToDeg: function(e) {
                    return e * t.Math.RAD2DEG
                },
                isPowerOfTwo: function(t) {
                    return 0 === (t & t - 1) && 0 !== t
                },
                nearestPowerOfTwo: function(t) {
                    return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
                },
                nextPowerOfTwo: function(t) {
                    return t--,
                    t |= t >> 1,
                    t |= t >> 2,
                    t |= t >> 4,
                    t |= t >> 8,
                    t |= t >> 16,
                    t++,
                    t
                }
            },
            r.prototype = {
                constructor: r,
                isVector2: !0,
                get width() {
                    return this.x
                },
                set width(t) {
                    this.x = t
                },
                get height() {
                    return this.y
                },
                set height(t) {
                    this.y = t
                },
                set: function(t, e) {
                    return this.x = t,
                    this.y = e,
                    this
                },
                setScalar: function(t) {
                    return this.x = t,
                    this.y = t,
                    this
                },
                setX: function(t) {
                    return this.x = t,
                    this
                },
                setY: function(t) {
                    return this.y = t,
                    this
                },
                setComponent: function(t, e) {
                    switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                    }
                },
                getComponent: function(t) {
                    switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x,this.y)
                },
                copy: function(t) {
                    return this.x = t.x,
                    this.y = t.y,
                    this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                    this.addVectors(t, e)) : (this.x += t.x,
                    this.y += t.y,
                    this)
                },
                addScalar: function(t) {
                    return this.x += t,
                    this.y += t,
                    this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x,
                    this.y = t.y + e.y,
                    this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e,
                    this.y += t.y * e,
                    this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                    this.subVectors(t, e)) : (this.x -= t.x,
                    this.y -= t.y,
                    this)
                },
                subScalar: function(t) {
                    return this.x -= t,
                    this.y -= t,
                    this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x,
                    this.y = t.y - e.y,
                    this
                },
                multiply: function(t) {
                    return this.x *= t.x,
                    this.y *= t.y,
                    this
                },
                multiplyScalar: function(t) {
                    return isFinite(t) ? (this.x *= t,
                    this.y *= t) : (this.x = 0,
                    this.y = 0),
                    this
                },
                divide: function(t) {
                    return this.x /= t.x,
                    this.y /= t.y,
                    this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x),
                    this.y = Math.min(this.y, t.y),
                    this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x),
                    this.y = Math.max(this.y, t.y),
                    this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                    this.y = Math.max(t.y, Math.min(e.y, this.y)),
                    this
                },
                clampScalar: function() {
                    var t, e;
                    return function(i, n) {
                        return void 0 === t && (t = new r,
                        e = new r),
                        t.set(i, i),
                        e.set(n, n),
                        this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var r = this.length();
                    return this.multiplyScalar(Math.max(t, Math.min(e, r)) / r)
                },
                floor: function() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this
                },
                round: function() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                    this
                },
                negate: function() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                angle: function() {
                    var t = Math.atan2(this.y, this.x);
                    return t < 0 && (t += 2 * Math.PI),
                    t
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x
                      , r = this.y - t.y;
                    return e * e + r * r
                },
                distanceToManhattan: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                },
                setLength: function(t) {
                    return this.multiplyScalar(t / this.length())
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e,
                    this.y += (t.y - this.y) * e,
                    this
                },
                lerpVectors: function(t, e, r) {
                    return this.subVectors(e, t).multiplyScalar(r).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0),
                    this.x = t[e],
                    this.y = t[e + 1],
                    this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    t[e] = this.x,
                    t[e + 1] = this.y,
                    t
                },
                fromAttribute: function(t, e, r) {
                    return void 0 === r && (r = 0),
                    e = e * t.itemSize + r,
                    this.x = t.array[e],
                    this.y = t.array[e + 1],
                    this
                },
                rotateAround: function(t, e) {
                    var r = Math.cos(e)
                      , i = Math.sin(e)
                      , n = this.x - t.x
                      , o = this.y - t.y;
                    return this.x = n * r - o * i + t.x,
                    this.y = n * i + o * r + t.y,
                    this
                }
            },
            i.DEFAULT_IMAGE = void 0,
            i.DEFAULT_MAPPING = uo,
            i.prototype = {
                constructor: i,
                isTexture: !0,
                set needsUpdate(t) {
                    t === !0 && this.version++
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.image = t.image,
                    this.mipmaps = t.mipmaps.slice(0),
                    this.mapping = t.mapping,
                    this.wrapS = t.wrapS,
                    this.wrapT = t.wrapT,
                    this.magFilter = t.magFilter,
                    this.minFilter = t.minFilter,
                    this.anisotropy = t.anisotropy,
                    this.format = t.format,
                    this.type = t.type,
                    this.offset.copy(t.offset),
                    this.repeat.copy(t.repeat),
                    this.generateMipmaps = t.generateMipmaps,
                    this.premultiplyAlpha = t.premultiplyAlpha,
                    this.flipY = t.flipY,
                    this.unpackAlignment = t.unpackAlignment,
                    this.encoding = t.encoding,
                    this
                },
                toJSON: function(e) {
                    function r(t) {
                        var e;
                        return void 0 !== t.toDataURL ? e = t : (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                        e.width = t.width,
                        e.height = t.height,
                        e.getContext("2d").drawImage(t, 0, 0, t.width, t.height)),
                        e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }
                    if (void 0 !== e.textures[this.uuid])
                        return e.textures[this.uuid];
                    var i = {
                        metadata: {
                            version: 4.4,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        wrap: [this.wrapS, this.wrapT],
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY
                    };
                    if (void 0 !== this.image) {
                        var n = this.image;
                        void 0 === n.uuid && (n.uuid = t.Math.generateUUID()),
                        void 0 === e.images[n.uuid] && (e.images[n.uuid] = {
                            uuid: n.uuid,
                            url: r(n)
                        }),
                        i.image = n.uuid
                    }
                    return e.textures[this.uuid] = i,
                    i
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (this.mapping === uo) {
                        if (t.multiply(this.repeat),
                        t.add(this.offset),
                        t.x < 0 || t.x > 1)
                            switch (this.wrapS) {
                            case bo:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case wo:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case _o:
                                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                            }
                        if (t.y < 0 || t.y > 1)
                            switch (this.wrapT) {
                            case bo:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case wo:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case _o:
                                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                            }
                        this.flipY && (t.y = 1 - t.y)
                    }
                }
            },
            Object.assign(i.prototype, e.prototype);
            var Ta = 0;
            o.prototype = {
                constructor: o,
                isMatrix4: !0,
                set: function(t, e, r, i, n, o, a, s, h, c, l, u, p, d, f, m) {
                    var g = this.elements;
                    return g[0] = t,
                    g[4] = e,
                    g[8] = r,
                    g[12] = i,
                    g[1] = n,
                    g[5] = o,
                    g[9] = a,
                    g[13] = s,
                    g[2] = h,
                    g[6] = c,
                    g[10] = l,
                    g[14] = u,
                    g[3] = p,
                    g[7] = d,
                    g[11] = f,
                    g[15] = m,
                    this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                },
                clone: function() {
                    return (new o).fromArray(this.elements)
                },
                copy: function(t) {
                    return this.elements.set(t.elements),
                    this
                },
                copyPosition: function(t) {
                    var e = this.elements
                      , r = t.elements;
                    return e[12] = r[12],
                    e[13] = r[13],
                    e[14] = r[14],
                    this
                },
                extractBasis: function(t, e, r) {
                    return t.setFromMatrixColumn(this, 0),
                    e.setFromMatrixColumn(this, 1),
                    r.setFromMatrixColumn(this, 2),
                    this
                },
                makeBasis: function(t, e, r) {
                    return this.set(t.x, e.x, r.x, 0, t.y, e.y, r.y, 0, t.z, e.z, r.z, 0, 0, 0, 0, 1),
                    this
                },
                extractRotation: function() {
                    var t;
                    return function(e) {
                        void 0 === t && (t = new s);
                        var r = this.elements
                          , i = e.elements
                          , n = 1 / t.setFromMatrixColumn(e, 0).length()
                          , o = 1 / t.setFromMatrixColumn(e, 1).length()
                          , a = 1 / t.setFromMatrixColumn(e, 2).length();
                        return r[0] = i[0] * n,
                        r[1] = i[1] * n,
                        r[2] = i[2] * n,
                        r[4] = i[4] * o,
                        r[5] = i[5] * o,
                        r[6] = i[6] * o,
                        r[8] = i[8] * a,
                        r[9] = i[9] * a,
                        r[10] = i[10] * a,
                        this
                    }
                }(),
                makeRotationFromEuler: function(t) {
                    (t && t.isEuler) === !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var e = this.elements
                      , r = t.x
                      , i = t.y
                      , n = t.z
                      , o = Math.cos(r)
                      , a = Math.sin(r)
                      , s = Math.cos(i)
                      , h = Math.sin(i)
                      , c = Math.cos(n)
                      , l = Math.sin(n);
                    if ("XYZ" === t.order) {
                        var u = o * c
                          , p = o * l
                          , d = a * c
                          , f = a * l;
                        e[0] = s * c,
                        e[4] = -s * l,
                        e[8] = h,
                        e[1] = p + d * h,
                        e[5] = u - f * h,
                        e[9] = -a * s,
                        e[2] = f - u * h,
                        e[6] = d + p * h,
                        e[10] = o * s
                    } else if ("YXZ" === t.order) {
                        var m = s * c
                          , g = s * l
                          , v = h * c
                          , y = h * l;
                        e[0] = m + y * a,
                        e[4] = v * a - g,
                        e[8] = o * h,
                        e[1] = o * l,
                        e[5] = o * c,
                        e[9] = -a,
                        e[2] = g * a - v,
                        e[6] = y + m * a,
                        e[10] = o * s
                    } else if ("ZXY" === t.order) {
                        var m = s * c
                          , g = s * l
                          , v = h * c
                          , y = h * l;
                        e[0] = m - y * a,
                        e[4] = -o * l,
                        e[8] = v + g * a,
                        e[1] = g + v * a,
                        e[5] = o * c,
                        e[9] = y - m * a,
                        e[2] = -o * h,
                        e[6] = a,
                        e[10] = o * s
                    } else if ("ZYX" === t.order) {
                        var u = o * c
                          , p = o * l
                          , d = a * c
                          , f = a * l;
                        e[0] = s * c,
                        e[4] = d * h - p,
                        e[8] = u * h + f,
                        e[1] = s * l,
                        e[5] = f * h + u,
                        e[9] = p * h - d,
                        e[2] = -h,
                        e[6] = a * s,
                        e[10] = o * s
                    } else if ("YZX" === t.order) {
                        var x = o * s
                          , b = o * h
                          , w = a * s
                          , _ = a * h;
                        e[0] = s * c,
                        e[4] = _ - x * l,
                        e[8] = w * l + b,
                        e[1] = l,
                        e[5] = o * c,
                        e[9] = -a * c,
                        e[2] = -h * c,
                        e[6] = b * l + w,
                        e[10] = x - _ * l
                    } else if ("XZY" === t.order) {
                        var x = o * s
                          , b = o * h
                          , w = a * s
                          , _ = a * h;
                        e[0] = s * c,
                        e[4] = -l,
                        e[8] = h * c,
                        e[1] = x * l + _,
                        e[5] = o * c,
                        e[9] = b * l - w,
                        e[2] = w * l - b,
                        e[6] = a * c,
                        e[10] = _ * l + x
                    }
                    return e[3] = 0,
                    e[7] = 0,
                    e[11] = 0,
                    e[12] = 0,
                    e[13] = 0,
                    e[14] = 0,
                    e[15] = 1,
                    this
                },
                makeRotationFromQuaternion: function(t) {
                    var e = this.elements
                      , r = t.x
                      , i = t.y
                      , n = t.z
                      , o = t.w
                      , a = r + r
                      , s = i + i
                      , h = n + n
                      , c = r * a
                      , l = r * s
                      , u = r * h
                      , p = i * s
                      , d = i * h
                      , f = n * h
                      , m = o * a
                      , g = o * s
                      , v = o * h;
                    return e[0] = 1 - (p + f),
                    e[4] = l - v,
                    e[8] = u + g,
                    e[1] = l + v,
                    e[5] = 1 - (c + f),
                    e[9] = d - m,
                    e[2] = u - g,
                    e[6] = d + m,
                    e[10] = 1 - (c + p),
                    e[3] = 0,
                    e[7] = 0,
                    e[11] = 0,
                    e[12] = 0,
                    e[13] = 0,
                    e[14] = 0,
                    e[15] = 1,
                    this
                },
                lookAt: function() {
                    var t, e, r;
                    return function(i, n, o) {
                        void 0 === t && (t = new s,
                        e = new s,
                        r = new s);
                        var a = this.elements;
                        return r.subVectors(i, n).normalize(),
                        0 === r.lengthSq() && (r.z = 1),
                        t.crossVectors(o, r).normalize(),
                        0 === t.lengthSq() && (r.z += 1e-4,
                        t.crossVectors(o, r).normalize()),
                        e.crossVectors(r, t),
                        a[0] = t.x,
                        a[4] = e.x,
                        a[8] = r.x,
                        a[1] = t.y,
                        a[5] = e.y,
                        a[9] = r.y,
                        a[2] = t.z,
                        a[6] = e.z,
                        a[10] = r.z,
                        this
                    }
                }(),
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                    this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var r = t.elements
                      , i = e.elements
                      , n = this.elements
                      , o = r[0]
                      , a = r[4]
                      , s = r[8]
                      , h = r[12]
                      , c = r[1]
                      , l = r[5]
                      , u = r[9]
                      , p = r[13]
                      , d = r[2]
                      , f = r[6]
                      , m = r[10]
                      , g = r[14]
                      , v = r[3]
                      , y = r[7]
                      , x = r[11]
                      , b = r[15]
                      , w = i[0]
                      , _ = i[4]
                      , M = i[8]
                      , S = i[12]
                      , E = i[1]
                      , T = i[5]
                      , A = i[9]
                      , L = i[13]
                      , C = i[2]
                      , R = i[6]
                      , P = i[10]
                      , U = i[14]
                      , I = i[3]
                      , D = i[7]
                      , O = i[11]
                      , N = i[15];
                    return n[0] = o * w + a * E + s * C + h * I,
                    n[4] = o * _ + a * T + s * R + h * D,
                    n[8] = o * M + a * A + s * P + h * O,
                    n[12] = o * S + a * L + s * U + h * N,
                    n[1] = c * w + l * E + u * C + p * I,
                    n[5] = c * _ + l * T + u * R + p * D,
                    n[9] = c * M + l * A + u * P + p * O,
                    n[13] = c * S + l * L + u * U + p * N,
                    n[2] = d * w + f * E + m * C + g * I,
                    n[6] = d * _ + f * T + m * R + g * D,
                    n[10] = d * M + f * A + m * P + g * O,
                    n[14] = d * S + f * L + m * U + g * N,
                    n[3] = v * w + y * E + x * C + b * I,
                    n[7] = v * _ + y * T + x * R + b * D,
                    n[11] = v * M + y * A + x * P + b * O,
                    n[15] = v * S + y * L + x * U + b * N,
                    this
                },
                multiplyToArray: function(t, e, r) {
                    var i = this.elements;
                    return this.multiplyMatrices(t, e),
                    r[0] = i[0],
                    r[1] = i[1],
                    r[2] = i[2],
                    r[3] = i[3],
                    r[4] = i[4],
                    r[5] = i[5],
                    r[6] = i[6],
                    r[7] = i[7],
                    r[8] = i[8],
                    r[9] = i[9],
                    r[10] = i[10],
                    r[11] = i[11],
                    r[12] = i[12],
                    r[13] = i[13],
                    r[14] = i[14],
                    r[15] = i[15],
                    this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t,
                    e[4] *= t,
                    e[8] *= t,
                    e[12] *= t,
                    e[1] *= t,
                    e[5] *= t,
                    e[9] *= t,
                    e[13] *= t,
                    e[2] *= t,
                    e[6] *= t,
                    e[10] *= t,
                    e[14] *= t,
                    e[3] *= t,
                    e[7] *= t,
                    e[11] *= t,
                    e[15] *= t,
                    this
                },
                applyToVector3Array: function() {
                    var t;
                    return function(e, r, i) {
                        void 0 === t && (t = new s),
                        void 0 === r && (r = 0),
                        void 0 === i && (i = e.length);
                        for (var n = 0, o = r; n < i; n += 3,
                        o += 3)
                            t.fromArray(e, o),
                            t.applyMatrix4(this),
                            t.toArray(e, o);
                        return e
                    }
                }(),
                applyToBuffer: function() {
                    var t;
                    return function(e, r, i) {
                        void 0 === t && (t = new s),
                        void 0 === r && (r = 0),
                        void 0 === i && (i = e.length / e.itemSize);
                        for (var n = 0, o = r; n < i; n++,
                        o++)
                            t.x = e.getX(o),
                            t.y = e.getY(o),
                            t.z = e.getZ(o),
                            t.applyMatrix4(this),
                            e.setXYZ(t.x, t.y, t.z);
                        return e
                    }
                }(),
                determinant: function() {
                    var t = this.elements
                      , e = t[0]
                      , r = t[4]
                      , i = t[8]
                      , n = t[12]
                      , o = t[1]
                      , a = t[5]
                      , s = t[9]
                      , h = t[13]
                      , c = t[2]
                      , l = t[6]
                      , u = t[10]
                      , p = t[14]
                      , d = t[3]
                      , f = t[7]
                      , m = t[11]
                      , g = t[15];
                    return d * (+n * s * l - i * h * l - n * a * u + r * h * u + i * a * p - r * s * p) + f * (+e * s * p - e * h * u + n * o * u - i * o * p + i * h * c - n * s * c) + m * (+e * h * l - e * a * p - n * o * l + r * o * p + n * a * c - r * h * c) + g * (-i * a * c - e * s * l + e * a * u + i * o * l - r * o * u + r * s * c)
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1],
                    e[1] = e[4],
                    e[4] = t,
                    t = e[2],
                    e[2] = e[8],
                    e[8] = t,
                    t = e[6],
                    e[6] = e[9],
                    e[9] = t,
                    t = e[3],
                    e[3] = e[12],
                    e[12] = t,
                    t = e[7],
                    e[7] = e[13],
                    e[13] = t,
                    t = e[11],
                    e[11] = e[14],
                    e[14] = t,
                    this
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."),
                    this.toArray(t, e)
                },
                getPosition: function() {
                    var t;
                    return function() {
                        return void 0 === t && (t = new s),
                        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
                        t.setFromMatrixColumn(this, 3)
                    }
                }(),
                setPosition: function(t) {
                    var e = this.elements;
                    return e[12] = t.x,
                    e[13] = t.y,
                    e[14] = t.z,
                    this
                },
                getInverse: function(t, e) {
                    var r = this.elements
                      , i = t.elements
                      , n = i[0]
                      , o = i[1]
                      , a = i[2]
                      , s = i[3]
                      , h = i[4]
                      , c = i[5]
                      , l = i[6]
                      , u = i[7]
                      , p = i[8]
                      , d = i[9]
                      , f = i[10]
                      , m = i[11]
                      , g = i[12]
                      , v = i[13]
                      , y = i[14]
                      , x = i[15]
                      , b = d * y * u - v * f * u + v * l * m - c * y * m - d * l * x + c * f * x
                      , w = g * f * u - p * y * u - g * l * m + h * y * m + p * l * x - h * f * x
                      , _ = p * v * u - g * d * u + g * c * m - h * v * m - p * c * x + h * d * x
                      , M = g * d * l - p * v * l - g * c * f + h * v * f + p * c * y - h * d * y
                      , S = n * b + o * w + a * _ + s * M;
                    if (0 === S) {
                        var E = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                        if (e === !0)
                            throw new Error(E);
                        return console.warn(E),
                        this.identity()
                    }
                    var T = 1 / S;
                    return r[0] = b * T,
                    r[1] = (v * f * s - d * y * s - v * a * m + o * y * m + d * a * x - o * f * x) * T,
                    r[2] = (c * y * s - v * l * s + v * a * u - o * y * u - c * a * x + o * l * x) * T,
                    r[3] = (d * l * s - c * f * s - d * a * u + o * f * u + c * a * m - o * l * m) * T,
                    r[4] = w * T,
                    r[5] = (p * y * s - g * f * s + g * a * m - n * y * m - p * a * x + n * f * x) * T,
                    r[6] = (g * l * s - h * y * s - g * a * u + n * y * u + h * a * x - n * l * x) * T,
                    r[7] = (h * f * s - p * l * s + p * a * u - n * f * u - h * a * m + n * l * m) * T,
                    r[8] = _ * T,
                    r[9] = (g * d * s - p * v * s - g * o * m + n * v * m + p * o * x - n * d * x) * T,
                    r[10] = (h * v * s - g * c * s + g * o * u - n * v * u - h * o * x + n * c * x) * T,
                    r[11] = (p * c * s - h * d * s - p * o * u + n * d * u + h * o * m - n * c * m) * T,
                    r[12] = M * T,
                    r[13] = (p * v * a - g * d * a + g * o * f - n * v * f - p * o * y + n * d * y) * T,
                    r[14] = (g * c * a - h * v * a - g * o * l + n * v * l + h * o * y - n * c * y) * T,
                    r[15] = (h * d * a - p * c * a + p * o * l - n * d * l - h * o * f + n * c * f) * T,
                    this
                },
                scale: function(t) {
                    var e = this.elements
                      , r = t.x
                      , i = t.y
                      , n = t.z;
                    return e[0] *= r,
                    e[4] *= i,
                    e[8] *= n,
                    e[1] *= r,
                    e[5] *= i,
                    e[9] *= n,
                    e[2] *= r,
                    e[6] *= i,
                    e[10] *= n,
                    e[3] *= r,
                    e[7] *= i,
                    e[11] *= n,
                    this
                },
                getMaxScaleOnAxis: function() {
                    var t = this.elements
                      , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                      , r = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                      , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, r, i))
                },
                makeTranslation: function(t, e, r) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, r, 0, 0, 0, 1),
                    this
                },
                makeRotationX: function(t) {
                    var e = Math.cos(t)
                      , r = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -r, 0, 0, r, e, 0, 0, 0, 0, 1),
                    this
                },
                makeRotationY: function(t) {
                    var e = Math.cos(t)
                      , r = Math.sin(t);
                    return this.set(e, 0, r, 0, 0, 1, 0, 0, -r, 0, e, 0, 0, 0, 0, 1),
                    this
                },
                makeRotationZ: function(t) {
                    var e = Math.cos(t)
                      , r = Math.sin(t);
                    return this.set(e, -r, 0, 0, r, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                },
                makeRotationAxis: function(t, e) {
                    var r = Math.cos(e)
                      , i = Math.sin(e)
                      , n = 1 - r
                      , o = t.x
                      , a = t.y
                      , s = t.z
                      , h = n * o
                      , c = n * a;
                    return this.set(h * o + r, h * a - i * s, h * s + i * a, 0, h * a + i * s, c * a + r, c * s - i * o, 0, h * s - i * a, c * s + i * o, n * s * s + r, 0, 0, 0, 0, 1),
                    this
                },
                makeScale: function(t, e, r) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
                    this
                },
                compose: function(t, e, r) {
                    return this.makeRotationFromQuaternion(e),
                    this.scale(r),
                    this.setPosition(t),
                    this
                },
                decompose: function() {
                    var t, e;
                    return function(r, i, n) {
                        void 0 === t && (t = new s,
                        e = new o);
                        var a = this.elements
                          , h = t.set(a[0], a[1], a[2]).length()
                          , c = t.set(a[4], a[5], a[6]).length()
                          , l = t.set(a[8], a[9], a[10]).length()
                          , u = this.determinant();
                        u < 0 && (h = -h),
                        r.x = a[12],
                        r.y = a[13],
                        r.z = a[14],
                        e.elements.set(this.elements);
                        var p = 1 / h
                          , d = 1 / c
                          , f = 1 / l;
                        return e.elements[0] *= p,
                        e.elements[1] *= p,
                        e.elements[2] *= p,
                        e.elements[4] *= d,
                        e.elements[5] *= d,
                        e.elements[6] *= d,
                        e.elements[8] *= f,
                        e.elements[9] *= f,
                        e.elements[10] *= f,
                        i.setFromRotationMatrix(e),
                        n.x = h,
                        n.y = c,
                        n.z = l,
                        this
                    }
                }(),
                makeFrustum: function(t, e, r, i, n, o) {
                    var a = this.elements
                      , s = 2 * n / (e - t)
                      , h = 2 * n / (i - r)
                      , c = (e + t) / (e - t)
                      , l = (i + r) / (i - r)
                      , u = -(o + n) / (o - n)
                      , p = -2 * o * n / (o - n);
                    return a[0] = s,
                    a[4] = 0,
                    a[8] = c,
                    a[12] = 0,
                    a[1] = 0,
                    a[5] = h,
                    a[9] = l,
                    a[13] = 0,
                    a[2] = 0,
                    a[6] = 0,
                    a[10] = u,
                    a[14] = p,
                    a[3] = 0,
                    a[7] = 0,
                    a[11] = -1,
                    a[15] = 0,
                    this
                },
                makePerspective: function(e, r, i, n) {
                    var o = i * Math.tan(t.Math.DEG2RAD * e * .5)
                      , a = -o
                      , s = a * r
                      , h = o * r;
                    return this.makeFrustum(s, h, a, o, i, n)
                },
                makeOrthographic: function(t, e, r, i, n, o) {
                    var a = this.elements
                      , s = 1 / (e - t)
                      , h = 1 / (r - i)
                      , c = 1 / (o - n)
                      , l = (e + t) * s
                      , u = (r + i) * h
                      , p = (o + n) * c;
                    return a[0] = 2 * s,
                    a[4] = 0,
                    a[8] = 0,
                    a[12] = -l,
                    a[1] = 0,
                    a[5] = 2 * h,
                    a[9] = 0,
                    a[13] = -u,
                    a[2] = 0,
                    a[6] = 0,
                    a[10] = -2 * c,
                    a[14] = -p,
                    a[3] = 0,
                    a[7] = 0,
                    a[11] = 0,
                    a[15] = 1,
                    this
                },
                equals: function(t) {
                    for (var e = this.elements, r = t.elements, i = 0; i < 16; i++)
                        if (e[i] !== r[i])
                            return !1;
                    return !0
                },
                fromArray: function(t) {
                    return this.elements.set(t),
                    this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []),
                    void 0 === e && (e = 0);
                    var r = this.elements;
                    return t[e] = r[0],
                    t[e + 1] = r[1],
                    t[e + 2] = r[2],
                    t[e + 3] = r[3],
                    t[e + 4] = r[4],
                    t[e + 5] = r[5],
                    t[e + 6] = r[6],
                    t[e + 7] = r[7],
                    t[e + 8] = r[8],
                    t[e + 9] = r[9],
                    t[e + 10] = r[10],
                    t[e + 11] = r[11],
                    t[e + 12] = r[12],
                    t[e + 13] = r[13],
                    t[e + 14] = r[14],
                    t[e + 15] = r[15],
                    t
                }
            },
            a.prototype = {
                constructor: a,
                get x() {
                    return this._x
                },
                set x(t) {
                    this._x = t,
                    this.onChangeCallback()
                },
                get y() {
                    return this._y
                },
                set y(t) {
                    this._y = t,
                    this.onChangeCallback()
                },
                get z() {
                    return this._z
                },
                set z(t) {
                    this._z = t,
                    this.onChangeCallback()
                },
                get w() {
                    return this._w
                },
                set w(t) {
                    this._w = t,
                    this.onChangeCallback()
                },
                set: function(t, e, r, i) {
                    return this._x = t,
                    this._y = e,
                    this._z = r,
                    this._w = i,
                    this.onChangeCallback(),
                    this
                },
                clone: function() {
                    return new this.constructor(this._x,this._y,this._z,this._w)
                },
                copy: function(t) {
                    return this._x = t.x,
                    this._y = t.y,
                    this._z = t.z,
                    this._w = t.w,
                    this.onChangeCallback(),
                    this
                },
                setFromEuler: function(t, e) {
                    if ((t && t.isEuler) === !1)
                        throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var r = Math.cos(t._x / 2)
                      , i = Math.cos(t._y / 2)
                      , n = Math.cos(t._z / 2)
                      , o = Math.sin(t._x / 2)
                      , a = Math.sin(t._y / 2)
                      , s = Math.sin(t._z / 2)
                      , h = t.order;
                    return "XYZ" === h ? (this._x = o * i * n + r * a * s,
                    this._y = r * a * n - o * i * s,
                    this._z = r * i * s + o * a * n,
                    this._w = r * i * n - o * a * s) : "YXZ" === h ? (this._x = o * i * n + r * a * s,
                    this._y = r * a * n - o * i * s,
                    this._z = r * i * s - o * a * n,
                    this._w = r * i * n + o * a * s) : "ZXY" === h ? (this._x = o * i * n - r * a * s,
                    this._y = r * a * n + o * i * s,
                    this._z = r * i * s + o * a * n,
                    this._w = r * i * n - o * a * s) : "ZYX" === h ? (this._x = o * i * n - r * a * s,
                    this._y = r * a * n + o * i * s,
                    this._z = r * i * s - o * a * n,
                    this._w = r * i * n + o * a * s) : "YZX" === h ? (this._x = o * i * n + r * a * s,
                    this._y = r * a * n + o * i * s,
                    this._z = r * i * s - o * a * n,
                    this._w = r * i * n - o * a * s) : "XZY" === h && (this._x = o * i * n - r * a * s,
                    this._y = r * a * n - o * i * s,
                    this._z = r * i * s + o * a * n,
                    this._w = r * i * n + o * a * s),
                    e !== !1 && this.onChangeCallback(),
                    this
                },
                setFromAxisAngle: function(t, e) {
                    var r = e / 2
                      , i = Math.sin(r);
                    return this._x = t.x * i,
                    this._y = t.y * i,
                    this._z = t.z * i,
                    this._w = Math.cos(r),
                    this.onChangeCallback(),
                    this
                },
                setFromRotationMatrix: function(t) {
                    var e, r = t.elements, i = r[0], n = r[4], o = r[8], a = r[1], s = r[5], h = r[9], c = r[2], l = r[6], u = r[10], p = i + s + u;
                    return p > 0 ? (e = .5 / Math.sqrt(p + 1),
                    this._w = .25 / e,
                    this._x = (l - h) * e,
                    this._y = (o - c) * e,
                    this._z = (a - n) * e) : i > s && i > u ? (e = 2 * Math.sqrt(1 + i - s - u),
                    this._w = (l - h) / e,
                    this._x = .25 * e,
                    this._y = (n + a) / e,
                    this._z = (o + c) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - i - u),
                    this._w = (o - c) / e,
                    this._x = (n + a) / e,
                    this._y = .25 * e,
                    this._z = (h + l) / e) : (e = 2 * Math.sqrt(1 + u - i - s),
                    this._w = (a - n) / e,
                    this._x = (o + c) / e,
                    this._y = (h + l) / e,
                    this._z = .25 * e),
                    this.onChangeCallback(),
                    this
                },
                setFromUnitVectors: function() {
                    var t, e, r = 1e-6;
                    return function(i, n) {
                        return void 0 === t && (t = new s),
                        e = i.dot(n) + 1,
                        e < r ? (e = 0,
                        Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, n),
                        this._x = t.x,
                        this._y = t.y,
                        this._z = t.z,
                        this._w = e,
                        this.normalize()
                    }
                }(),
                inverse: function() {
                    return this.conjugate().normalize()
                },
                conjugate: function() {
                    return this._x *= -1,
                    this._y *= -1,
                    this._z *= -1,
                    this.onChangeCallback(),
                    this
                },
                dot: function(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var t = this.length();
                    return 0 === t ? (this._x = 0,
                    this._y = 0,
                    this._z = 0,
                    this._w = 1) : (t = 1 / t,
                    this._x = this._x * t,
                    this._y = this._y * t,
                    this._z = this._z * t,
                    this._w = this._w * t),
                    this.onChangeCallback(),
                    this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                    this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyQuaternions(t, this)
                },
                multiplyQuaternions: function(t, e) {
                    var r = t._x
                      , i = t._y
                      , n = t._z
                      , o = t._w
                      , a = e._x
                      , s = e._y
                      , h = e._z
                      , c = e._w;
                    return this._x = r * c + o * a + i * h - n * s,
                    this._y = i * c + o * s + n * a - r * h,
                    this._z = n * c + o * h + r * s - i * a,
                    this._w = o * c - r * a - i * s - n * h,
                    this.onChangeCallback(),
                    this
                },
                slerp: function(t, e) {
                    if (0 === e)
                        return this;
                    if (1 === e)
                        return this.copy(t);
                    var r = this._x
                      , i = this._y
                      , n = this._z
                      , o = this._w
                      , a = o * t._w + r * t._x + i * t._y + n * t._z;
                    if (a < 0 ? (this._w = -t._w,
                    this._x = -t._x,
                    this._y = -t._y,
                    this._z = -t._z,
                    a = -a) : this.copy(t),
                    a >= 1)
                        return this._w = o,
                        this._x = r,
                        this._y = i,
                        this._z = n,
                        this;
                    var s = Math.sqrt(1 - a * a);
                    if (Math.abs(s) < .001)
                        return this._w = .5 * (o + this._w),
                        this._x = .5 * (r + this._x),
                        this._y = .5 * (i + this._y),
                        this._z = .5 * (n + this._z),
                        this;
                    var h = Math.atan2(s, a)
                      , c = Math.sin((1 - e) * h) / s
                      , l = Math.sin(e * h) / s;
                    return this._w = o * c + this._w * l,
                    this._x = r * c + this._x * l,
                    this._y = i * c + this._y * l,
                    this._z = n * c + this._z * l,
                    this.onChangeCallback(),
                    this
                },
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0),
                    this._x = t[e],
                    this._y = t[e + 1],
                    this._z = t[e + 2],
                    this._w = t[e + 3],
                    this.onChangeCallback(),
                    this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    t[e] = this._x,
                    t[e + 1] = this._y,
                    t[e + 2] = this._z,
                    t[e + 3] = this._w,
                    t
                },
                onChange: function(t) {
                    return this.onChangeCallback = t,
                    this
                },
                onChangeCallback: function() {}
            },
            Object.assign(a, {
                slerp: function(t, e, r, i) {
                    return r.copy(t).slerp(e, i)
                },
                slerpFlat: function(t, e, r, i, n, o, a) {
                    var s = r[i + 0]
                      , h = r[i + 1]
                      , c = r[i + 2]
                      , l = r[i + 3]
                      , u = n[o + 0]
                      , p = n[o + 1]
                      , d = n[o + 2]
                      , f = n[o + 3];
                    if (l !== f || s !== u || h !== p || c !== d) {
                        var m = 1 - a
                          , g = s * u + h * p + c * d + l * f
                          , v = g >= 0 ? 1 : -1
                          , y = 1 - g * g;
                        if (y > Number.EPSILON) {
                            var x = Math.sqrt(y)
                              , b = Math.atan2(x, g * v);
                            m = Math.sin(m * b) / x,
                            a = Math.sin(a * b) / x
                        }
                        var w = a * v;
                        if (s = s * m + u * w,
                        h = h * m + p * w,
                        c = c * m + d * w,
                        l = l * m + f * w,
                        m === 1 - a) {
                            var _ = 1 / Math.sqrt(s * s + h * h + c * c + l * l);
                            s *= _,
                            h *= _,
                            c *= _,
                            l *= _
                        }
                    }
                    t[e] = s,
                    t[e + 1] = h,
                    t[e + 2] = c,
                    t[e + 3] = l
                }
            }),
            s.prototype = {
                constructor: s,
                isVector3: !0,
                set: function(t, e, r) {
                    return this.x = t,
                    this.y = e,
                    this.z = r,
                    this
                },
                setScalar: function(t) {
                    return this.x = t,
                    this.y = t,
                    this.z = t,
                    this
                },
                setX: function(t) {
                    return this.x = t,
                    this
                },
                setY: function(t) {
                    return this.y = t,
                    this
                },
                setZ: function(t) {
                    return this.z = t,
                    this
                },
                setComponent: function(t, e) {
                    switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                    }
                },
                getComponent: function(t) {
                    switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x,this.y,this.z)
                },
                copy: function(t) {
                    return this.x = t.x,
                    this.y = t.y,
                    this.z = t.z,
                    this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                    this.addVectors(t, e)) : (this.x += t.x,
                    this.y += t.y,
                    this.z += t.z,
                    this)
                },
                addScalar: function(t) {
                    return this.x += t,
                    this.y += t,
                    this.z += t,
                    this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x,
                    this.y = t.y + e.y,
                    this.z = t.z + e.z,
                    this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e,
                    this.y += t.y * e,
                    this.z += t.z * e,
                    this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                    this.subVectors(t, e)) : (this.x -= t.x,
                    this.y -= t.y,
                    this.z -= t.z,
                    this)
                },
                subScalar: function(t) {
                    return this.x -= t,
                    this.y -= t,
                    this.z -= t,
                    this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x,
                    this.y = t.y - e.y,
                    this.z = t.z - e.z,
                    this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                    this.multiplyVectors(t, e)) : (this.x *= t.x,
                    this.y *= t.y,
                    this.z *= t.z,
                    this)
                },
                multiplyScalar: function(t) {
                    return isFinite(t) ? (this.x *= t,
                    this.y *= t,
                    this.z *= t) : (this.x = 0,
                    this.y = 0,
                    this.z = 0),
                    this
                },
                multiplyVectors: function(t, e) {
                    return this.x = t.x * e.x,
                    this.y = t.y * e.y,
                    this.z = t.z * e.z,
                    this
                },
                applyEuler: function() {
                    var t;
                    return function(e) {
                        return (e && e.isEuler) === !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                        void 0 === t && (t = new a),
                        this.applyQuaternion(t.setFromEuler(e))
                    }
                }(),
                applyAxisAngle: function() {
                    var t;
                    return function(e, r) {
                        return void 0 === t && (t = new a),
                        this.applyQuaternion(t.setFromAxisAngle(e, r))
                    }
                }(),
                applyMatrix3: function(t) {
                    var e = this.x
                      , r = this.y
                      , i = this.z
                      , n = t.elements;
                    return this.x = n[0] * e + n[3] * r + n[6] * i,
                    this.y = n[1] * e + n[4] * r + n[7] * i,
                    this.z = n[2] * e + n[5] * r + n[8] * i,
                    this
                },
                applyMatrix4: function(t) {
                    var e = this.x
                      , r = this.y
                      , i = this.z
                      , n = t.elements;
                    return this.x = n[0] * e + n[4] * r + n[8] * i + n[12],
                    this.y = n[1] * e + n[5] * r + n[9] * i + n[13],
                    this.z = n[2] * e + n[6] * r + n[10] * i + n[14],
                    this
                },
                applyProjection: function(t) {
                    var e = this.x
                      , r = this.y
                      , i = this.z
                      , n = t.elements
                      , o = 1 / (n[3] * e + n[7] * r + n[11] * i + n[15]);
                    return this.x = (n[0] * e + n[4] * r + n[8] * i + n[12]) * o,
                    this.y = (n[1] * e + n[5] * r + n[9] * i + n[13]) * o,
                    this.z = (n[2] * e + n[6] * r + n[10] * i + n[14]) * o,
                    this
                },
                applyQuaternion: function(t) {
                    var e = this.x
                      , r = this.y
                      , i = this.z
                      , n = t.x
                      , o = t.y
                      , a = t.z
                      , s = t.w
                      , h = s * e + o * i - a * r
                      , c = s * r + a * e - n * i
                      , l = s * i + n * r - o * e
                      , u = -n * e - o * r - a * i;
                    return this.x = h * s + u * -n + c * -a - l * -o,
                    this.y = c * s + u * -o + l * -n - h * -a,
                    this.z = l * s + u * -a + h * -o - c * -n,
                    this
                },
                project: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new o),
                        t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)),
                        this.applyProjection(t)
                    }
                }(),
                unproject: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new o),
                        t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)),
                        this.applyProjection(t)
                    }
                }(),
                transformDirection: function(t) {
                    var e = this.x
                      , r = this.y
                      , i = this.z
                      , n = t.elements;
                    return this.x = n[0] * e + n[4] * r + n[8] * i,
                    this.y = n[1] * e + n[5] * r + n[9] * i,
                    this.z = n[2] * e + n[6] * r + n[10] * i,
                    this.normalize()
                },
                divide: function(t) {
                    return this.x /= t.x,
                    this.y /= t.y,
                    this.z /= t.z,
                    this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x),
                    this.y = Math.min(this.y, t.y),
                    this.z = Math.min(this.z, t.z),
                    this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x),
                    this.y = Math.max(this.y, t.y),
                    this.z = Math.max(this.z, t.z),
                    this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                    this.y = Math.max(t.y, Math.min(e.y, this.y)),
                    this.z = Math.max(t.z, Math.min(e.z, this.z)),
                    this
                },
                clampScalar: function() {
                    var t, e;
                    return function(r, i) {
                        return void 0 === t && (t = new s,
                        e = new s),
                        t.set(r, r, r),
                        e.set(i, i, i),
                        this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var r = this.length();
                    return this.multiplyScalar(Math.max(t, Math.min(e, r)) / r)
                },
                floor: function() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this.z = Math.floor(this.z),
                    this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this.z = Math.ceil(this.z),
                    this
                },
                round: function() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this.z = Math.round(this.z),
                    this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                    this
                },
                negate: function() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(t) {
                    return this.multiplyScalar(t / this.length())
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e,
                    this.y += (t.y - this.y) * e,
                    this.z += (t.z - this.z) * e,
                    this
                },
                lerpVectors: function(t, e, r) {
                    return this.subVectors(e, t).multiplyScalar(r).add(t)
                },
                cross: function(t, e) {
                    if (void 0 !== e)
                        return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                        this.crossVectors(t, e);
                    var r = this.x
                      , i = this.y
                      , n = this.z;
                    return this.x = i * t.z - n * t.y,
                    this.y = n * t.x - r * t.z,
                    this.z = r * t.y - i * t.x,
                    this
                },
                crossVectors: function(t, e) {
                    var r = t.x
                      , i = t.y
                      , n = t.z
                      , o = e.x
                      , a = e.y
                      , s = e.z;
                    return this.x = i * s - n * a,
                    this.y = n * o - r * s,
                    this.z = r * a - i * o,
                    this
                },
                projectOnVector: function(t) {
                    var e = t.dot(this) / t.lengthSq();
                    return this.copy(t).multiplyScalar(e)
                },
                projectOnPlane: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new s),
                        t.copy(this).projectOnVector(e),
                        this.sub(t)
                    }
                }(),
                reflect: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new s),
                        this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                    }
                }(),
                angleTo: function(e) {
                    var r = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
                    return Math.acos(t.Math.clamp(r, -1, 1))
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x
                      , r = this.y - t.y
                      , i = this.z - t.z;
                    return e * e + r * r + i * i
                },
                distanceToManhattan: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                },
                setFromSpherical: function(t) {
                    var e = Math.sin(t.phi) * t.radius;
                    return this.x = e * Math.sin(t.theta),
                    this.y = Math.cos(t.phi) * t.radius,
                    this.z = e * Math.cos(t.theta),
                    this
                },
                setFromMatrixPosition: function(t) {
                    return this.setFromMatrixColumn(t, 3)
                },
                setFromMatrixScale: function(t) {
                    var e = this.setFromMatrixColumn(t, 0).length()
                      , r = this.setFromMatrixColumn(t, 1).length()
                      , i = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e,
                    this.y = r,
                    this.z = i,
                    this
                },
                setFromMatrixColumn: function(t, e) {
                    if ("number" == typeof t) {
                        console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
                        var r = t;
                        t = e,
                        e = r
                    }
                    return this.fromArray(t.elements, 4 * e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0),
                    this.x = t[e],
                    this.y = t[e + 1],
                    this.z = t[e + 2],
                    this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    t[e] = this.x,
                    t[e + 1] = this.y,
                    t[e + 2] = this.z,
                    t
                },
                fromAttribute: function(t, e, r) {
                    return void 0 === r && (r = 0),
                    e = e * t.itemSize + r,
                    this.x = t.array[e],
                    this.y = t.array[e + 1],
                    this.z = t.array[e + 2],
                    this
                }
            },
            c.prototype = {
                constructor: c,
                set: function(t, e) {
                    return this.min.copy(t),
                    this.max.copy(e),
                    this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, r = t.length; e < r; e++)
                        this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var t = new r;
                    return function(e, r) {
                        var i = t.copy(r).multiplyScalar(.5);
                        return this.min.copy(e).sub(i),
                        this.max.copy(e).add(i),
                        this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min),
                    this.max.copy(t.max),
                    this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = +(1 / 0),
                    this.max.x = this.max.y = -(1 / 0),
                    this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                center: function(t) {
                    var e = t || new r;
                    return e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                size: function(t) {
                    var e = t || new r;
                    return e.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t),
                    this.max.max(t),
                    this
                },
                expandByVector: function(t) {
                    return this.min.sub(t),
                    this.max.add(t),
                    this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t),
                    this.max.addScalar(t),
                    this
                },
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                },
                getParameter: function(t, e) {
                    var i = e || new r;
                    return i.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                },
                clampPoint: function(t, e) {
                    var i = e || new r;
                    return i.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var t = new r;
                    return function(e) {
                        var r = t.copy(e).clamp(this.min, this.max);
                        return r.sub(e).length()
                    }
                }(),
                intersect: function(t) {
                    return this.min.max(t.min),
                    this.max.min(t.max),
                    this
                },
                union: function(t) {
                    return this.min.min(t.min),
                    this.max.max(t.max),
                    this
                },
                translate: function(t) {
                    return this.min.add(t),
                    this.max.add(t),
                    this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            },
            u.prototype = Object.create(i.prototype),
            u.prototype.constructor = u,
            u.prototype.isCubeTexture = !0,
            Object.defineProperty(u.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            });
            var Aa = new i
              , La = new u
              , Ca = []
              , Ra = [];
            G.prototype.setValue = function(t, e) {
                for (var r = this.seq, i = 0, n = r.length; i !== n; ++i) {
                    var o = r[i];
                    o.setValue(t, e[o.id])
                }
            }
            ;
            var Pa = /([\w\d_]+)(\])?(\[|\.)?/g;
            W.prototype.setValue = function(t, e, r) {
                var i = this.map[e];
                void 0 !== i && i.setValue(t, r, this.renderer)
            }
            ,
            W.prototype.set = function(t, e, r) {
                var i = this.map[r];
                void 0 !== i && i.setValue(t, e[r], this.renderer)
            }
            ,
            W.prototype.setOptional = function(t, e, r) {
                var i = e[r];
                void 0 !== i && this.setValue(t, r, i)
            }
            ,
            W.upload = function(t, e, r, i) {
                for (var n = 0, o = e.length; n !== o; ++n) {
                    var a = e[n]
                      , s = r[a.id];
                    s.needsUpdate !== !1 && a.setValue(t, s.value, i)
                }
            }
            ,
            W.seqWithValue = function(t, e) {
                for (var r = [], i = 0, n = t.length; i !== n; ++i) {
                    var o = t[i];
                    o.id in e && r.push(o)
                }
                return r
            }
            ,
            W.splitDynamic = function(t, e) {
                for (var r = null, i = t.length, n = 0, o = 0; o !== i; ++o) {
                    var a = t[o]
                      , s = e[a.id];
                    s && s.dynamic === !0 ? (null === r && (r = []),
                    r.push(a)) : (n < o && (t[n] = a),
                    ++n)
                }
                return n < i && (t.length = n),
                r
            }
            ,
            W.evalDynamic = function(t, e, r, i) {
                for (var n = 0, o = t.length; n !== o; ++n) {
                    var a = e[t[n].id]
                      , s = a.onUpdateCallback;
                    void 0 !== s && s.call(a, r, i)
                }
            }
            ,
            Y.prototype = {
                constructor: Y,
                isVector4: !0,
                set: function(t, e, r, i) {
                    return this.x = t,
                    this.y = e,
                    this.z = r,
                    this.w = i,
                    this
                },
                setScalar: function(t) {
                    return this.x = t,
                    this.y = t,
                    this.z = t,
                    this.w = t,
                    this
                },
                setX: function(t) {
                    return this.x = t,
                    this
                },
                setY: function(t) {
                    return this.y = t,
                    this
                },
                setZ: function(t) {
                    return this.z = t,
                    this
                },
                setW: function(t) {
                    return this.w = t,
                    this
                },
                setComponent: function(t, e) {
                    switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                    }
                },
                getComponent: function(t) {
                    switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x,this.y,this.z,this.w)
                },
                copy: function(t) {
                    return this.x = t.x,
                    this.y = t.y,
                    this.z = t.z,
                    this.w = void 0 !== t.w ? t.w : 1,
                    this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                    this.addVectors(t, e)) : (this.x += t.x,
                    this.y += t.y,
                    this.z += t.z,
                    this.w += t.w,
                    this)
                },
                addScalar: function(t) {
                    return this.x += t,
                    this.y += t,
                    this.z += t,
                    this.w += t,
                    this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x,
                    this.y = t.y + e.y,
                    this.z = t.z + e.z,
                    this.w = t.w + e.w,
                    this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e,
                    this.y += t.y * e,
                    this.z += t.z * e,
                    this.w += t.w * e,
                    this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                    this.subVectors(t, e)) : (this.x -= t.x,
                    this.y -= t.y,
                    this.z -= t.z,
                    this.w -= t.w,
                    this)
                },
                subScalar: function(t) {
                    return this.x -= t,
                    this.y -= t,
                    this.z -= t,
                    this.w -= t,
                    this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x,
                    this.y = t.y - e.y,
                    this.z = t.z - e.z,
                    this.w = t.w - e.w,
                    this
                },
                multiplyScalar: function(t) {
                    return isFinite(t) ? (this.x *= t,
                    this.y *= t,
                    this.z *= t,
                    this.w *= t) : (this.x = 0,
                    this.y = 0,
                    this.z = 0,
                    this.w = 0),
                    this
                },
                applyMatrix4: function(t) {
                    var e = this.x
                      , r = this.y
                      , i = this.z
                      , n = this.w
                      , o = t.elements;
                    return this.x = o[0] * e + o[4] * r + o[8] * i + o[12] * n,
                    this.y = o[1] * e + o[5] * r + o[9] * i + o[13] * n,
                    this.z = o[2] * e + o[6] * r + o[10] * i + o[14] * n,
                    this.w = o[3] * e + o[7] * r + o[11] * i + o[15] * n,
                    this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                setAxisAngleFromQuaternion: function(t) {
                    this.w = 2 * Math.acos(t.w);
                    var e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1,
                    this.y = 0,
                    this.z = 0) : (this.x = t.x / e,
                    this.y = t.y / e,
                    this.z = t.z / e),
                    this
                },
                setAxisAngleFromRotationMatrix: function(t) {
                    var e, r, i, n, o = .01, a = .1, s = t.elements, h = s[0], c = s[4], l = s[8], u = s[1], p = s[5], d = s[9], f = s[2], m = s[6], g = s[10];
                    if (Math.abs(c - u) < o && Math.abs(l - f) < o && Math.abs(d - m) < o) {
                        if (Math.abs(c + u) < a && Math.abs(l + f) < a && Math.abs(d + m) < a && Math.abs(h + p + g - 3) < a)
                            return this.set(1, 0, 0, 0),
                            this;
                        e = Math.PI;
                        var v = (h + 1) / 2
                          , y = (p + 1) / 2
                          , x = (g + 1) / 2
                          , b = (c + u) / 4
                          , w = (l + f) / 4
                          , _ = (d + m) / 4;
                        return v > y && v > x ? v < o ? (r = 0,
                        i = .707106781,
                        n = .707106781) : (r = Math.sqrt(v),
                        i = b / r,
                        n = w / r) : y > x ? y < o ? (r = .707106781,
                        i = 0,
                        n = .707106781) : (i = Math.sqrt(y),
                        r = b / i,
                        n = _ / i) : x < o ? (r = .707106781,
                        i = .707106781,
                        n = 0) : (n = Math.sqrt(x),
                        r = w / n,
                        i = _ / n),
                        this.set(r, i, n, e),
                        this
                    }
                    var M = Math.sqrt((m - d) * (m - d) + (l - f) * (l - f) + (u - c) * (u - c));
                    return Math.abs(M) < .001 && (M = 1),
                    this.x = (m - d) / M,
                    this.y = (l - f) / M,
                    this.z = (u - c) / M,
                    this.w = Math.acos((h + p + g - 1) / 2),
                    this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x),
                    this.y = Math.min(this.y, t.y),
                    this.z = Math.min(this.z, t.z),
                    this.w = Math.min(this.w, t.w),
                    this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x),
                    this.y = Math.max(this.y, t.y),
                    this.z = Math.max(this.z, t.z),
                    this.w = Math.max(this.w, t.w),
                    this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                    this.y = Math.max(t.y, Math.min(e.y, this.y)),
                    this.z = Math.max(t.z, Math.min(e.z, this.z)),
                    this.w = Math.max(t.w, Math.min(e.w, this.w)),
                    this
                },
                clampScalar: function() {
                    var t, e;
                    return function(r, i) {
                        return void 0 === t && (t = new Y,
                        e = new Y),
                        t.set(r, r, r, r),
                        e.set(i, i, i, i),
                        this.clamp(t, e)
                    }
                }(),
                floor: function() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this.z = Math.floor(this.z),
                    this.w = Math.floor(this.w),
                    this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this.z = Math.ceil(this.z),
                    this.w = Math.ceil(this.w),
                    this
                },
                round: function() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this.z = Math.round(this.z),
                    this.w = Math.round(this.w),
                    this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                    this
                },
                negate: function() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this.w = -this.w,
                    this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(t) {
                    return this.multiplyScalar(t / this.length())
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e,
                    this.y += (t.y - this.y) * e,
                    this.z += (t.z - this.z) * e,
                    this.w += (t.w - this.w) * e,
                    this
                },
                lerpVectors: function(t, e, r) {
                    return this.subVectors(e, t).multiplyScalar(r).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0),
                    this.x = t[e],
                    this.y = t[e + 1],
                    this.z = t[e + 2],
                    this.w = t[e + 3],
                    this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    t[e] = this.x,
                    t[e + 1] = this.y,
                    t[e + 2] = this.z,
                    t[e + 3] = this.w,
                    t
                },
                fromAttribute: function(t, e, r) {
                    return void 0 === r && (r = 0),
                    e = e * t.itemSize + r,
                    this.x = t.array[e],
                    this.y = t.array[e + 1],
                    this.z = t.array[e + 2],
                    this.w = t.array[e + 3],
                    this
                }
            },
            Object.assign(Z.prototype, e.prototype, {
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t,
                    this.height = e,
                    this.dispose()),
                    this.viewport.set(0, 0, t, e),
                    this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width,
                    this.height = t.height,
                    this.viewport.copy(t.viewport),
                    this.texture = t.texture.clone(),
                    this.depthBuffer = t.depthBuffer,
                    this.stencilBuffer = t.stencilBuffer,
                    this.depthTexture = t.depthTexture,
                    this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }),
            Q.prototype = {
                constructor: Q,
                isMaterial: !0,
                get needsUpdate() {
                    return this._needsUpdate
                },
                set needsUpdate(t) {
                    t === !0 && this.update(),
                    this._needsUpdate = t
                },
                setValues: function(t) {
                    if (void 0 !== t)
                        for (var e in t) {
                            var r = t[e];
                            if (void 0 !== r) {
                                var i = this[e];
                                void 0 !== i ? i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : "overdraw" === e ? this[e] = Number(r) : this[e] = r : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                            } else
                                console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                        }
                },
                toJSON: function(t) {
                    function e(t) {
                        var e = [];
                        for (var r in t) {
                            var i = t[r];
                            delete i.metadata,
                            e.push(i)
                        }
                        return e
                    }
                    var r = void 0 === t;
                    r && (t = {
                        textures: {},
                        images: {}
                    });
                    var i = {
                        metadata: {
                            version: 4.4,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    if (i.uuid = this.uuid,
                    i.type = this.type,
                    "" !== this.name && (i.name = this.name),
                    this.color && this.color.isColor && (i.color = this.color.getHex()),
                    void 0 !== this.roughness && (i.roughness = this.roughness),
                    void 0 !== this.metalness && (i.metalness = this.metalness),
                    this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
                    this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
                    void 0 !== this.shininess && (i.shininess = this.shininess),
                    this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
                    this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid),
                    this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid),
                    this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid,
                    i.bumpScale = this.bumpScale),
                    this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid,
                    i.normalScale = this.normalScale.toArray()),
                    this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid,
                    i.displacementScale = this.displacementScale,
                    i.displacementBias = this.displacementBias),
                    this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                    this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                    this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                    this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid),
                    this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid,
                    i.reflectivity = this.reflectivity),
                    void 0 !== this.size && (i.size = this.size),
                    void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
                    this.blending !== Ln && (i.blending = this.blending),
                    this.shading !== Mn && (i.shading = this.shading),
                    this.side !== xn && (i.side = this.side),
                    this.vertexColors !== Sn && (i.vertexColors = this.vertexColors),
                    this.opacity < 1 && (i.opacity = this.opacity),
                    this.transparent === !0 && (i.transparent = this.transparent),
                    i.depthFunc = this.depthFunc,
                    i.depthTest = this.depthTest,
                    i.depthWrite = this.depthWrite,
                    this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
                    this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha),
                    this.wireframe === !0 && (i.wireframe = this.wireframe),
                    this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
                    "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
                    "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
                    i.skinning = this.skinning,
                    i.morphTargets = this.morphTargets,
                    r) {
                        var n = e(t.textures)
                          , o = e(t.images);
                        n.length > 0 && (i.textures = n),
                        o.length > 0 && (i.images = o)
                    }
                    return i
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name,
                    this.fog = t.fog,
                    this.lights = t.lights,
                    this.blending = t.blending,
                    this.side = t.side,
                    this.shading = t.shading,
                    this.vertexColors = t.vertexColors,
                    this.opacity = t.opacity,
                    this.transparent = t.transparent,
                    this.blendSrc = t.blendSrc,
                    this.blendDst = t.blendDst,
                    this.blendEquation = t.blendEquation,
                    this.blendSrcAlpha = t.blendSrcAlpha,
                    this.blendDstAlpha = t.blendDstAlpha,
                    this.blendEquationAlpha = t.blendEquationAlpha,
                    this.depthFunc = t.depthFunc,
                    this.depthTest = t.depthTest,
                    this.depthWrite = t.depthWrite,
                    this.colorWrite = t.colorWrite,
                    this.precision = t.precision,
                    this.polygonOffset = t.polygonOffset,
                    this.polygonOffsetFactor = t.polygonOffsetFactor,
                    this.polygonOffsetUnits = t.polygonOffsetUnits,
                    this.alphaTest = t.alphaTest,
                    this.premultipliedAlpha = t.premultipliedAlpha,
                    this.overdraw = t.overdraw,
                    this.visible = t.visible,
                    this.clipShadows = t.clipShadows;
                    var e = t.clippingPlanes
                      , r = null;
                    if (null !== e) {
                        var i = e.length;
                        r = new Array(i);
                        for (var n = 0; n !== i; ++n)
                            r[n] = e[n].clone()
                    }
                    return this.clippingPlanes = r,
                    this
                },
                update: function() {
                    this.dispatchEvent({
                        type: "update"
                    })
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            },
            Object.assign(Q.prototype, e.prototype);
            var Ua = 0;
            t.UniformsUtils = {
                merge: function(t) {
                    for (var e = {}, r = 0; r < t.length; r++) {
                        var i = this.clone(t[r]);
                        for (var n in i)
                            e[n] = i[n]
                    }
                    return e
                },
                clone: function(t) {
                    var e = {};
                    for (var r in t) {
                        e[r] = {};
                        for (var i in t[r]) {
                            var n = t[r][i];
                            n && n.isColor || n && n.isVector2 || n && n.isVector3 || n && n.isVector4 || n && n.isMatrix3 || n && n.isMatrix4 || n && n.isTexture ? e[r][i] = n.clone() : Array.isArray(n) ? e[r][i] = n.slice() : e[r][i] = n
                        }
                    }
                    return e
                }
            },
            K.prototype = Object.create(Q.prototype),
            K.prototype.constructor = K,
            K.prototype.isShaderMaterial = !0,
            K.prototype.copy = function(e) {
                return Q.prototype.copy.call(this, e),
                this.fragmentShader = e.fragmentShader,
                this.vertexShader = e.vertexShader,
                this.uniforms = t.UniformsUtils.clone(e.uniforms),
                this.defines = e.defines,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.lights = e.lights,
                this.clipping = e.clipping,
                this.skinning = e.skinning,
                this.morphTargets = e.morphTargets,
                this.morphNormals = e.morphNormals,
                this.extensions = e.extensions,
                this
            }
            ,
            K.prototype.toJSON = function(t) {
                var e = Q.prototype.toJSON.call(this, t);
                return e.uniforms = this.uniforms,
                e.vertexShader = this.vertexShader,
                e.fragmentShader = this.fragmentShader,
                e
            }
            ;
            var Ia = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n"
              , Da = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n"
              , Oa = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n"
              , Na = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n"
              , Ba = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif"
              , Fa = "\nvec3 transformed = vec3( position );\n"
              , ka = "\nvec3 objectNormal = vec3( normal );\n"
              , za = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n"
              , Va = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n"
              , Ga = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n"
              , ja = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n"
              , Ha = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n"
              , Wa = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n"
              , Xa = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif"
              , Ya = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n"
              , qa = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif"
              , Za = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif"
              , Qa = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n"
              , Ja = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n"
              , Ka = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n"
              , $a = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n"
              , ts = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n"
              , es = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n"
              , rs = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n"
              , is = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n"
              , ns = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n"
              , os = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n"
              , as = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n"
              , ss = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n"
              , hs = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n"
              , cs = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n"
              , ls = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif"
              , us = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n"
              , ps = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif"
              , ds = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n"
              , fs = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n"
              , ms = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n"
              , gs = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n"
              , vs = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n"
              , ys = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n"
              , xs = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n"
              , bs = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif"
              , ws = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n"
              , _s = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif"
              , Ms = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n"
              , Ss = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n"
              , Es = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n"
              , Ts = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n"
              , As = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n"
              , Ls = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n"
              , Cs = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif"
              , Rs = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n"
              , Ps = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif"
              , Us = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n"
              , Is = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n"
              , Ds = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n"
              , Os = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n"
              , Ns = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n"
              , Bs = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n"
              , Fs = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n"
              , ks = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n"
              , zs = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif"
              , Vs = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n"
              , Gs = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n"
              , js = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n"
              , Hs = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n"
              , Ws = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif"
              , Xs = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n"
              , Ys = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n"
              , qs = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n"
              , Zs = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif"
              , Qs = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif"
              , Js = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n"
              , Ks = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n"
              , $s = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif"
              , th = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n"
              , eh = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif"
              , rh = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif"
              , ih = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif"
              , nh = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif"
              , oh = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n"
              , ah = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n"
              , sh = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n"
              , hh = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n"
              , ch = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n"
              , lh = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n"
              , uh = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n"
              , ph = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n"
              , dh = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n"
              , fh = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
              , mh = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n"
              , gh = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
              , vh = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n"
              , yh = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
              , xh = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n"
              , bh = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
              , wh = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n"
              , _h = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
              , Mh = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
              , Sh = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n"
              , Eh = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n"
              , Th = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
              , Ah = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
              , Lh = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n"
              , Ch = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
              , Rh = {
                alphamap_fragment: Ia,
                alphamap_pars_fragment: Da,
                alphatest_fragment: Oa,
                aomap_fragment: Na,
                aomap_pars_fragment: Ba,
                begin_vertex: Fa,
                beginnormal_vertex: ka,
                bsdfs: za,
                bumpmap_pars_fragment: Va,
                clipping_planes_fragment: Ga,
                clipping_planes_pars_fragment: ja,
                clipping_planes_pars_vertex: Ha,
                clipping_planes_vertex: Wa,
                color_fragment: Xa,
                color_pars_fragment: Ya,
                color_pars_vertex: qa,
                color_vertex: Za,
                common: Qa,
                cube_uv_reflection_fragment: Ja,
                defaultnormal_vertex: Ka,
                displacementmap_pars_vertex: $a,
                displacementmap_vertex: ts,
                emissivemap_fragment: es,
                emissivemap_pars_fragment: rs,
                encodings_fragment: is,
                encodings_pars_fragment: ns,
                envmap_fragment: os,
                envmap_pars_fragment: as,
                envmap_pars_vertex: ss,
                envmap_vertex: hs,
                fog_fragment: cs,
                fog_pars_fragment: ls,
                lightmap_fragment: us,
                lightmap_pars_fragment: ps,
                lights_lambert_vertex: ds,
                lights_pars: fs,
                lights_phong_fragment: ms,
                lights_phong_pars_fragment: gs,
                lights_physical_fragment: vs,
                lights_physical_pars_fragment: ys,
                lights_template: xs,
                logdepthbuf_fragment: bs,
                logdepthbuf_pars_fragment: ws,
                logdepthbuf_pars_vertex: _s,
                logdepthbuf_vertex: Ms,
                map_fragment: Ss,
                map_pars_fragment: Es,
                map_particle_fragment: Ts,
                map_particle_pars_fragment: As,
                metalnessmap_fragment: Ls,
                metalnessmap_pars_fragment: Cs,
                morphnormal_vertex: Rs,
                morphtarget_pars_vertex: Ps,
                morphtarget_vertex: Us,
                normal_flip: Is,
                normal_fragment: Ds,
                normalmap_pars_fragment: Os,
                packing: Ns,
                premultiplied_alpha_fragment: Bs,
                project_vertex: Fs,
                roughnessmap_fragment: ks,
                roughnessmap_pars_fragment: zs,
                shadowmap_pars_fragment: Vs,
                shadowmap_pars_vertex: Gs,
                shadowmap_vertex: js,
                shadowmask_pars_fragment: Hs,
                skinbase_vertex: Ws,
                skinning_pars_vertex: Xs,
                skinning_vertex: Ys,
                skinnormal_vertex: qs,
                specularmap_fragment: Zs,
                specularmap_pars_fragment: Qs,
                tonemapping_fragment: Js,
                tonemapping_pars_fragment: Ks,
                uv_pars_fragment: $s,
                uv_pars_vertex: th,
                uv_vertex: eh,
                uv2_pars_fragment: rh,
                uv2_pars_vertex: ih,
                uv2_vertex: nh,
                worldpos_vertex: oh,
                cube_frag: ah,
                cube_vert: sh,
                depth_frag: hh,
                depth_vert: ch,
                distanceRGBA_frag: lh,
                distanceRGBA_vert: uh,
                equirect_frag: ph,
                equirect_vert: dh,
                linedashed_frag: fh,
                linedashed_vert: mh,
                meshbasic_frag: gh,
                meshbasic_vert: vh,
                meshlambert_frag: yh,
                meshlambert_vert: xh,
                meshphong_frag: bh,
                meshphong_vert: wh,
                meshphysical_frag: _h,
                meshphysical_vert: Mh,
                normal_frag: Sh,
                normal_vert: Eh,
                points_frag: Th,
                points_vert: Ah,
                shadow_frag: Lh,
                shadow_vert: Ch
            };
            $.prototype = {
                constructor: $,
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
                    this
                },
                setScalar: function(t) {
                    this.r = t,
                    this.g = t,
                    this.b = t
                },
                setHex: function(t) {
                    return t = Math.floor(t),
                    this.r = (t >> 16 & 255) / 255,
                    this.g = (t >> 8 & 255) / 255,
                    this.b = (255 & t) / 255,
                    this
                },
                setRGB: function(t, e, r) {
                    return this.r = t,
                    this.g = e,
                    this.b = r,
                    this
                },
                setHSL: function() {
                    function e(t, e, r) {
                        return r < 0 && (r += 1),
                        r > 1 && (r -= 1),
                        r < 1 / 6 ? t + 6 * (e - t) * r : r < .5 ? e : r < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - r) : t
                    }
                    return function(r, i, n) {
                        if (r = t.Math.euclideanModulo(r, 1),
                        i = t.Math.clamp(i, 0, 1),
                        n = t.Math.clamp(n, 0, 1),
                        0 === i)
                            this.r = this.g = this.b = n;
                        else {
                            var o = n <= .5 ? n * (1 + i) : n + i - n * i
                              , a = 2 * n - o;
                            this.r = e(a, o, r + 1 / 3),
                            this.g = e(a, o, r),
                            this.b = e(a, o, r - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(e) {
                    function r(t) {
                        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    var i;
                    if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                        var n, o = i[1], a = i[2];
                        switch (o) {
                        case "rgb":
                        case "rgba":
                            if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
                                return this.r = Math.min(255, parseInt(n[1], 10)) / 255,
                                this.g = Math.min(255, parseInt(n[2], 10)) / 255,
                                this.b = Math.min(255, parseInt(n[3], 10)) / 255,
                                r(n[5]),
                                this;
                            if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
                                return this.r = Math.min(100, parseInt(n[1], 10)) / 100,
                                this.g = Math.min(100, parseInt(n[2], 10)) / 100,
                                this.b = Math.min(100, parseInt(n[3], 10)) / 100,
                                r(n[5]),
                                this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                var s = parseFloat(n[1]) / 360
                                  , h = parseInt(n[2], 10) / 100
                                  , c = parseInt(n[3], 10) / 100;
                                return r(n[5]),
                                this.setHSL(s, h, c)
                            }
                        }
                    } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                        var l = i[1]
                          , u = l.length;
                        if (3 === u)
                            return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255,
                            this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255,
                            this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255,
                            this;
                        if (6 === u)
                            return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255,
                            this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255,
                            this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255,
                            this
                    }
                    if (e && e.length > 0) {
                        var l = t.ColorKeywords[e];
                        void 0 !== l ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + e)
                    }
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r,this.g,this.b)
                },
                copy: function(t) {
                    return this.r = t.r,
                    this.g = t.g,
                    this.b = t.b,
                    this
                },
                copyGammaToLinear: function(t, e) {
                    return void 0 === e && (e = 2),
                    this.r = Math.pow(t.r, e),
                    this.g = Math.pow(t.g, e),
                    this.b = Math.pow(t.b, e),
                    this
                },
                copyLinearToGamma: function(t, e) {
                    void 0 === e && (e = 2);
                    var r = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, r),
                    this.g = Math.pow(t.g, r),
                    this.b = Math.pow(t.b, r),
                    this
                },
                convertGammaToLinear: function() {
                    var t = this.r
                      , e = this.g
                      , r = this.b;
                    return this.r = t * t,
                    this.g = e * e,
                    this.b = r * r,
                    this
                },
                convertLinearToGamma: function() {
                    return this.r = Math.sqrt(this.r),
                    this.g = Math.sqrt(this.g),
                    this.b = Math.sqrt(this.b),
                    this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(t) {
                    var e, r, i = t || {
                        h: 0,
                        s: 0,
                        l: 0
                    }, n = this.r, o = this.g, a = this.b, s = Math.max(n, o, a), h = Math.min(n, o, a), c = (h + s) / 2;
                    if (h === s)
                        e = 0,
                        r = 0;
                    else {
                        var l = s - h;
                        switch (r = c <= .5 ? l / (s + h) : l / (2 - s - h),
                        s) {
                        case n:
                            e = (o - a) / l + (o < a ? 6 : 0);
                            break;
                        case o:
                            e = (a - n) / l + 2;
                            break;
                        case a:
                            e = (n - o) / l + 4
                        }
                        e /= 6
                    }
                    return i.h = e,
                    i.s = r,
                    i.l = c,
                    i
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function(t, e, r) {
                    var i = this.getHSL();
                    return i.h += t,
                    i.s += e,
                    i.l += r,
                    this.setHSL(i.h, i.s, i.l),
                    this
                },
                add: function(t) {
                    return this.r += t.r,
                    this.g += t.g,
                    this.b += t.b,
                    this
                },
                addColors: function(t, e) {
                    return this.r = t.r + e.r,
                    this.g = t.g + e.g,
                    this.b = t.b + e.b,
                    this
                },
                addScalar: function(t) {
                    return this.r += t,
                    this.g += t,
                    this.b += t,
                    this
                },
                sub: function(t) {
                    return this.r = Math.max(0, this.r - t.r),
                    this.g = Math.max(0, this.g - t.g),
                    this.b = Math.max(0, this.b - t.b),
                    this
                },
                multiply: function(t) {
                    return this.r *= t.r,
                    this.g *= t.g,
                    this.b *= t.b,
                    this
                },
                multiplyScalar: function(t) {
                    return this.r *= t,
                    this.g *= t,
                    this.b *= t,
                    this
                },
                lerp: function(t, e) {
                    return this.r += (t.r - this.r) * e,
                    this.g += (t.g - this.g) * e,
                    this.b += (t.b - this.b) * e,
                    this
                },
                equals: function(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0),
                    this.r = t[e],
                    this.g = t[e + 1],
                    this.b = t[e + 2],
                    this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    t[e] = this.r,
                    t[e + 1] = this.g,
                    t[e + 2] = this.b,
                    t
                },
                toJSON: function() {
                    return this.getHex()
                }
            },
            t.ColorKeywords = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            };
            var Ph = {
                common: {
                    diffuse: {
                        value: new $(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    offsetRepeat: {
                        value: new Y(0,0,1,1)
                    },
                    specularMap: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new r(1,1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new $(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new $(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    offsetRepeat: {
                        value: new Y(0,0,1,1)
                    }
                }
            }
              , Uh = {
                basic: {
                    uniforms: t.UniformsUtils.merge([Ph.common, Ph.aomap, Ph.fog]),
                    vertexShader: Rh.meshbasic_vert,
                    fragmentShader: Rh.meshbasic_frag
                },
                lambert: {
                    uniforms: t.UniformsUtils.merge([Ph.common, Ph.aomap, Ph.lightmap, Ph.emissivemap, Ph.fog, Ph.lights, {
                        emissive: {
                            value: new $(0)
                        }
                    }]),
                    vertexShader: Rh.meshlambert_vert,
                    fragmentShader: Rh.meshlambert_frag
                },
                phong: {
                    uniforms: t.UniformsUtils.merge([Ph.common, Ph.aomap, Ph.lightmap, Ph.emissivemap, Ph.bumpmap, Ph.normalmap, Ph.displacementmap, Ph.fog, Ph.lights, {
                        emissive: {
                            value: new $(0)
                        },
                        specular: {
                            value: new $(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Rh.meshphong_vert,
                    fragmentShader: Rh.meshphong_frag
                },
                standard: {
                    uniforms: t.UniformsUtils.merge([Ph.common, Ph.aomap, Ph.lightmap, Ph.emissivemap, Ph.bumpmap, Ph.normalmap, Ph.displacementmap, Ph.roughnessmap, Ph.metalnessmap, Ph.fog, Ph.lights, {
                        emissive: {
                            value: new $(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Rh.meshphysical_vert,
                    fragmentShader: Rh.meshphysical_frag
                },
                points: {
                    uniforms: t.UniformsUtils.merge([Ph.points, Ph.fog]),
                    vertexShader: Rh.points_vert,
                    fragmentShader: Rh.points_frag
                },
                dashed: {
                    uniforms: t.UniformsUtils.merge([Ph.common, Ph.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: Rh.linedashed_vert,
                    fragmentShader: Rh.linedashed_frag
                },
                depth: {
                    uniforms: t.UniformsUtils.merge([Ph.common, Ph.displacementmap]),
                    vertexShader: Rh.depth_vert,
                    fragmentShader: Rh.depth_frag
                },
                normal: {
                    uniforms: {
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: Rh.normal_vert,
                    fragmentShader: Rh.normal_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: Rh.cube_vert,
                    fragmentShader: Rh.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        }
                    },
                    vertexShader: Rh.equirect_vert,
                    fragmentShader: Rh.equirect_frag
                },
                distanceRGBA: {
                    uniforms: {
                        lightPos: {
                            value: new s
                        }
                    },
                    vertexShader: Rh.distanceRGBA_vert,
                    fragmentShader: Rh.distanceRGBA_frag
                }
            };
            Uh.physical = {
                uniforms: t.UniformsUtils.merge([Uh.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: Rh.meshphysical_vert,
                fragmentShader: Rh.meshphysical_frag
            },
            tt.prototype = Object.create(Q.prototype),
            tt.prototype.constructor = tt,
            tt.prototype.isMeshDepthMaterial = !0,
            tt.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.depthPacking = t.depthPacking,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this
            }
            ,
            et.prototype = {
                constructor: et,
                isBox3: !0,
                set: function(t, e) {
                    return this.min.copy(t),
                    this.max.copy(e),
                    this
                },
                setFromArray: function(t) {
                    for (var e = +(1 / 0), r = +(1 / 0), i = +(1 / 0), n = -(1 / 0), o = -(1 / 0), a = -(1 / 0), s = 0, h = t.length; s < h; s += 3) {
                        var c = t[s]
                          , l = t[s + 1]
                          , u = t[s + 2];
                        c < e && (e = c),
                        l < r && (r = l),
                        u < i && (i = u),
                        c > n && (n = c),
                        l > o && (o = l),
                        u > a && (a = u)
                    }
                    this.min.set(e, r, i),
                    this.max.set(n, o, a)
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, r = t.length; e < r; e++)
                        this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var t = new s;
                    return function(e, r) {
                        var i = t.copy(r).multiplyScalar(.5);
                        return this.min.copy(e).sub(i),
                        this.max.copy(e).add(i),
                        this
                    }
                }(),
                setFromObject: function() {
                    var t = new s;
                    return function(e) {
                        var r = this;
                        return e.updateMatrixWorld(!0),
                        this.makeEmpty(),
                        e.traverse(function(e) {
                            var i = e.geometry;
                            if (void 0 !== i)
                                if (i && i.isGeometry)
                                    for (var n = i.vertices, o = 0, a = n.length; o < a; o++)
                                        t.copy(n[o]),
                                        t.applyMatrix4(e.matrixWorld),
                                        r.expandByPoint(t);
                                else if (i && i.isBufferGeometry) {
                                    var s = i.attributes.position;
                                    if (void 0 !== s) {
                                        var h, c, l;
                                        s && s.isInterleavedBufferAttribute ? (h = s.data.array,
                                        c = s.offset,
                                        l = s.data.stride) : (h = s.array,
                                        c = 0,
                                        l = 3);
                                        for (var o = c, a = h.length; o < a; o += l)
                                            t.fromArray(h, o),
                                            t.applyMatrix4(e.matrixWorld),
                                            r.expandByPoint(t)
                                    }
                                }
                        }),
                        this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min),
                    this.max.copy(t.max),
                    this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = +(1 / 0),
                    this.max.x = this.max.y = this.max.z = -(1 / 0),
                    this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                center: function(t) {
                    var e = t || new s;
                    return e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                size: function(t) {
                    var e = t || new s;
                    return e.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t),
                    this.max.max(t),
                    this
                },
                expandByVector: function(t) {
                    return this.min.sub(t),
                    this.max.add(t),
                    this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t),
                    this.max.addScalar(t),
                    this
                },
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                },
                getParameter: function(t, e) {
                    var r = e || new s;
                    return r.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                },
                intersectsSphere: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new s),
                        this.clampPoint(e.center, t),
                        t.distanceToSquared(e.center) <= e.radius * e.radius
                    }
                }(),
                intersectsPlane: function(t) {
                    var e, r;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                    r = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                    r = t.normal.x * this.min.x),
                    t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                    r += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                    r += t.normal.y * this.min.y),
                    t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                    r += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                    r += t.normal.z * this.min.z),
                    e <= t.constant && r >= t.constant
                },
                clampPoint: function(t, e) {
                    var r = e || new s;
                    return r.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var t = new s;
                    return function(e) {
                        var r = t.copy(e).clamp(this.min, this.max);
                        return r.sub(e).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var t = new s;
                    return function(e) {
                        var r = e || new rt;
                        return r.center = this.center(),
                        r.radius = .5 * this.size(t).length(),
                        r
                    }
                }(),
                intersect: function(t) {
                    return this.min.max(t.min),
                    this.max.min(t.max),
                    this.isEmpty() && this.makeEmpty(),
                    this
                },
                union: function(t) {
                    return this.min.min(t.min),
                    this.max.max(t.max),
                    this
                },
                applyMatrix4: function() {
                    var t = [new s, new s, new s, new s, new s, new s, new s, new s];
                    return function(e) {
                        return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                        t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                        t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                        t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                        t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                        t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                        t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                        t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                        this.setFromPoints(t),
                        this)
                    }
                }(),
                translate: function(t) {
                    return this.min.add(t),
                    this.max.add(t),
                    this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            },
            rt.prototype = {
                constructor: rt,
                set: function(t, e) {
                    return this.center.copy(t),
                    this.radius = e,
                    this
                },
                setFromPoints: function() {
                    var t = new et;
                    return function(e, r) {
                        var i = this.center;
                        void 0 !== r ? i.copy(r) : t.setFromPoints(e).center(i);
                        for (var n = 0, o = 0, a = e.length; o < a; o++)
                            n = Math.max(n, i.distanceToSquared(e[o]));
                        return this.radius = Math.sqrt(n),
                        this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.center.copy(t.center),
                    this.radius = t.radius,
                    this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(t) {
                    return t.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(t) {
                    var e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                },
                intersectsBox: function(t) {
                    return t.intersectsSphere(this)
                },
                intersectsPlane: function(t) {
                    return Math.abs(this.center.dot(t.normal) - t.constant) <= this.radius
                },
                clampPoint: function(t, e) {
                    var r = this.center.distanceToSquared(t)
                      , i = e || new s;
                    return i.copy(t),
                    r > this.radius * this.radius && (i.sub(this.center).normalize(),
                    i.multiplyScalar(this.radius).add(this.center)),
                    i
                },
                getBoundingBox: function(t) {
                    var e = t || new et;
                    return e.set(this.center, this.center),
                    e.expandByScalar(this.radius),
                    e
                },
                applyMatrix4: function(t) {
                    return this.center.applyMatrix4(t),
                    this.radius = this.radius * t.getMaxScaleOnAxis(),
                    this
                },
                translate: function(t) {
                    return this.center.add(t),
                    this
                },
                equals: function(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            },
            it.prototype = {
                constructor: it,
                isMatrix3: !0,
                set: function(t, e, r, i, n, o, a, s, h) {
                    var c = this.elements;
                    return c[0] = t,
                    c[1] = i,
                    c[2] = a,
                    c[3] = e,
                    c[4] = n,
                    c[5] = s,
                    c[6] = r,
                    c[7] = o,
                    c[8] = h,
                    this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                    this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]),
                    this
                },
                setFromMatrix4: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
                    this
                },
                applyToVector3Array: function() {
                    var t;
                    return function(e, r, i) {
                        void 0 === t && (t = new s),
                        void 0 === r && (r = 0),
                        void 0 === i && (i = e.length);
                        for (var n = 0, o = r; n < i; n += 3,
                        o += 3)
                            t.fromArray(e, o),
                            t.applyMatrix3(this),
                            t.toArray(e, o);
                        return e
                    }
                }(),
                applyToBuffer: function() {
                    var t;
                    return function(e, r, i) {
                        void 0 === t && (t = new s),
                        void 0 === r && (r = 0),
                        void 0 === i && (i = e.length / e.itemSize);
                        for (var n = 0, o = r; n < i; n++,
                        o++)
                            t.x = e.getX(o),
                            t.y = e.getY(o),
                            t.z = e.getZ(o),
                            t.applyMatrix3(this),
                            e.setXYZ(t.x, t.y, t.z);
                        return e
                    }
                }(),
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t,
                    e[3] *= t,
                    e[6] *= t,
                    e[1] *= t,
                    e[4] *= t,
                    e[7] *= t,
                    e[2] *= t,
                    e[5] *= t,
                    e[8] *= t,
                    this
                },
                determinant: function() {
                    var t = this.elements
                      , e = t[0]
                      , r = t[1]
                      , i = t[2]
                      , n = t[3]
                      , o = t[4]
                      , a = t[5]
                      , s = t[6]
                      , h = t[7]
                      , c = t[8];
                    return e * o * c - e * a * h - r * n * c + r * a * s + i * n * h - i * o * s
                },
                getInverse: function(t, e) {
                    t && t.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
                    var r = t.elements
                      , i = this.elements
                      , n = r[0]
                      , o = r[1]
                      , a = r[2]
                      , s = r[3]
                      , h = r[4]
                      , c = r[5]
                      , l = r[6]
                      , u = r[7]
                      , p = r[8]
                      , d = p * h - c * u
                      , f = c * l - p * s
                      , m = u * s - h * l
                      , g = n * d + o * f + a * m;
                    if (0 === g) {
                        var v = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                        if (e === !0)
                            throw new Error(v);
                        return console.warn(v),
                        this.identity()
                    }
                    var y = 1 / g;
                    return i[0] = d * y,
                    i[1] = (a * u - p * o) * y,
                    i[2] = (c * o - a * h) * y,
                    i[3] = f * y,
                    i[4] = (p * n - a * l) * y,
                    i[5] = (a * s - c * n) * y,
                    i[6] = m * y,
                    i[7] = (o * l - u * n) * y,
                    i[8] = (h * n - o * s) * y,
                    this
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1],
                    e[1] = e[3],
                    e[3] = t,
                    t = e[2],
                    e[2] = e[6],
                    e[6] = t,
                    t = e[5],
                    e[5] = e[7],
                    e[7] = t,
                    this
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."),
                    this.toArray(t, e)
                },
                getNormalMatrix: function(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                },
                transposeIntoArray: function(t) {
                    var e = this.elements;
                    return t[0] = e[0],
                    t[1] = e[3],
                    t[2] = e[6],
                    t[3] = e[1],
                    t[4] = e[4],
                    t[5] = e[7],
                    t[6] = e[2],
                    t[7] = e[5],
                    t[8] = e[8],
                    this
                },
                fromArray: function(t) {
                    return this.elements.set(t),
                    this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []),
                    void 0 === e && (e = 0);
                    var r = this.elements;
                    return t[e] = r[0],
                    t[e + 1] = r[1],
                    t[e + 2] = r[2],
                    t[e + 3] = r[3],
                    t[e + 4] = r[4],
                    t[e + 5] = r[5],
                    t[e + 6] = r[6],
                    t[e + 7] = r[7],
                    t[e + 8] = r[8],
                    t
                }
            },
            nt.prototype = {
                constructor: nt,
                set: function(t, e) {
                    return this.normal.copy(t),
                    this.constant = e,
                    this
                },
                setComponents: function(t, e, r, i) {
                    return this.normal.set(t, e, r),
                    this.constant = i,
                    this
                },
                setFromNormalAndCoplanarPoint: function(t, e) {
                    return this.normal.copy(t),
                    this.constant = -e.dot(this.normal),
                    this
                },
                setFromCoplanarPoints: function() {
                    var t = new s
                      , e = new s;
                    return function(r, i, n) {
                        var o = t.subVectors(n, i).cross(e.subVectors(r, i)).normalize();
                        return this.setFromNormalAndCoplanarPoint(o, r),
                        this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.normal.copy(t.normal),
                    this.constant = t.constant,
                    this
                },
                normalize: function() {
                    var t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t),
                    this.constant *= t,
                    this
                },
                negate: function() {
                    return this.constant *= -1,
                    this.normal.negate(),
                    this
                },
                distanceToPoint: function(t) {
                    return this.normal.dot(t) + this.constant
                },
                distanceToSphere: function(t) {
                    return this.distanceToPoint(t.center) - t.radius
                },
                projectPoint: function(t, e) {
                    return this.orthoPoint(t, e).sub(t).negate()
                },
                orthoPoint: function(t, e) {
                    var r = this.distanceToPoint(t)
                      , i = e || new s;
                    return i.copy(this.normal).multiplyScalar(r)
                },
                intersectLine: function() {
                    var t = new s;
                    return function(e, r) {
                        var i = r || new s
                          , n = e.delta(t)
                          , o = this.normal.dot(n);
                        if (0 !== o) {
                            var a = -(e.start.dot(this.normal) + this.constant) / o;
                            if (!(a < 0 || a > 1))
                                return i.copy(n).multiplyScalar(a).add(e.start)
                        } else if (0 === this.distanceToPoint(e.start))
                            return i.copy(e.start)
                    }
                }(),
                intersectsLine: function(t) {
                    var e = this.distanceToPoint(t.start)
                      , r = this.distanceToPoint(t.end);
                    return e < 0 && r > 0 || r < 0 && e > 0
                },
                intersectsBox: function(t) {
                    return t.intersectsPlane(this)
                },
                intersectsSphere: function(t) {
                    return t.intersectsPlane(this)
                },
                coplanarPoint: function(t) {
                    var e = t || new s;
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var t = new s
                      , e = new it;
                    return function(r, i) {
                        var n = this.coplanarPoint(t).applyMatrix4(r)
                          , o = i || e.getNormalMatrix(r)
                          , a = this.normal.applyMatrix3(o).normalize();
                        return this.constant = -n.dot(a),
                        this
                    }
                }(),
                translate: function(t) {
                    return this.constant = this.constant - t.dot(this.normal),
                    this
                },
                equals: function(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            },
            ot.prototype = {
                constructor: ot,
                set: function(t, e, r, i, n, o) {
                    var a = this.planes;
                    return a[0].copy(t),
                    a[1].copy(e),
                    a[2].copy(r),
                    a[3].copy(i),
                    a[4].copy(n),
                    a[5].copy(o),
                    this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    for (var e = this.planes, r = 0; r < 6; r++)
                        e[r].copy(t.planes[r]);
                    return this
                },
                setFromMatrix: function(t) {
                    var e = this.planes
                      , r = t.elements
                      , i = r[0]
                      , n = r[1]
                      , o = r[2]
                      , a = r[3]
                      , s = r[4]
                      , h = r[5]
                      , c = r[6]
                      , l = r[7]
                      , u = r[8]
                      , p = r[9]
                      , d = r[10]
                      , f = r[11]
                      , m = r[12]
                      , g = r[13]
                      , v = r[14]
                      , y = r[15];
                    return e[0].setComponents(a - i, l - s, f - u, y - m).normalize(),
                    e[1].setComponents(a + i, l + s, f + u, y + m).normalize(),
                    e[2].setComponents(a + n, l + h, f + p, y + g).normalize(),
                    e[3].setComponents(a - n, l - h, f - p, y - g).normalize(),
                    e[4].setComponents(a - o, l - c, f - d, y - v).normalize(),
                    e[5].setComponents(a + o, l + c, f + d, y + v).normalize(),
                    this
                },
                intersectsObject: function() {
                    var t = new rt;
                    return function(e) {
                        var r = e.geometry;
                        return null === r.boundingSphere && r.computeBoundingSphere(),
                        t.copy(r.boundingSphere).applyMatrix4(e.matrixWorld),
                        this.intersectsSphere(t)
                    }
                }(),
                intersectsSprite: function() {
                    var t = new rt;
                    return function(e) {
                        return t.center.set(0, 0, 0),
                        t.radius = .7071067811865476,
                        t.applyMatrix4(e.matrixWorld),
                        this.intersectsSphere(t)
                    }
                }(),
                intersectsSphere: function(t) {
                    for (var e = this.planes, r = t.center, i = -t.radius, n = 0; n < 6; n++) {
                        var o = e[n].distanceToPoint(r);
                        if (o < i)
                            return !1
                    }
                    return !0
                },
                intersectsBox: function() {
                    var t = new s
                      , e = new s;
                    return function(r) {
                        for (var i = this.planes, n = 0; n < 6; n++) {
                            var o = i[n];
                            t.x = o.normal.x > 0 ? r.min.x : r.max.x,
                            e.x = o.normal.x > 0 ? r.max.x : r.min.x,
                            t.y = o.normal.y > 0 ? r.min.y : r.max.y,
                            e.y = o.normal.y > 0 ? r.max.y : r.min.y,
                            t.z = o.normal.z > 0 ? r.min.z : r.max.z,
                            e.z = o.normal.z > 0 ? r.max.z : r.min.z;
                            var a = o.distanceToPoint(t)
                              , s = o.distanceToPoint(e);
                            if (a < 0 && s < 0)
                                return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function(t) {
                    for (var e = this.planes, r = 0; r < 6; r++)
                        if (e[r].distanceToPoint(t) < 0)
                            return !1;
                    return !0
                }
            };
            var Ih = 0;
            Mt.prototype = {
                constructor: Mt,
                isBufferAttribute: !0,
                get count() {
                    return this.array.length / this.itemSize
                },
                set needsUpdate(t) {
                    t === !0 && this.version++
                },
                setDynamic: function(t) {
                    return this.dynamic = t,
                    this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array),
                    this.itemSize = t.itemSize,
                    this.normalized = t.normalized,
                    this.dynamic = t.dynamic,
                    this
                },
                copyAt: function(t, e, r) {
                    t *= this.itemSize,
                    r *= e.itemSize;
                    for (var i = 0, n = this.itemSize; i < n; i++)
                        this.array[t + i] = e.array[r + i];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t),
                    this
                },
                copyColorsArray: function(t) {
                    for (var e = this.array, r = 0, i = 0, n = t.length; i < n; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                        o = new $),
                        e[r++] = o.r,
                        e[r++] = o.g,
                        e[r++] = o.b
                    }
                    return this
                },
                copyIndicesArray: function(t) {
                    for (var e = this.array, r = 0, i = 0, n = t.length; i < n; i++) {
                        var o = t[i];
                        e[r++] = o.a,
                        e[r++] = o.b,
                        e[r++] = o.c
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
                        var a = t[n];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n),
                        a = new r),
                        e[i++] = a.x,
                        e[i++] = a.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    for (var e = this.array, r = 0, i = 0, n = t.length; i < n; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                        o = new s),
                        e[r++] = o.x,
                        e[r++] = o.y,
                        e[r++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    for (var e = this.array, r = 0, i = 0, n = t.length; i < n; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                        o = new Y),
                        e[r++] = o.x,
                        e[r++] = o.y,
                        e[r++] = o.z,
                        e[r++] = o.w
                    }
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0),
                    this.array.set(t, e),
                    this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e,
                    this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e,
                    this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e,
                    this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e,
                    this
                },
                setXY: function(t, e, r) {
                    return t *= this.itemSize,
                    this.array[t + 0] = e,
                    this.array[t + 1] = r,
                    this
                },
                setXYZ: function(t, e, r, i) {
                    return t *= this.itemSize,
                    this.array[t + 0] = e,
                    this.array[t + 1] = r,
                    this.array[t + 2] = i,
                    this
                },
                setXYZW: function(t, e, r, i, n) {
                    return t *= this.itemSize,
                    this.array[t + 0] = e,
                    this.array[t + 1] = r,
                    this.array[t + 2] = i,
                    this.array[t + 3] = n,
                    this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            },
            Dt.prototype = {
                constructor: Dt,
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.a = t.a,
                    this.b = t.b,
                    this.c = t.c,
                    this.normal.copy(t.normal),
                    this.color.copy(t.color),
                    this.materialIndex = t.materialIndex;
                    for (var e = 0, r = t.vertexNormals.length; e < r; e++)
                        this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (var e = 0, r = t.vertexColors.length; e < r; e++)
                        this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            },
            Ot.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
            Ot.DefaultOrder = "XYZ",
            Ot.prototype = {
                constructor: Ot,
                isEuler: !0,
                get x() {
                    return this._x
                },
                set x(t) {
                    this._x = t,
                    this.onChangeCallback()
                },
                get y() {
                    return this._y
                },
                set y(t) {
                    this._y = t,
                    this.onChangeCallback()
                },
                get z() {
                    return this._z
                },
                set z(t) {
                    this._z = t,
                    this.onChangeCallback()
                },
                get order() {
                    return this._order
                },
                set order(t) {
                    this._order = t,
                    this.onChangeCallback()
                },
                set: function(t, e, r, i) {
                    return this._x = t,
                    this._y = e,
                    this._z = r,
                    this._order = i || this._order,
                    this.onChangeCallback(),
                    this
                },
                clone: function() {
                    return new this.constructor(this._x,this._y,this._z,this._order)
                },
                copy: function(t) {
                    return this._x = t._x,
                    this._y = t._y,
                    this._z = t._z,
                    this._order = t._order,
                    this.onChangeCallback(),
                    this
                },
                setFromRotationMatrix: function(e, r, i) {
                    var n = t.Math.clamp
                      , o = e.elements
                      , a = o[0]
                      , s = o[4]
                      , h = o[8]
                      , c = o[1]
                      , l = o[5]
                      , u = o[9]
                      , p = o[2]
                      , d = o[6]
                      , f = o[10];
                    return r = r || this._order,
                    "XYZ" === r ? (this._y = Math.asin(n(h, -1, 1)),
                    Math.abs(h) < .99999 ? (this._x = Math.atan2(-u, f),
                    this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(d, l),
                    this._z = 0)) : "YXZ" === r ? (this._x = Math.asin(-n(u, -1, 1)),
                    Math.abs(u) < .99999 ? (this._y = Math.atan2(h, f),
                    this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-p, a),
                    this._z = 0)) : "ZXY" === r ? (this._x = Math.asin(n(d, -1, 1)),
                    Math.abs(d) < .99999 ? (this._y = Math.atan2(-p, f),
                    this._z = Math.atan2(-s, l)) : (this._y = 0,
                    this._z = Math.atan2(c, a))) : "ZYX" === r ? (this._y = Math.asin(-n(p, -1, 1)),
                    Math.abs(p) < .99999 ? (this._x = Math.atan2(d, f),
                    this._z = Math.atan2(c, a)) : (this._x = 0,
                    this._z = Math.atan2(-s, l))) : "YZX" === r ? (this._z = Math.asin(n(c, -1, 1)),
                    Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, l),
                    this._y = Math.atan2(-p, a)) : (this._x = 0,
                    this._y = Math.atan2(h, f))) : "XZY" === r ? (this._z = Math.asin(-n(s, -1, 1)),
                    Math.abs(s) < .99999 ? (this._x = Math.atan2(d, l),
                    this._y = Math.atan2(h, a)) : (this._x = Math.atan2(-u, f),
                    this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + r),
                    this._order = r,
                    i !== !1 && this.onChangeCallback(),
                    this
                },
                setFromQuaternion: function() {
                    var t;
                    return function(e, r, i) {
                        return void 0 === t && (t = new o),
                        t.makeRotationFromQuaternion(e),
                        this.setFromRotationMatrix(t, r, i)
                    }
                }(),
                setFromVector3: function(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                },
                reorder: function() {
                    var t = new a;
                    return function(e) {
                        return t.setFromEuler(this),
                        this.setFromQuaternion(t, e)
                    }
                }(),
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                },
                fromArray: function(t) {
                    return this._x = t[0],
                    this._y = t[1],
                    this._z = t[2],
                    void 0 !== t[3] && (this._order = t[3]),
                    this.onChangeCallback(),
                    this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    t[e] = this._x,
                    t[e + 1] = this._y,
                    t[e + 2] = this._z,
                    t[e + 3] = this._order,
                    t
                },
                toVector3: function(t) {
                    return t ? t.set(this._x, this._y, this._z) : new s(this._x,this._y,this._z)
                },
                onChange: function(t) {
                    return this.onChangeCallback = t,
                    this
                },
                onChangeCallback: function() {}
            },
            Nt.prototype = {
                constructor: Nt,
                set: function(t) {
                    this.mask = 1 << t
                },
                enable: function(t) {
                    this.mask |= 1 << t;
                },
                toggle: function(t) {
                    this.mask ^= 1 << t
                },
                disable: function(t) {
                    this.mask &= ~(1 << t)
                },
                test: function(t) {
                    return 0 !== (this.mask & t.mask)
                }
            },
            Bt.DefaultUp = new s(0,1,0),
            Bt.DefaultMatrixAutoUpdate = !0,
            Object.assign(Bt.prototype, e.prototype, {
                isObject3D: !0,
                applyMatrix: function(t) {
                    this.matrix.multiplyMatrices(t, this.matrix),
                    this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function() {
                    var t = new a;
                    return function(e, r) {
                        return t.setFromAxisAngle(e, r),
                        this.quaternion.multiply(t),
                        this
                    }
                }(),
                rotateX: function() {
                    var t = new s(1,0,0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateY: function() {
                    var t = new s(0,1,0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateZ: function() {
                    var t = new s(0,0,1);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                translateOnAxis: function() {
                    var t = new s;
                    return function(e, r) {
                        return t.copy(e).applyQuaternion(this.quaternion),
                        this.position.add(t.multiplyScalar(r)),
                        this
                    }
                }(),
                translateX: function() {
                    var t = new s(1,0,0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateY: function() {
                    var t = new s(0,1,0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateZ: function() {
                    var t = new s(0,0,1);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var t = new o;
                    return function(e) {
                        return e.applyMatrix4(t.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var t = new o;
                    return function(e) {
                        t.lookAt(e, this.position, this.up),
                        this.quaternion.setFromRotationMatrix(t)
                    }
                }(),
                add: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++)
                            this.add(arguments[e]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                    this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
                    t.parent = this,
                    t.dispatchEvent({
                        type: "added"
                    }),
                    this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                    this)
                },
                remove: function(t) {
                    if (arguments.length > 1)
                        for (var e = 0; e < arguments.length; e++)
                            this.remove(arguments[e]);
                    var r = this.children.indexOf(t);
                    r !== -1 && (t.parent = null,
                    t.dispatchEvent({
                        type: "removed"
                    }),
                    this.children.splice(r, 1))
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e)
                        return this;
                    for (var r = 0, i = this.children.length; r < i; r++) {
                        var n = this.children[r]
                          , o = n.getObjectByProperty(t, e);
                        if (void 0 !== o)
                            return o
                    }
                },
                getWorldPosition: function(t) {
                    var e = t || new s;
                    return this.updateMatrixWorld(!0),
                    e.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var t = new s
                      , e = new s;
                    return function(r) {
                        var i = r || new a;
                        return this.updateMatrixWorld(!0),
                        this.matrixWorld.decompose(t, i, e),
                        i
                    }
                }(),
                getWorldRotation: function() {
                    var t = new a;
                    return function(e) {
                        var r = e || new Ot;
                        return this.getWorldQuaternion(t),
                        r.setFromQuaternion(t, this.rotation.order, !1)
                    }
                }(),
                getWorldScale: function() {
                    var t = new s
                      , e = new a;
                    return function(r) {
                        var i = r || new s;
                        return this.updateMatrixWorld(!0),
                        this.matrixWorld.decompose(t, e, i),
                        i
                    }
                }(),
                getWorldDirection: function() {
                    var t = new a;
                    return function(e) {
                        var r = e || new s;
                        return this.getWorldQuaternion(t),
                        r.set(0, 0, 1).applyQuaternion(t)
                    }
                }(),
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    for (var e = this.children, r = 0, i = e.length; r < i; r++)
                        e[r].traverse(t)
                },
                traverseVisible: function(t) {
                    if (this.visible !== !1) {
                        t(this);
                        for (var e = this.children, r = 0, i = e.length; r < i; r++)
                            e[r].traverseVisible(t)
                    }
                },
                traverseAncestors: function(t) {
                    var e = this.parent;
                    null !== e && (t(e),
                    e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale),
                    this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate === !0 && this.updateMatrix(),
                    this.matrixWorldNeedsUpdate !== !0 && t !== !0 || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                    this.matrixWorldNeedsUpdate = !1,
                    t = !0);
                    for (var e = this.children, r = 0, i = e.length; r < i; r++)
                        e[r].updateMatrixWorld(t)
                },
                toJSON: function(t) {
                    function e(t) {
                        var e = [];
                        for (var r in t) {
                            var i = t[r];
                            delete i.metadata,
                            e.push(i)
                        }
                        return e
                    }
                    var r = void 0 === t || "" === t
                      , i = {};
                    r && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {}
                    },
                    i.metadata = {
                        version: 4.4,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var n = {};
                    if (n.uuid = this.uuid,
                    n.type = this.type,
                    "" !== this.name && (n.name = this.name),
                    "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                    this.castShadow === !0 && (n.castShadow = !0),
                    this.receiveShadow === !0 && (n.receiveShadow = !0),
                    this.visible === !1 && (n.visible = !1),
                    n.matrix = this.matrix.toArray(),
                    void 0 !== this.geometry && (void 0 === t.geometries[this.geometry.uuid] && (t.geometries[this.geometry.uuid] = this.geometry.toJSON(t)),
                    n.geometry = this.geometry.uuid),
                    void 0 !== this.material && (void 0 === t.materials[this.material.uuid] && (t.materials[this.material.uuid] = this.material.toJSON(t)),
                    n.material = this.material.uuid),
                    this.children.length > 0) {
                        n.children = [];
                        for (var o = 0; o < this.children.length; o++)
                            n.children.push(this.children[o].toJSON(t).object)
                    }
                    if (r) {
                        var a = e(t.geometries)
                          , s = e(t.materials)
                          , h = e(t.textures)
                          , c = e(t.images);
                        a.length > 0 && (i.geometries = a),
                        s.length > 0 && (i.materials = s),
                        h.length > 0 && (i.textures = h),
                        c.length > 0 && (i.images = c)
                    }
                    return i.object = n,
                    i
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0),
                    this.name = t.name,
                    this.up.copy(t.up),
                    this.position.copy(t.position),
                    this.quaternion.copy(t.quaternion),
                    this.scale.copy(t.scale),
                    this.matrix.copy(t.matrix),
                    this.matrixWorld.copy(t.matrixWorld),
                    this.matrixAutoUpdate = t.matrixAutoUpdate,
                    this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                    this.visible = t.visible,
                    this.castShadow = t.castShadow,
                    this.receiveShadow = t.receiveShadow,
                    this.frustumCulled = t.frustumCulled,
                    this.renderOrder = t.renderOrder,
                    this.userData = JSON.parse(JSON.stringify(t.userData)),
                    e === !0)
                        for (var r = 0; r < t.children.length; r++) {
                            var i = t.children[r];
                            this.add(i.clone())
                        }
                    return this
                }
            });
            var Dh = 0;
            Object.assign(kt.prototype, e.prototype, {
                isGeometry: !0,
                applyMatrix: function(t) {
                    for (var e = (new it).getNormalMatrix(t), r = 0, i = this.vertices.length; r < i; r++) {
                        var n = this.vertices[r];
                        n.applyMatrix4(t)
                    }
                    for (var r = 0, i = this.faces.length; r < i; r++) {
                        var o = this.faces[r];
                        o.normal.applyMatrix3(e).normalize();
                        for (var a = 0, s = o.vertexNormals.length; a < s; a++)
                            o.vertexNormals[a].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(),
                    null !== this.boundingSphere && this.computeBoundingSphere(),
                    this.verticesNeedUpdate = !0,
                    this.normalsNeedUpdate = !0,
                    this
                },
                rotateX: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new o),
                        t.makeRotationX(e),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                rotateY: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new o),
                        t.makeRotationY(e),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                rotateZ: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new o),
                        t.makeRotationZ(e),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                translate: function() {
                    var t;
                    return function(e, r, i) {
                        return void 0 === t && (t = new o),
                        t.makeTranslation(e, r, i),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                scale: function() {
                    var t;
                    return function(e, r, i) {
                        return void 0 === t && (t = new o),
                        t.makeScale(e, r, i),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                lookAt: function() {
                    var t;
                    return function(e) {
                        void 0 === t && (t = new Bt),
                        t.lookAt(e),
                        t.updateMatrix(),
                        this.applyMatrix(t.matrix)
                    }
                }(),
                fromBufferGeometry: function(t) {
                    function e(t, e, r, n) {
                        var o = void 0 !== h ? [p[t].clone(), p[e].clone(), p[r].clone()] : []
                          , a = void 0 !== c ? [i.colors[t].clone(), i.colors[e].clone(), i.colors[r].clone()] : []
                          , s = new Dt(t,e,r,o,a,n);
                        i.faces.push(s),
                        void 0 !== l && i.faceVertexUvs[0].push([d[t].clone(), d[e].clone(), d[r].clone()]),
                        void 0 !== u && i.faceVertexUvs[1].push([f[t].clone(), f[e].clone(), f[r].clone()])
                    }
                    var i = this
                      , n = null !== t.index ? t.index.array : void 0
                      , o = t.attributes
                      , a = o.position.array
                      , h = void 0 !== o.normal ? o.normal.array : void 0
                      , c = void 0 !== o.color ? o.color.array : void 0
                      , l = void 0 !== o.uv ? o.uv.array : void 0
                      , u = void 0 !== o.uv2 ? o.uv2.array : void 0;
                    void 0 !== u && (this.faceVertexUvs[1] = []);
                    for (var p = [], d = [], f = [], m = 0, g = 0; m < a.length; m += 3,
                    g += 2)
                        i.vertices.push(new s(a[m],a[m + 1],a[m + 2])),
                        void 0 !== h && p.push(new s(h[m],h[m + 1],h[m + 2])),
                        void 0 !== c && i.colors.push(new $(c[m],c[m + 1],c[m + 2])),
                        void 0 !== l && d.push(new r(l[g],l[g + 1])),
                        void 0 !== u && f.push(new r(u[g],u[g + 1]));
                    if (void 0 !== n) {
                        var v = t.groups;
                        if (v.length > 0)
                            for (var m = 0; m < v.length; m++)
                                for (var y = v[m], x = y.start, b = y.count, g = x, w = x + b; g < w; g += 3)
                                    e(n[g], n[g + 1], n[g + 2], y.materialIndex);
                        else
                            for (var m = 0; m < n.length; m += 3)
                                e(n[m], n[m + 1], n[m + 2])
                    } else
                        for (var m = 0; m < a.length / 3; m += 3)
                            e(m, m + 1, m + 2);
                    return this.computeFaceNormals(),
                    null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                    null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                    this
                },
                center: function() {
                    this.computeBoundingBox();
                    var t = this.boundingBox.center().negate();
                    return this.translate(t.x, t.y, t.z),
                    t
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    var t = this.boundingSphere.center
                      , e = this.boundingSphere.radius
                      , r = 0 === e ? 1 : 1 / e
                      , i = new o;
                    return i.set(r, 0, 0, -r * t.x, 0, r, 0, -r * t.y, 0, 0, r, -r * t.z, 0, 0, 0, 1),
                    this.applyMatrix(i),
                    this
                },
                computeFaceNormals: function() {
                    for (var t = new s, e = new s, r = 0, i = this.faces.length; r < i; r++) {
                        var n = this.faces[r]
                          , o = this.vertices[n.a]
                          , a = this.vertices[n.b]
                          , h = this.vertices[n.c];
                        t.subVectors(h, a),
                        e.subVectors(o, a),
                        t.cross(e),
                        t.normalize(),
                        n.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    void 0 === t && (t = !0);
                    var e, r, i, n, o, a;
                    for (a = new Array(this.vertices.length),
                    e = 0,
                    r = this.vertices.length; e < r; e++)
                        a[e] = new s;
                    if (t) {
                        var h, c, l, u = new s, p = new s;
                        for (i = 0,
                        n = this.faces.length; i < n; i++)
                            o = this.faces[i],
                            h = this.vertices[o.a],
                            c = this.vertices[o.b],
                            l = this.vertices[o.c],
                            u.subVectors(l, c),
                            p.subVectors(h, c),
                            u.cross(p),
                            a[o.a].add(u),
                            a[o.b].add(u),
                            a[o.c].add(u)
                    } else
                        for (i = 0,
                        n = this.faces.length; i < n; i++)
                            o = this.faces[i],
                            a[o.a].add(o.normal),
                            a[o.b].add(o.normal),
                            a[o.c].add(o.normal);
                    for (e = 0,
                    r = this.vertices.length; e < r; e++)
                        a[e].normalize();
                    for (i = 0,
                    n = this.faces.length; i < n; i++) {
                        o = this.faces[i];
                        var d = o.vertexNormals;
                        3 === d.length ? (d[0].copy(a[o.a]),
                        d[1].copy(a[o.b]),
                        d[2].copy(a[o.c])) : (d[0] = a[o.a].clone(),
                        d[1] = a[o.b].clone(),
                        d[2] = a[o.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var t, e, r, i, n;
                    for (r = 0,
                    i = this.faces.length; r < i; r++)
                        for (n = this.faces[r],
                        n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(),
                        n.__originalVertexNormals || (n.__originalVertexNormals = []),
                        t = 0,
                        e = n.vertexNormals.length; t < e; t++)
                            n.__originalVertexNormals[t] ? n.__originalVertexNormals[t].copy(n.vertexNormals[t]) : n.__originalVertexNormals[t] = n.vertexNormals[t].clone();
                    var o = new kt;
                    for (o.faces = this.faces,
                    t = 0,
                    e = this.morphTargets.length; t < e; t++) {
                        if (!this.morphNormals[t]) {
                            this.morphNormals[t] = {},
                            this.morphNormals[t].faceNormals = [],
                            this.morphNormals[t].vertexNormals = [];
                            var a, h, c = this.morphNormals[t].faceNormals, l = this.morphNormals[t].vertexNormals;
                            for (r = 0,
                            i = this.faces.length; r < i; r++)
                                a = new s,
                                h = {
                                    a: new s,
                                    b: new s,
                                    c: new s
                                },
                                c.push(a),
                                l.push(h)
                        }
                        var u = this.morphNormals[t];
                        o.vertices = this.morphTargets[t].vertices,
                        o.computeFaceNormals(),
                        o.computeVertexNormals();
                        var a, h;
                        for (r = 0,
                        i = this.faces.length; r < i; r++)
                            n = this.faces[r],
                            a = u.faceNormals[r],
                            h = u.vertexNormals[r],
                            a.copy(n.normal),
                            h.a.copy(n.vertexNormals[0]),
                            h.b.copy(n.vertexNormals[1]),
                            h.c.copy(n.vertexNormals[2])
                    }
                    for (r = 0,
                    i = this.faces.length; r < i; r++)
                        n = this.faces[r],
                        n.normal = n.__originalFaceNormal,
                        n.vertexNormals = n.__originalVertexNormals
                },
                computeTangents: function() {
                    console.warn("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    for (var t = 0, e = this.vertices, r = 0, i = e.length; r < i; r++)
                        r > 0 && (t += e[r].distanceTo(e[r - 1])),
                        this.lineDistances[r] = t
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new et),
                    this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new rt),
                    this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, r) {
                    if ((t && t.isGeometry) === !1)
                        return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                    var i, n = this.vertices.length, o = this.vertices, a = t.vertices, s = this.faces, h = t.faces, c = this.faceVertexUvs[0], l = t.faceVertexUvs[0];
                    void 0 === r && (r = 0),
                    void 0 !== e && (i = (new it).getNormalMatrix(e));
                    for (var u = 0, p = a.length; u < p; u++) {
                        var d = a[u]
                          , f = d.clone();
                        void 0 !== e && f.applyMatrix4(e),
                        o.push(f)
                    }
                    for (u = 0,
                    p = h.length; u < p; u++) {
                        var m, g, v, y = h[u], x = y.vertexNormals, b = y.vertexColors;
                        m = new Dt(y.a + n,y.b + n,y.c + n),
                        m.normal.copy(y.normal),
                        void 0 !== i && m.normal.applyMatrix3(i).normalize();
                        for (var w = 0, _ = x.length; w < _; w++)
                            g = x[w].clone(),
                            void 0 !== i && g.applyMatrix3(i).normalize(),
                            m.vertexNormals.push(g);
                        m.color.copy(y.color);
                        for (var w = 0, _ = b.length; w < _; w++)
                            v = b[w],
                            m.vertexColors.push(v.clone());
                        m.materialIndex = y.materialIndex + r,
                        s.push(m)
                    }
                    for (u = 0,
                    p = l.length; u < p; u++) {
                        var M = l[u]
                          , S = [];
                        if (void 0 !== M) {
                            for (var w = 0, _ = M.length; w < _; w++)
                                S.push(M[w].clone());
                            c.push(S)
                        }
                    }
                },
                mergeMesh: function(t) {
                    return (t && t.isMesh) === !1 ? void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) : (t.matrixAutoUpdate && t.updateMatrix(),
                    void this.merge(t.geometry, t.matrix))
                },
                mergeVertices: function() {
                    var t, e, r, i, n, o, a, s, h = {}, c = [], l = [], u = 4, p = Math.pow(10, u);
                    for (r = 0,
                    i = this.vertices.length; r < i; r++)
                        t = this.vertices[r],
                        e = Math.round(t.x * p) + "_" + Math.round(t.y * p) + "_" + Math.round(t.z * p),
                        void 0 === h[e] ? (h[e] = r,
                        c.push(this.vertices[r]),
                        l[r] = c.length - 1) : l[r] = l[h[e]];
                    var d = [];
                    for (r = 0,
                    i = this.faces.length; r < i; r++) {
                        n = this.faces[r],
                        n.a = l[n.a],
                        n.b = l[n.b],
                        n.c = l[n.c],
                        o = [n.a, n.b, n.c];
                        for (var f = -1, m = 0; m < 3; m++)
                            if (o[m] === o[(m + 1) % 3]) {
                                f = m,
                                d.push(r);
                                break
                            }
                    }
                    for (r = d.length - 1; r >= 0; r--) {
                        var g = d[r];
                        for (this.faces.splice(g, 1),
                        a = 0,
                        s = this.faceVertexUvs.length; a < s; a++)
                            this.faceVertexUvs[a].splice(g, 1)
                    }
                    var v = this.vertices.length - c.length;
                    return this.vertices = c,
                    v
                },
                sortFacesByMaterialIndex: function() {
                    function t(t, e) {
                        return t.materialIndex - e.materialIndex
                    }
                    for (var e = this.faces, r = e.length, i = 0; i < r; i++)
                        e[i]._id = i;
                    e.sort(t);
                    var n, o, a = this.faceVertexUvs[0], s = this.faceVertexUvs[1];
                    a && a.length === r && (n = []),
                    s && s.length === r && (o = []);
                    for (var i = 0; i < r; i++) {
                        var h = e[i]._id;
                        n && n.push(a[h]),
                        o && o.push(s[h])
                    }
                    n && (this.faceVertexUvs[0] = n),
                    o && (this.faceVertexUvs[1] = o)
                },
                toJSON: function() {
                    function t(t, e, r) {
                        return r ? t | 1 << e : t & ~(1 << e)
                    }
                    function e(t) {
                        var e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== p[e] ? p[e] : (p[e] = u.length / 3,
                        u.push(t.x, t.y, t.z),
                        p[e])
                    }
                    function r(t) {
                        var e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== f[e] ? f[e] : (f[e] = d.length,
                        d.push(t.getHex()),
                        f[e])
                    }
                    function i(t) {
                        var e = t.x.toString() + t.y.toString();
                        return void 0 !== g[e] ? g[e] : (g[e] = m.length / 2,
                        m.push(t.x, t.y),
                        g[e])
                    }
                    var n = {
                        metadata: {
                            version: 4.4,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (n.uuid = this.uuid,
                    n.type = this.type,
                    "" !== this.name && (n.name = this.name),
                    void 0 !== this.parameters) {
                        var o = this.parameters;
                        for (var a in o)
                            void 0 !== o[a] && (n[a] = o[a]);
                        return n
                    }
                    for (var s = [], h = 0; h < this.vertices.length; h++) {
                        var c = this.vertices[h];
                        s.push(c.x, c.y, c.z)
                    }
                    for (var l = [], u = [], p = {}, d = [], f = {}, m = [], g = {}, h = 0; h < this.faces.length; h++) {
                        var v = this.faces[h]
                          , y = !0
                          , x = !1
                          , b = void 0 !== this.faceVertexUvs[0][h]
                          , w = v.normal.length() > 0
                          , _ = v.vertexNormals.length > 0
                          , M = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b
                          , S = v.vertexColors.length > 0
                          , E = 0;
                        if (E = t(E, 0, 0),
                        E = t(E, 1, y),
                        E = t(E, 2, x),
                        E = t(E, 3, b),
                        E = t(E, 4, w),
                        E = t(E, 5, _),
                        E = t(E, 6, M),
                        E = t(E, 7, S),
                        l.push(E),
                        l.push(v.a, v.b, v.c),
                        l.push(v.materialIndex),
                        b) {
                            var T = this.faceVertexUvs[0][h];
                            l.push(i(T[0]), i(T[1]), i(T[2]))
                        }
                        if (w && l.push(e(v.normal)),
                        _) {
                            var A = v.vertexNormals;
                            l.push(e(A[0]), e(A[1]), e(A[2]))
                        }
                        if (M && l.push(r(v.color)),
                        S) {
                            var L = v.vertexColors;
                            l.push(r(L[0]), r(L[1]), r(L[2]))
                        }
                    }
                    return n.data = {},
                    n.data.vertices = s,
                    n.data.normals = u,
                    d.length > 0 && (n.data.colors = d),
                    m.length > 0 && (n.data.uvs = [m]),
                    n.data.faces = l,
                    n
                },
                clone: function() {
                    return (new kt).copy(this)
                },
                copy: function(t) {
                    this.vertices = [],
                    this.faces = [],
                    this.faceVertexUvs = [[]];
                    for (var e = t.vertices, r = 0, i = e.length; r < i; r++)
                        this.vertices.push(e[r].clone());
                    for (var n = t.faces, r = 0, i = n.length; r < i; r++)
                        this.faces.push(n[r].clone());
                    for (var r = 0, i = t.faceVertexUvs.length; r < i; r++) {
                        var o = t.faceVertexUvs[r];
                        void 0 === this.faceVertexUvs[r] && (this.faceVertexUvs[r] = []);
                        for (var a = 0, s = o.length; a < s; a++) {
                            for (var h = o[a], c = [], l = 0, u = h.length; l < u; l++) {
                                var p = h[l];
                                c.push(p.clone())
                            }
                            this.faceVertexUvs[r].push(c)
                        }
                    }
                    return this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            var Oh = 0;
            Object.assign(Vt.prototype, e.prototype, {
                computeBoundingBox: kt.prototype.computeBoundingBox,
                computeBoundingSphere: kt.prototype.computeBoundingSphere,
                computeFaceNormals: function() {
                    console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
                },
                computeVertexNormals: function() {
                    console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
                },
                computeGroups: function(t) {
                    for (var e, r, i = [], n = t.faces, o = 0; o < n.length; o++) {
                        var a = n[o];
                        a.materialIndex !== r && (r = a.materialIndex,
                        void 0 !== e && (e.count = 3 * o - e.start,
                        i.push(e)),
                        e = {
                            start: 3 * o,
                            materialIndex: r
                        })
                    }
                    void 0 !== e && (e.count = 3 * o - e.start,
                    i.push(e)),
                    this.groups = i
                },
                fromGeometry: function(t) {
                    var e, i = t.faces, n = t.vertices, o = t.faceVertexUvs, a = o[0] && o[0].length > 0, s = o[1] && o[1].length > 0, h = t.morphTargets, c = h.length;
                    if (c > 0) {
                        e = [];
                        for (var l = 0; l < c; l++)
                            e[l] = [];
                        this.morphTargets.position = e
                    }
                    var u, p = t.morphNormals, d = p.length;
                    if (d > 0) {
                        u = [];
                        for (var l = 0; l < d; l++)
                            u[l] = [];
                        this.morphTargets.normal = u
                    }
                    for (var f = t.skinIndices, m = t.skinWeights, g = f.length === n.length, v = m.length === n.length, l = 0; l < i.length; l++) {
                        var y = i[l];
                        this.vertices.push(n[y.a], n[y.b], n[y.c]);
                        var x = y.vertexNormals;
                        if (3 === x.length)
                            this.normals.push(x[0], x[1], x[2]);
                        else {
                            var b = y.normal;
                            this.normals.push(b, b, b)
                        }
                        var w = y.vertexColors;
                        if (3 === w.length)
                            this.colors.push(w[0], w[1], w[2]);
                        else {
                            var _ = y.color;
                            this.colors.push(_, _, _)
                        }
                        if (a === !0) {
                            var M = o[0][l];
                            void 0 !== M ? this.uvs.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l),
                            this.uvs.push(new r, new r, new r))
                        }
                        if (s === !0) {
                            var M = o[1][l];
                            void 0 !== M ? this.uvs2.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l),
                            this.uvs2.push(new r, new r, new r))
                        }
                        for (var S = 0; S < c; S++) {
                            var E = h[S].vertices;
                            e[S].push(E[y.a], E[y.b], E[y.c])
                        }
                        for (var S = 0; S < d; S++) {
                            var T = p[S].vertexNormals[l];
                            u[S].push(T.a, T.b, T.c)
                        }
                        g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]),
                        v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                    }
                    return this.computeGroups(t),
                    this.verticesNeedUpdate = t.verticesNeedUpdate,
                    this.normalsNeedUpdate = t.normalsNeedUpdate,
                    this.colorsNeedUpdate = t.colorsNeedUpdate,
                    this.uvsNeedUpdate = t.uvsNeedUpdate,
                    this.groupsNeedUpdate = t.groupsNeedUpdate,
                    this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }),
            Object.assign(Gt.prototype, e.prototype, {
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    this.index = t
                },
                addAttribute: function(t, e) {
                    return (e && e.isBufferAttribute) === !1 && (e && e.isInterleavedBufferAttribute) === !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
                    void this.addAttribute(t, new Mt(arguments[1],arguments[2]))) : "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
                    void this.setIndex(e)) : (this.attributes[t] = e,
                    this)
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                removeAttribute: function(t) {
                    return delete this.attributes[t],
                    this
                },
                addGroup: function(t, e, r) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== r ? r : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t,
                    this.drawRange.count = e
                },
                applyMatrix: function(t) {
                    var e = this.attributes.position;
                    void 0 !== e && (t.applyToVector3Array(e.array),
                    e.needsUpdate = !0);
                    var r = this.attributes.normal;
                    if (void 0 !== r) {
                        var i = (new it).getNormalMatrix(t);
                        i.applyToVector3Array(r.array),
                        r.needsUpdate = !0
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(),
                    null !== this.boundingSphere && this.computeBoundingSphere(),
                    this
                },
                rotateX: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new o),
                        t.makeRotationX(e),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                rotateY: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new o),
                        t.makeRotationY(e),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                rotateZ: function() {
                    var t;
                    return function(e) {
                        return void 0 === t && (t = new o),
                        t.makeRotationZ(e),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                translate: function() {
                    var t;
                    return function(e, r, i) {
                        return void 0 === t && (t = new o),
                        t.makeTranslation(e, r, i),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                scale: function() {
                    var t;
                    return function(e, r, i) {
                        return void 0 === t && (t = new o),
                        t.makeScale(e, r, i),
                        this.applyMatrix(t),
                        this
                    }
                }(),
                lookAt: function() {
                    var t;
                    return function(e) {
                        void 0 === t && (t = new Bt),
                        t.lookAt(e),
                        t.updateMatrix(),
                        this.applyMatrix(t.matrix)
                    }
                }(),
                center: function() {
                    this.computeBoundingBox();
                    var t = this.boundingBox.center().negate();
                    return this.translate(t.x, t.y, t.z),
                    t
                },
                setFromObject: function(t) {
                    var e = t.geometry;
                    if (t && t.isPoints || t && t.isLine) {
                        var r = new Pt(3 * e.vertices.length,3)
                          , i = new Pt(3 * e.colors.length,3);
                        if (this.addAttribute("position", r.copyVector3sArray(e.vertices)),
                        this.addAttribute("color", i.copyColorsArray(e.colors)),
                        e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            var n = new Pt(e.lineDistances.length,1);
                            this.addAttribute("lineDistance", n.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else
                        t && t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                updateFromObject: function(t) {
                    var e = t.geometry;
                    if (t && t.isMesh) {
                        var r = e.__directGeometry;
                        if (e.elementsNeedUpdate === !0 && (r = void 0,
                        e.elementsNeedUpdate = !1),
                        void 0 === r)
                            return this.fromGeometry(e);
                        r.verticesNeedUpdate = e.verticesNeedUpdate,
                        r.normalsNeedUpdate = e.normalsNeedUpdate,
                        r.colorsNeedUpdate = e.colorsNeedUpdate,
                        r.uvsNeedUpdate = e.uvsNeedUpdate,
                        r.groupsNeedUpdate = e.groupsNeedUpdate,
                        e.verticesNeedUpdate = !1,
                        e.normalsNeedUpdate = !1,
                        e.colorsNeedUpdate = !1,
                        e.uvsNeedUpdate = !1,
                        e.groupsNeedUpdate = !1,
                        e = r
                    }
                    var i;
                    return e.verticesNeedUpdate === !0 && (i = this.attributes.position,
                    void 0 !== i && (i.copyVector3sArray(e.vertices),
                    i.needsUpdate = !0),
                    e.verticesNeedUpdate = !1),
                    e.normalsNeedUpdate === !0 && (i = this.attributes.normal,
                    void 0 !== i && (i.copyVector3sArray(e.normals),
                    i.needsUpdate = !0),
                    e.normalsNeedUpdate = !1),
                    e.colorsNeedUpdate === !0 && (i = this.attributes.color,
                    void 0 !== i && (i.copyColorsArray(e.colors),
                    i.needsUpdate = !0),
                    e.colorsNeedUpdate = !1),
                    e.uvsNeedUpdate && (i = this.attributes.uv,
                    void 0 !== i && (i.copyVector2sArray(e.uvs),
                    i.needsUpdate = !0),
                    e.uvsNeedUpdate = !1),
                    e.lineDistancesNeedUpdate && (i = this.attributes.lineDistance,
                    void 0 !== i && (i.copyArray(e.lineDistances),
                    i.needsUpdate = !0),
                    e.lineDistancesNeedUpdate = !1),
                    e.groupsNeedUpdate && (e.computeGroups(t.geometry),
                    this.groups = e.groups,
                    e.groupsNeedUpdate = !1),
                    this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new Vt).fromGeometry(t),
                    this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    var e = new Float32Array(3 * t.vertices.length);
                    if (this.addAttribute("position", new Mt(e,3).copyVector3sArray(t.vertices)),
                    t.normals.length > 0) {
                        var r = new Float32Array(3 * t.normals.length);
                        this.addAttribute("normal", new Mt(r,3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        var i = new Float32Array(3 * t.colors.length);
                        this.addAttribute("color", new Mt(i,3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        var n = new Float32Array(2 * t.uvs.length);
                        this.addAttribute("uv", new Mt(n,2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        var o = new Float32Array(2 * t.uvs2.length);
                        this.addAttribute("uv2", new Mt(o,2).copyVector2sArray(t.uvs2))
                    }
                    if (t.indices.length > 0) {
                        var a = t.vertices.length > 65535 ? Uint32Array : Uint16Array
                          , s = new a(3 * t.indices.length);
                        this.setIndex(new Mt(s,1).copyIndicesArray(t.indices))
                    }
                    this.groups = t.groups;
                    for (var h in t.morphTargets) {
                        for (var c = [], l = t.morphTargets[h], u = 0, p = l.length; u < p; u++) {
                            var d = l[u]
                              , f = new Pt(3 * d.length,3);
                            c.push(f.copyVector3sArray(d))
                        }
                        this.morphAttributes[h] = c
                    }
                    if (t.skinIndices.length > 0) {
                        var m = new Pt(4 * t.skinIndices.length,4);
                        this.addAttribute("skinIndex", m.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        var g = new Pt(4 * t.skinWeights.length,4);
                        this.addAttribute("skinWeight", g.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                    null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                    this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new et);
                    var t = this.attributes.position.array;
                    void 0 !== t ? this.boundingBox.setFromArray(t) : this.boundingBox.makeEmpty(),
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    var t = new et
                      , e = new s;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new rt);
                        var r = this.attributes.position;
                        if (r) {
                            var i = r.array
                              , n = this.boundingSphere.center;
                            t.setFromArray(i),
                            t.center(n);
                            for (var o = 0, a = 0, s = i.length; a < s; a += 3)
                                e.fromArray(i, a),
                                o = Math.max(o, n.distanceToSquared(e));
                            this.boundingSphere.radius = Math.sqrt(o),
                            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var t = this.index
                      , e = this.attributes
                      , r = this.groups;
                    if (e.position) {
                        var i = e.position.array;
                        if (void 0 === e.normal)
                            this.addAttribute("normal", new Mt(new Float32Array(i.length),3));
                        else
                            for (var n = e.normal.array, o = 0, a = n.length; o < a; o++)
                                n[o] = 0;
                        var h, c, l, u = e.normal.array, p = new s, d = new s, f = new s, m = new s, g = new s;
                        if (t) {
                            var v = t.array;
                            0 === r.length && this.addGroup(0, v.length);
                            for (var y = 0, x = r.length; y < x; ++y)
                                for (var b = r[y], w = b.start, _ = b.count, o = w, a = w + _; o < a; o += 3)
                                    h = 3 * v[o + 0],
                                    c = 3 * v[o + 1],
                                    l = 3 * v[o + 2],
                                    p.fromArray(i, h),
                                    d.fromArray(i, c),
                                    f.fromArray(i, l),
                                    m.subVectors(f, d),
                                    g.subVectors(p, d),
                                    m.cross(g),
                                    u[h] += m.x,
                                    u[h + 1] += m.y,
                                    u[h + 2] += m.z,
                                    u[c] += m.x,
                                    u[c + 1] += m.y,
                                    u[c + 2] += m.z,
                                    u[l] += m.x,
                                    u[l + 1] += m.y,
                                    u[l + 2] += m.z
                        } else
                            for (var o = 0, a = i.length; o < a; o += 9)
                                p.fromArray(i, o),
                                d.fromArray(i, o + 3),
                                f.fromArray(i, o + 6),
                                m.subVectors(f, d),
                                g.subVectors(p, d),
                                m.cross(g),
                                u[o] = m.x,
                                u[o + 1] = m.y,
                                u[o + 2] = m.z,
                                u[o + 3] = m.x,
                                u[o + 4] = m.y,
                                u[o + 5] = m.z,
                                u[o + 6] = m.x,
                                u[o + 7] = m.y,
                                u[o + 8] = m.z;
                        this.normalizeNormals(),
                        e.normal.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if ((t && t.isBufferGeometry) === !1)
                        return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                    void 0 === e && (e = 0);
                    var r = this.attributes;
                    for (var i in r)
                        if (void 0 !== t.attributes[i])
                            for (var n = r[i], o = n.array, a = t.attributes[i], s = a.array, h = a.itemSize, c = 0, l = h * e; c < s.length; c++,
                            l++)
                                o[l] = s[c];
                    return this
                },
                normalizeNormals: function() {
                    for (var t, e, r, i, n = this.attributes.normal.array, o = 0, a = n.length; o < a; o += 3)
                        t = n[o],
                        e = n[o + 1],
                        r = n[o + 2],
                        i = 1 / Math.sqrt(t * t + e * e + r * r),
                        n[o] *= i,
                        n[o + 1] *= i,
                        n[o + 2] *= i
                },
                toNonIndexed: function() {
                    if (null === this.index)
                        return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                        this;
                    var t = new Gt
                      , e = this.index.array
                      , r = this.attributes;
                    for (var i in r) {
                        for (var n = r[i], o = n.array, a = n.itemSize, s = new o.constructor(e.length * a), h = 0, c = 0, l = 0, u = e.length; l < u; l++) {
                            h = e[l] * a;
                            for (var p = 0; p < a; p++)
                                s[c++] = o[h++]
                        }
                        t.addAttribute(i, new Mt(s,a))
                    }
                    return t
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.4,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid,
                    t.type = this.type,
                    "" !== this.name && (t.name = this.name),
                    void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var r in e)
                            void 0 !== e[r] && (t[r] = e[r]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    var i = this.index;
                    if (null !== i) {
                        var n = Array.prototype.slice.call(i.array);
                        t.data.index = {
                            type: i.array.constructor.name,
                            array: n
                        }
                    }
                    var o = this.attributes;
                    for (var r in o) {
                        var a = o[r]
                          , n = Array.prototype.slice.call(a.array);
                        t.data.attributes[r] = {
                            itemSize: a.itemSize,
                            type: a.array.constructor.name,
                            array: n,
                            normalized: a.normalized
                        }
                    }
                    var s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    var h = this.boundingSphere;
                    return null !== h && (t.data.boundingSphere = {
                        center: h.center.toArray(),
                        radius: h.radius
                    }),
                    t
                },
                clone: function() {
                    return (new Gt).copy(this)
                },
                copy: function(t) {
                    var e = t.index;
                    null !== e && this.setIndex(e.clone());
                    var r = t.attributes;
                    for (var i in r) {
                        var n = r[i];
                        this.addAttribute(i, n.clone())
                    }
                    for (var o = t.groups, a = 0, s = o.length; a < s; a++) {
                        var h = o[a];
                        this.addGroup(h.start, h.count, h.materialIndex)
                    }
                    return this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }),
            Gt.MaxIndex = 65535,
            Jt.prototype = Object.create(Z.prototype),
            Jt.prototype.constructor = Jt,
            Jt.prototype.isWebGLRenderTargetCube = !0,
            Kt.prototype = Object.create(Gt.prototype),
            Kt.prototype.constructor = Kt,
            $t.prototype = {
                constructor: $t,
                set: function(t, e) {
                    return this.origin.copy(t),
                    this.direction.copy(e),
                    this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.origin.copy(t.origin),
                    this.direction.copy(t.direction),
                    this
                },
                at: function(t, e) {
                    var r = e || new s;
                    return r.copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(),
                    this
                },
                recast: function() {
                    var t = new s;
                    return function(e) {
                        return this.origin.copy(this.at(e, t)),
                        this
                    }
                }(),
                closestPointToPoint: function(t, e) {
                    var r = e || new s;
                    r.subVectors(t, this.origin);
                    var i = r.dot(this.direction);
                    return i < 0 ? r.copy(this.origin) : r.copy(this.direction).multiplyScalar(i).add(this.origin)
                },
                distanceToPoint: function(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                },
                distanceSqToPoint: function() {
                    var t = new s;
                    return function(e) {
                        var r = t.subVectors(e, this.origin).dot(this.direction);
                        return r < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(r).add(this.origin),
                        t.distanceToSquared(e))
                    }
                }(),
                distanceSqToSegment: function() {
                    var t = new s
                      , e = new s
                      , r = new s;
                    return function(i, n, o, a) {
                        t.copy(i).add(n).multiplyScalar(.5),
                        e.copy(n).sub(i).normalize(),
                        r.copy(this.origin).sub(t);
                        var s, h, c, l, u = .5 * i.distanceTo(n), p = -this.direction.dot(e), d = r.dot(this.direction), f = -r.dot(e), m = r.lengthSq(), g = Math.abs(1 - p * p);
                        if (g > 0)
                            if (s = p * f - d,
                            h = p * d - f,
                            l = u * g,
                            s >= 0)
                                if (h >= -l)
                                    if (h <= l) {
                                        var v = 1 / g;
                                        s *= v,
                                        h *= v,
                                        c = s * (s + p * h + 2 * d) + h * (p * s + h + 2 * f) + m
                                    } else
                                        h = u,
                                        s = Math.max(0, -(p * h + d)),
                                        c = -s * s + h * (h + 2 * f) + m;
                                else
                                    h = -u,
                                    s = Math.max(0, -(p * h + d)),
                                    c = -s * s + h * (h + 2 * f) + m;
                            else
                                h <= -l ? (s = Math.max(0, -(-p * u + d)),
                                h = s > 0 ? -u : Math.min(Math.max(-u, -f), u),
                                c = -s * s + h * (h + 2 * f) + m) : h <= l ? (s = 0,
                                h = Math.min(Math.max(-u, -f), u),
                                c = h * (h + 2 * f) + m) : (s = Math.max(0, -(p * u + d)),
                                h = s > 0 ? u : Math.min(Math.max(-u, -f), u),
                                c = -s * s + h * (h + 2 * f) + m);
                        else
                            h = p > 0 ? -u : u,
                            s = Math.max(0, -(p * h + d)),
                            c = -s * s + h * (h + 2 * f) + m;
                        return o && o.copy(this.direction).multiplyScalar(s).add(this.origin),
                        a && a.copy(e).multiplyScalar(h).add(t),
                        c
                    }
                }(),
                intersectSphere: function() {
                    var t = new s;
                    return function(e, r) {
                        t.subVectors(e.center, this.origin);
                        var i = t.dot(this.direction)
                          , n = t.dot(t) - i * i
                          , o = e.radius * e.radius;
                        if (n > o)
                            return null;
                        var a = Math.sqrt(o - n)
                          , s = i - a
                          , h = i + a;
                        return s < 0 && h < 0 ? null : s < 0 ? this.at(h, r) : this.at(s, r)
                    }
                }(),
                intersectsSphere: function(t) {
                    return this.distanceToPoint(t.center) <= t.radius
                },
                distanceToPlane: function(t) {
                    var e = t.normal.dot(this.direction);
                    if (0 === e)
                        return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    var r = -(this.origin.dot(t.normal) + t.constant) / e;
                    return r >= 0 ? r : null
                },
                intersectPlane: function(t, e) {
                    var r = this.distanceToPlane(t);
                    return null === r ? null : this.at(r, e)
                },
                intersectsPlane: function(t) {
                    var e = t.distanceToPoint(this.origin);
                    if (0 === e)
                        return !0;
                    var r = t.normal.dot(this.direction);
                    return r * e < 0
                },
                intersectBox: function(t, e) {
                    var r, i, n, o, a, s, h = 1 / this.direction.x, c = 1 / this.direction.y, l = 1 / this.direction.z, u = this.origin;
                    return h >= 0 ? (r = (t.min.x - u.x) * h,
                    i = (t.max.x - u.x) * h) : (r = (t.max.x - u.x) * h,
                    i = (t.min.x - u.x) * h),
                    c >= 0 ? (n = (t.min.y - u.y) * c,
                    o = (t.max.y - u.y) * c) : (n = (t.max.y - u.y) * c,
                    o = (t.min.y - u.y) * c),
                    r > o || n > i ? null : ((n > r || r !== r) && (r = n),
                    (o < i || i !== i) && (i = o),
                    l >= 0 ? (a = (t.min.z - u.z) * l,
                    s = (t.max.z - u.z) * l) : (a = (t.max.z - u.z) * l,
                    s = (t.min.z - u.z) * l),
                    r > s || a > i ? null : ((a > r || r !== r) && (r = a),
                    (s < i || i !== i) && (i = s),
                    i < 0 ? null : this.at(r >= 0 ? r : i, e)))
                },
                intersectsBox: function() {
                    var t = new s;
                    return function(e) {
                        return null !== this.intersectBox(e, t)
                    }
                }(),
                intersectTriangle: function() {
                    var t = new s
                      , e = new s
                      , r = new s
                      , i = new s;
                    return function(n, o, a, s, h) {
                        e.subVectors(o, n),
                        r.subVectors(a, n),
                        i.crossVectors(e, r);
                        var c, l = this.direction.dot(i);
                        if (l > 0) {
                            if (s)
                                return null;
                            c = 1
                        } else {
                            if (!(l < 0))
                                return null;
                            c = -1,
                            l = -l
                        }
                        t.subVectors(this.origin, n);
                        var u = c * this.direction.dot(r.crossVectors(t, r));
                        if (u < 0)
                            return null;
                        var p = c * this.direction.dot(e.cross(t));
                        if (p < 0)
                            return null;
                        if (u + p > l)
                            return null;
                        var d = -c * t.dot(i);
                        return d < 0 ? null : this.at(d / l, h)
                    }
                }(),
                applyMatrix4: function(t) {
                    return this.direction.add(this.origin).applyMatrix4(t),
                    this.origin.applyMatrix4(t),
                    this.direction.sub(this.origin),
                    this.direction.normalize(),
                    this
                },
                equals: function(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            },
            te.prototype = {
                constructor: te,
                set: function(t, e) {
                    return this.start.copy(t),
                    this.end.copy(e),
                    this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.start.copy(t.start),
                    this.end.copy(t.end),
                    this
                },
                center: function(t) {
                    var e = t || new s;
                    return e.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(t) {
                    var e = t || new s;
                    return e.subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(t, e) {
                    var r = e || new s;
                    return this.delta(r).multiplyScalar(t).add(this.start)
                },
                closestPointToPointParameter: function() {
                    var e = new s
                      , r = new s;
                    return function(i, n) {
                        e.subVectors(i, this.start),
                        r.subVectors(this.end, this.start);
                        var o = r.dot(r)
                          , a = r.dot(e)
                          , s = a / o;
                        return n && (s = t.Math.clamp(s, 0, 1)),
                        s
                    }
                }(),
                closestPointToPoint: function(t, e, r) {
                    var i = this.closestPointToPointParameter(t, e)
                      , n = r || new s;
                    return this.delta(n).multiplyScalar(i).add(this.start)
                },
                applyMatrix4: function(t) {
                    return this.start.applyMatrix4(t),
                    this.end.applyMatrix4(t),
                    this
                },
                equals: function(t) {
                    return t.start.equals(this.start) && t.end.equals(this.end)
                }
            },
            ee.normal = function() {
                var t = new s;
                return function(e, r, i, n) {
                    var o = n || new s;
                    o.subVectors(i, r),
                    t.subVectors(e, r),
                    o.cross(t);
                    var a = o.lengthSq();
                    return a > 0 ? o.multiplyScalar(1 / Math.sqrt(a)) : o.set(0, 0, 0)
                }
            }(),
            ee.barycoordFromPoint = function() {
                var t = new s
                  , e = new s
                  , r = new s;
                return function(i, n, o, a, h) {
                    t.subVectors(a, n),
                    e.subVectors(o, n),
                    r.subVectors(i, n);
                    var c = t.dot(t)
                      , l = t.dot(e)
                      , u = t.dot(r)
                      , p = e.dot(e)
                      , d = e.dot(r)
                      , f = c * p - l * l
                      , m = h || new s;
                    if (0 === f)
                        return m.set(-2, -1, -1);
                    var g = 1 / f
                      , v = (p * u - l * d) * g
                      , y = (c * d - l * u) * g;
                    return m.set(1 - v - y, y, v)
                }
            }(),
            ee.containsPoint = function() {
                var t = new s;
                return function(e, r, i, n) {
                    var o = ee.barycoordFromPoint(e, r, i, n, t);
                    return o.x >= 0 && o.y >= 0 && o.x + o.y <= 1
                }
            }(),
            ee.prototype = {
                constructor: ee,
                set: function(t, e, r) {
                    return this.a.copy(t),
                    this.b.copy(e),
                    this.c.copy(r),
                    this
                },
                setFromPointsAndIndices: function(t, e, r, i) {
                    return this.a.copy(t[e]),
                    this.b.copy(t[r]),
                    this.c.copy(t[i]),
                    this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.a.copy(t.a),
                    this.b.copy(t.b),
                    this.c.copy(t.c),
                    this
                },
                area: function() {
                    var t = new s
                      , e = new s;
                    return function() {
                        return t.subVectors(this.c, this.b),
                        e.subVectors(this.a, this.b),
                        .5 * t.cross(e).length()
                    }
                }(),
                midpoint: function(t) {
                    var e = t || new s;
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                normal: function(t) {
                    return ee.normal(this.a, this.b, this.c, t)
                },
                plane: function(t) {
                    var e = t || new nt;
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                barycoordFromPoint: function(t, e) {
                    return ee.barycoordFromPoint(t, this.a, this.b, this.c, e)
                },
                containsPoint: function(t) {
                    return ee.containsPoint(t, this.a, this.b, this.c)
                },
                closestPointToPoint: function() {
                    var t, e, r, i;
                    return function(n, o) {
                        void 0 === t && (t = new nt,
                        e = [new te, new te, new te],
                        r = new s,
                        i = new s);
                        var a = o || new s
                          , h = 1 / 0;
                        if (t.setFromCoplanarPoints(this.a, this.b, this.c),
                        t.projectPoint(n, r),
                        this.containsPoint(r) === !0)
                            a.copy(r);
                        else {
                            e[0].set(this.a, this.b),
                            e[1].set(this.b, this.c),
                            e[2].set(this.c, this.a);
                            for (var c = 0; c < e.length; c++) {
                                e[c].closestPointToPoint(r, !0, i);
                                var l = r.distanceToSquared(i);
                                l < h && (h = l,
                                a.copy(i))
                            }
                        }
                        return a
                    }
                }(),
                equals: function(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            },
            re.prototype = Object.create(Q.prototype),
            re.prototype.constructor = re,
            re.prototype.isMeshBasicMaterial = !0,
            re.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.color.copy(t.color),
                this.map = t.map,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this
            }
            ,
            ie.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: ie,
                isMesh: !0,
                setDrawMode: function(t) {
                    this.drawMode = t
                },
                copy: function(t) {
                    return Bt.prototype.copy.call(this, t),
                    this.drawMode = t.drawMode,
                    this
                },
                updateMorphTargets: function() {
                    if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) {
                        this.morphTargetBase = -1,
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (var t = 0, e = this.geometry.morphTargets.length; t < e; t++)
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[this.geometry.morphTargets[t].name] = t
                    }
                },
                getMorphTargetIndexByName: function(t) {
                    return void 0 !== this.morphTargetDictionary[t] ? this.morphTargetDictionary[t] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + t + " does not exist. Returning 0."),
                    0)
                },
                raycast: function() {
                    function t(t, e, r, i, n, o, a) {
                        return ee.barycoordFromPoint(t, e, r, i, y),
                        n.multiplyScalar(y.x),
                        o.multiplyScalar(y.y),
                        a.multiplyScalar(y.z),
                        n.add(o).add(a),
                        n.clone()
                    }
                    function e(t, e, r, i, n, o, a) {
                        var s, h = t.material;
                        if (s = h.side === bn ? r.intersectTriangle(o, n, i, !0, a) : r.intersectTriangle(i, n, o, h.side !== wn, a),
                        null === s)
                            return null;
                        b.copy(a),
                        b.applyMatrix4(t.matrixWorld);
                        var c = e.ray.origin.distanceTo(b);
                        return c < e.near || c > e.far ? null : {
                            distance: c,
                            point: b.clone(),
                            object: t
                        }
                    }
                    function i(r, i, n, o, a, s, h, p) {
                        c.fromArray(o, 3 * s),
                        l.fromArray(o, 3 * h),
                        u.fromArray(o, 3 * p);
                        var d = e(r, i, n, c, l, u, x);
                        return d && (a && (m.fromArray(a, 2 * s),
                        g.fromArray(a, 2 * h),
                        v.fromArray(a, 2 * p),
                        d.uv = t(x, c, l, u, m, g, v)),
                        d.face = new Dt(s,h,p,ee.normal(c, l, u)),
                        d.faceIndex = s),
                        d
                    }
                    var n = new o
                      , a = new $t
                      , h = new rt
                      , c = new s
                      , l = new s
                      , u = new s
                      , p = new s
                      , d = new s
                      , f = new s
                      , m = new r
                      , g = new r
                      , v = new r
                      , y = new s
                      , x = new s
                      , b = new s;
                    return function(r, o) {
                        var s = this.geometry
                          , y = this.material
                          , b = this.matrixWorld;
                        if (void 0 !== y && (null === s.boundingSphere && s.computeBoundingSphere(),
                        h.copy(s.boundingSphere),
                        h.applyMatrix4(b),
                        r.ray.intersectsSphere(h) !== !1 && (n.getInverse(b),
                        a.copy(r.ray).applyMatrix4(n),
                        null === s.boundingBox || a.intersectsBox(s.boundingBox) !== !1))) {
                            var w, _;
                            if (s && s.isBufferGeometry) {
                                var M, S, E, T = s.index, A = s.attributes, L = A.position.array;
                                if (void 0 !== A.uv && (w = A.uv.array),
                                null !== T)
                                    for (var C = T.array, R = 0, P = C.length; R < P; R += 3)
                                        M = C[R],
                                        S = C[R + 1],
                                        E = C[R + 2],
                                        _ = i(this, r, a, L, w, M, S, E),
                                        _ && (_.faceIndex = Math.floor(R / 3),
                                        o.push(_));
                                else
                                    for (var R = 0, P = L.length; R < P; R += 9)
                                        M = R / 3,
                                        S = M + 1,
                                        E = M + 2,
                                        _ = i(this, r, a, L, w, M, S, E),
                                        _ && (_.index = M,
                                        o.push(_))
                            } else if (s && s.isGeometry) {
                                var U, I, D, O = y && y.isMultiMaterial, N = O === !0 ? y.materials : null, B = s.vertices, F = s.faces, k = s.faceVertexUvs[0];
                                k.length > 0 && (w = k);
                                for (var z = 0, V = F.length; z < V; z++) {
                                    var G = F[z]
                                      , j = O === !0 ? N[G.materialIndex] : y;
                                    if (void 0 !== j) {
                                        if (U = B[G.a],
                                        I = B[G.b],
                                        D = B[G.c],
                                        j.morphTargets === !0) {
                                            var H = s.morphTargets
                                              , W = this.morphTargetInfluences;
                                            c.set(0, 0, 0),
                                            l.set(0, 0, 0),
                                            u.set(0, 0, 0);
                                            for (var X = 0, Y = H.length; X < Y; X++) {
                                                var q = W[X];
                                                if (0 !== q) {
                                                    var Z = H[X].vertices;
                                                    c.addScaledVector(p.subVectors(Z[G.a], U), q),
                                                    l.addScaledVector(d.subVectors(Z[G.b], I), q),
                                                    u.addScaledVector(f.subVectors(Z[G.c], D), q)
                                                }
                                            }
                                            c.add(U),
                                            l.add(I),
                                            u.add(D),
                                            U = c,
                                            I = l,
                                            D = u
                                        }
                                        if (_ = e(this, r, a, U, I, D, x)) {
                                            if (w) {
                                                var Q = w[z];
                                                m.copy(Q[0]),
                                                g.copy(Q[1]),
                                                v.copy(Q[2]),
                                                _.uv = t(x, U, I, D, m, g, v)
                                            }
                                            _.face = G,
                                            _.faceIndex = z,
                                            o.push(_)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry,this.material).copy(this)
                }
            }),
            ne.prototype = Object.create(Gt.prototype),
            ne.prototype.constructor = ne,
            oe.prototype = Object.create(Bt.prototype),
            oe.prototype.constructor = oe,
            oe.prototype.isCamera = !0,
            oe.prototype.getWorldDirection = function() {
                var t = new a;
                return function(e) {
                    var r = e || new s;
                    return this.getWorldQuaternion(t),
                    r.set(0, 0, -1).applyQuaternion(t)
                }
            }(),
            oe.prototype.lookAt = function() {
                var t = new o;
                return function(e) {
                    t.lookAt(this.position, e, this.up),
                    this.quaternion.setFromRotationMatrix(t)
                }
            }(),
            oe.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }
            ,
            oe.prototype.copy = function(t) {
                return Bt.prototype.copy.call(this, t),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this
            }
            ,
            ae.prototype = Object.assign(Object.create(oe.prototype), {
                constructor: ae,
                isPerspectiveCamera: !0,
                copy: function(t) {
                    return oe.prototype.copy.call(this, t),
                    this.fov = t.fov,
                    this.zoom = t.zoom,
                    this.near = t.near,
                    this.far = t.far,
                    this.focus = t.focus,
                    this.aspect = t.aspect,
                    this.view = null === t.view ? null : Object.assign({}, t.view),
                    this.filmGauge = t.filmGauge,
                    this.filmOffset = t.filmOffset,
                    this
                },
                setFocalLength: function(e) {
                    var r = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * t.Math.RAD2DEG * Math.atan(r),
                    this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var e = Math.tan(.5 * t.Math.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / e
                },
                getEffectiveFOV: function() {
                    return 2 * t.Math.RAD2DEG * Math.atan(Math.tan(.5 * t.Math.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, r, i, n, o) {
                    this.aspect = t / e,
                    this.view = {
                        fullWidth: t,
                        fullHeight: e,
                        offsetX: r,
                        offsetY: i,
                        width: n,
                        height: o
                    },
                    this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    this.view = null,
                    this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var e = this.near
                      , r = e * Math.tan(.5 * t.Math.DEG2RAD * this.fov) / this.zoom
                      , i = 2 * r
                      , n = this.aspect * i
                      , o = -.5 * n
                      , a = this.view;
                    if (null !== a) {
                        var s = a.fullWidth
                          , h = a.fullHeight;
                        o += a.offsetX * n / s,
                        r -= a.offsetY * i / h,
                        n *= a.width / s,
                        i *= a.height / h
                    }
                    var c = this.filmOffset;
                    0 !== c && (o += e * c / this.getFilmWidth()),
                    this.projectionMatrix.makeFrustum(o, o + n, r - i, r, e, this.far)
                },
                toJSON: function(t) {
                    var e = Bt.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov,
                    e.object.zoom = this.zoom,
                    e.object.near = this.near,
                    e.object.far = this.far,
                    e.object.focus = this.focus,
                    e.object.aspect = this.aspect,
                    null !== this.view && (e.object.view = Object.assign({}, this.view)),
                    e.object.filmGauge = this.filmGauge,
                    e.object.filmOffset = this.filmOffset,
                    e
                }
            }),
            se.prototype = Object.assign(Object.create(oe.prototype), {
                constructor: se,
                isOrthographicCamera: !0,
                copy: function(t) {
                    return oe.prototype.copy.call(this, t),
                    this.left = t.left,
                    this.right = t.right,
                    this.top = t.top,
                    this.bottom = t.bottom,
                    this.near = t.near,
                    this.far = t.far,
                    this.zoom = t.zoom,
                    this.view = null === t.view ? null : Object.assign({}, t.view),
                    this
                },
                setViewOffset: function(t, e, r, i, n, o) {
                    this.view = {
                        fullWidth: t,
                        fullHeight: e,
                        offsetX: r,
                        offsetY: i,
                        width: n,
                        height: o
                    },
                    this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    this.view = null,
                    this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = (this.right - this.left) / (2 * this.zoom)
                      , e = (this.top - this.bottom) / (2 * this.zoom)
                      , r = (this.right + this.left) / 2
                      , i = (this.top + this.bottom) / 2
                      , n = r - t
                      , o = r + t
                      , a = i + e
                      , s = i - e;
                    if (null !== this.view) {
                        var h = this.zoom / (this.view.width / this.view.fullWidth)
                          , c = this.zoom / (this.view.height / this.view.fullHeight)
                          , l = (this.right - this.left) / this.view.width
                          , u = (this.top - this.bottom) / this.view.height;
                        n += l * (this.view.offsetX / h),
                        o = n + l * (this.view.width / h),
                        a -= u * (this.view.offsetY / c),
                        s = a - u * (this.view.height / c)
                    }
                    this.projectionMatrix.makeOrthographic(n, o, a, s, this.near, this.far)
                },
                toJSON: function(t) {
                    var e = Bt.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom,
                    e.object.left = this.left,
                    e.object.right = this.right,
                    e.object.top = this.top,
                    e.object.bottom = this.bottom,
                    e.object.near = this.near,
                    e.object.far = this.far,
                    null !== this.view && (e.object.view = Object.assign({}, this.view)),
                    e
                }
            }),
            ce.prototype.isFogExp2 = !0,
            ce.prototype.clone = function() {
                return new ce(this.color.getHex(),this.density)
            }
            ,
            ce.prototype.toJSON = function(t) {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
            ,
            le.prototype.isFog = !0,
            le.prototype.clone = function() {
                return new le(this.color.getHex(),this.near,this.far)
            }
            ,
            le.prototype.toJSON = function(t) {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
            ,
            ue.prototype = Object.create(Bt.prototype),
            ue.prototype.constructor = ue,
            ue.prototype.copy = function(t, e) {
                return Bt.prototype.copy.call(this, t, e),
                null !== t.background && (this.background = t.background.clone()),
                null !== t.fog && (this.fog = t.fog.clone()),
                null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                this.autoUpdate = t.autoUpdate,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this
            }
            ,
            ue.prototype.toJSON = function(t) {
                var e = Bt.prototype.toJSON.call(this, t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)),
                null !== this.fog && (e.object.fog = this.fog.toJSON()),
                e
            }
            ,
            pe.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: pe,
                isLensFlare: !0,
                copy: function(t) {
                    Bt.prototype.copy.call(this, t),
                    this.positionScreen.copy(t.positionScreen),
                    this.customUpdateCallback = t.customUpdateCallback;
                    for (var e = 0, r = t.lensFlares.length; e < r; e++)
                        this.lensFlares.push(t.lensFlares[e]);
                    return this
                },
                add: function(t, e, r, i, n, o) {
                    void 0 === e && (e = -1),
                    void 0 === r && (r = 0),
                    void 0 === o && (o = 1),
                    void 0 === n && (n = new $(16777215)),
                    void 0 === i && (i = Ln),
                    r = Math.min(r, Math.max(0, r)),
                    this.lensFlares.push({
                        texture: t,
                        size: e,
                        distance: r,
                        x: 0,
                        y: 0,
                        z: 0,
                        scale: 1,
                        rotation: 0,
                        opacity: o,
                        color: n,
                        blending: i
                    })
                },
                updateLensFlares: function() {
                    var t, e, r = this.lensFlares.length, i = 2 * -this.positionScreen.x, n = 2 * -this.positionScreen.y;
                    for (t = 0; t < r; t++)
                        e = this.lensFlares[t],
                        e.x = this.positionScreen.x + i * e.distance,
                        e.y = this.positionScreen.y + n * e.distance,
                        e.wantedRotation = e.x * Math.PI * .25,
                        e.rotation += .25 * (e.wantedRotation - e.rotation)
                }
            }),
            de.prototype = Object.create(Q.prototype),
            de.prototype.constructor = de,
            de.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.color.copy(t.color),
                this.map = t.map,
                this.rotation = t.rotation,
                this
            }
            ,
            fe.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: fe,
                isSprite: !0,
                raycast: function() {
                    var t = new s;
                    return function(e, r) {
                        t.setFromMatrixPosition(this.matrixWorld);
                        var i = e.ray.distanceSqToPoint(t)
                          , n = this.scale.x * this.scale.y / 4;
                        i > n || r.push({
                            distance: Math.sqrt(i),
                            point: this.position,
                            face: null,
                            object: this
                        })
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                }
            }),
            me.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: me,
                copy: function(t) {
                    Bt.prototype.copy.call(this, t, !1);
                    for (var e = t.levels, r = 0, i = e.length; r < i; r++) {
                        var n = e[r];
                        this.addLevel(n.object.clone(), n.distance)
                    }
                    return this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0),
                    e = Math.abs(e);
                    for (var r = this.levels, i = 0; i < r.length && !(e < r[i].distance); i++)
                        ;
                    r.splice(i, 0, {
                        distance: e,
                        object: t
                    }),
                    this.add(t)
                },
                getObjectForDistance: function(t) {
                    for (var e = this.levels, r = 1, i = e.length; r < i && !(t < e[r].distance); r++)
                        ;
                    return e[r - 1].object
                },
                raycast: function() {
                    var t = new s;
                    return function(e, r) {
                        t.setFromMatrixPosition(this.matrixWorld);
                        var i = e.ray.origin.distanceTo(t);
                        this.getObjectForDistance(i).raycast(e, r)
                    }
                }(),
                update: function() {
                    var t = new s
                      , e = new s;
                    return function(r) {
                        var i = this.levels;
                        if (i.length > 1) {
                            t.setFromMatrixPosition(r.matrixWorld),
                            e.setFromMatrixPosition(this.matrixWorld);
                            var n = t.distanceTo(e);
                            i[0].object.visible = !0;
                            for (var o = 1, a = i.length; o < a && n >= i[o].distance; o++)
                                i[o - 1].object.visible = !1,
                                i[o].object.visible = !0;
                            for (; o < a; o++)
                                i[o].object.visible = !1
                        }
                    }
                }(),
                toJSON: function(t) {
                    var e = Bt.prototype.toJSON.call(this, t);
                    e.object.levels = [];
                    for (var r = this.levels, i = 0, n = r.length; i < n; i++) {
                        var o = r[i];
                        e.object.levels.push({
                            object: o.object.uuid,
                            distance: o.distance
                        })
                    }
                    return e
                }
            }),
            ge.prototype = Object.create(i.prototype),
            ge.prototype.constructor = ge,
            ge.prototype.isDataTexture = !0,
            Object.assign(ve.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var r = new o;
                        this.bones[t] && r.getInverse(this.bones[t].matrixWorld),
                        this.boneInverses.push(r)
                    }
                },
                pose: function() {
                    for (var t, e = 0, r = this.bones.length; e < r; e++)
                        t = this.bones[e],
                        t && t.matrixWorld.getInverse(this.boneInverses[e]);
                    for (var e = 0, r = this.bones.length; e < r; e++)
                        t = this.bones[e],
                        t && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld),
                        t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                        t.matrix.decompose(t.position, t.quaternion, t.scale))
                },
                update: function() {
                    var t = new o;
                    return function() {
                        for (var e = 0, r = this.bones.length; e < r; e++) {
                            var i = this.bones[e] ? this.bones[e].matrixWorld : this.identityMatrix;
                            t.multiplyMatrices(i, this.boneInverses[e]),
                            t.toArray(this.boneMatrices, 16 * e)
                        }
                        this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
                    }
                }(),
                clone: function() {
                    return new ve(this.bones,this.boneInverses,this.useVertexTexture)
                }
            }),
            ye.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: ye,
                isBone: !0,
                copy: function(t) {
                    return Bt.prototype.copy.call(this, t),
                    this.skin = t.skin,
                    this
                }
            }),
            xe.prototype = Object.assign(Object.create(ie.prototype), {
                constructor: xe,
                isSkinnedMesh: !0,
                bind: function(t, e) {
                    this.skeleton = t,
                    void 0 === e && (this.updateMatrixWorld(!0),
                    this.skeleton.calculateInverses(),
                    e = this.matrixWorld),
                    this.bindMatrix.copy(e),
                    this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    if (this.geometry && this.geometry.isGeometry)
                        for (var t = 0; t < this.geometry.skinWeights.length; t++) {
                            var e = this.geometry.skinWeights[t]
                              , r = 1 / e.lengthManhattan();
                            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0)
                        }
                    else if (this.geometry && this.geometry.isBufferGeometry)
                        for (var i = new Y, n = this.geometry.attributes.skinWeight, t = 0; t < n.count; t++) {
                            i.x = n.getX(t),
                            i.y = n.getY(t),
                            i.z = n.getZ(t),
                            i.w = n.getW(t);
                            var r = 1 / i.lengthManhattan();
                            r !== 1 / 0 ? i.multiplyScalar(r) : i.set(1, 0, 0, 0),
                            n.setXYZW(t, i.x, i.y, i.z, i.w)
                        }
                },
                updateMatrixWorld: function(t) {
                    ie.prototype.updateMatrixWorld.call(this, !0),
                    "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
                },
                clone: function() {
                    return new this.constructor(this.geometry,this.material,this.skeleton.useVertexTexture).copy(this)
                }
            }),
            be.prototype = Object.create(Q.prototype),
            be.prototype.constructor = be,
            be.prototype.isLineBasicMaterial = !0,
            be.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.color.copy(t.color),
                this.linewidth = t.linewidth,
                this.linecap = t.linecap,
                this.linejoin = t.linejoin,
                this
            }
            ,
            we.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: we,
                isLine: !0,
                raycast: function() {
                    var t = new o
                      , e = new $t
                      , r = new rt;
                    return function(i, n) {
                        var o = i.linePrecision
                          , a = o * o
                          , h = this.geometry
                          , c = this.matrixWorld;
                        if (null === h.boundingSphere && h.computeBoundingSphere(),
                        r.copy(h.boundingSphere),
                        r.applyMatrix4(c),
                        i.ray.intersectsSphere(r) !== !1) {
                            t.getInverse(c),
                            e.copy(i.ray).applyMatrix4(t);
                            var l = new s
                              , u = new s
                              , p = new s
                              , d = new s
                              , f = this && this.isLineSegments ? 2 : 1;
                            if (h && h.isBufferGeometry) {
                                var m = h.index
                                  , g = h.attributes
                                  , v = g.position.array;
                                if (null !== m)
                                    for (var y = m.array, x = 0, b = y.length - 1; x < b; x += f) {
                                        var w = y[x]
                                          , _ = y[x + 1];
                                        l.fromArray(v, 3 * w),
                                        u.fromArray(v, 3 * _);
                                        var M = e.distanceSqToSegment(l, u, d, p);
                                        if (!(M > a)) {
                                            d.applyMatrix4(this.matrixWorld);
                                            var S = i.ray.origin.distanceTo(d);
                                            S < i.near || S > i.far || n.push({
                                                distance: S,
                                                point: p.clone().applyMatrix4(this.matrixWorld),
                                                index: x,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    }
                                else
                                    for (var x = 0, b = v.length / 3 - 1; x < b; x += f) {
                                        l.fromArray(v, 3 * x),
                                        u.fromArray(v, 3 * x + 3);
                                        var M = e.distanceSqToSegment(l, u, d, p);
                                        if (!(M > a)) {
                                            d.applyMatrix4(this.matrixWorld);
                                            var S = i.ray.origin.distanceTo(d);
                                            S < i.near || S > i.far || n.push({
                                                distance: S,
                                                point: p.clone().applyMatrix4(this.matrixWorld),
                                                index: x,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    }
                            } else if (h && h.isGeometry)
                                for (var E = h.vertices, T = E.length, x = 0; x < T - 1; x += f) {
                                    var M = e.distanceSqToSegment(E[x], E[x + 1], d, p);
                                    if (!(M > a)) {
                                        d.applyMatrix4(this.matrixWorld);
                                        var S = i.ray.origin.distanceTo(d);
                                        S < i.near || S > i.far || n.push({
                                            distance: S,
                                            point: p.clone().applyMatrix4(this.matrixWorld),
                                            index: x,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry,this.material).copy(this)
                }
            }),
            _e.prototype = Object.assign(Object.create(we.prototype), {
                constructor: _e,
                isLineSegments: !0
            }),
            Me.prototype = Object.create(Q.prototype),
            Me.prototype.constructor = Me,
            Me.prototype.isPointsMaterial = !0,
            Me.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.color.copy(t.color),
                this.map = t.map,
                this.size = t.size,
                this.sizeAttenuation = t.sizeAttenuation,
                this
            }
            ,
            Se.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: Se,
                isPoints: !0,
                raycast: function() {
                    var t = new o
                      , e = new $t
                      , r = new rt;
                    return function(i, n) {
                        function o(t, r) {
                            var o = e.distanceSqToPoint(t);
                            if (o < p) {
                                var s = e.closestPointToPoint(t);
                                s.applyMatrix4(c);
                                var h = i.ray.origin.distanceTo(s);
                                if (h < i.near || h > i.far)
                                    return;
                                n.push({
                                    distance: h,
                                    distanceToRay: Math.sqrt(o),
                                    point: s.clone(),
                                    index: r,
                                    face: null,
                                    object: a
                                })
                            }
                        }
                        var a = this
                          , h = this.geometry
                          , c = this.matrixWorld
                          , l = i.params.Points.threshold;
                        if (null === h.boundingSphere && h.computeBoundingSphere(),
                        r.copy(h.boundingSphere),
                        r.applyMatrix4(c),
                        i.ray.intersectsSphere(r) !== !1) {
                            t.getInverse(c),
                            e.copy(i.ray).applyMatrix4(t);
                            var u = l / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                              , p = u * u
                              , d = new s;
                            if (h && h.isBufferGeometry) {
                                var f = h.index
                                  , m = h.attributes
                                  , g = m.position.array;
                                if (null !== f)
                                    for (var v = f.array, y = 0, x = v.length; y < x; y++) {
                                        var b = v[y];
                                        d.fromArray(g, 3 * b),
                                        o(d, b)
                                    }
                                else
                                    for (var y = 0, w = g.length / 3; y < w; y++)
                                        d.fromArray(g, 3 * y),
                                        o(d, y)
                            } else
                                for (var _ = h.vertices, y = 0, w = _.length; y < w; y++)
                                    o(_[y], y)
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry,this.material).copy(this)
                }
            }),
            Ee.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: Ee
            }),
            Te.prototype = Object.create(i.prototype),
            Te.prototype.constructor = Te,
            Ae.prototype = Object.create(i.prototype),
            Ae.prototype.constructor = Ae,
            Ae.prototype.isCompressedTexture = !0,
            Le.prototype = Object.create(i.prototype),
            Le.prototype.constructor = Le,
            Ce.prototype = Object.create(i.prototype),
            Ce.prototype.constructor = Ce,
            Ce.prototype.isDepthTexture = !0,
            Re.prototype = Object.create(K.prototype),
            Re.prototype.constructor = Re,
            Re.prototype.isShadowMaterial = !0,
            Pe.prototype = Object.create(K.prototype),
            Pe.prototype.constructor = Pe,
            Pe.prototype.isRawShaderMaterial = !0,
            Ue.prototype = {
                constructor: Ue,
                isMultiMaterial: !0,
                toJSON: function(t) {
                    for (var e = {
                        metadata: {
                            version: 4.2,
                            type: "material",
                            generator: "MaterialExporter"
                        },
                        uuid: this.uuid,
                        type: this.type,
                        materials: []
                    }, r = this.materials, i = 0, n = r.length; i < n; i++) {
                        var o = r[i].toJSON(t);
                        delete o.metadata,
                        e.materials.push(o)
                    }
                    return e.visible = this.visible,
                    e
                },
                clone: function() {
                    for (var t = new this.constructor, e = 0; e < this.materials.length; e++)
                        t.materials.push(this.materials[e].clone());
                    return t.visible = this.visible,
                    t
                }
            },
            Ie.prototype = Object.create(Q.prototype),
            Ie.prototype.constructor = Ie,
            Ie.prototype.isMeshStandardMaterial = !0,
            Ie.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(t.color),
                this.roughness = t.roughness,
                this.metalness = t.metalness,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.roughnessMap = t.roughnessMap,
                this.metalnessMap = t.metalnessMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.envMapIntensity = t.envMapIntensity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this
            }
            ,
            De.prototype = Object.create(Ie.prototype),
            De.prototype.constructor = De,
            De.prototype.isMeshPhysicalMaterial = !0,
            De.prototype.copy = function(t) {
                return Ie.prototype.copy.call(this, t),
                this.defines = {
                    PHYSICAL: ""
                },
                this.reflectivity = t.reflectivity,
                this.clearCoat = t.clearCoat,
                this.clearCoatRoughness = t.clearCoatRoughness,
                this
            }
            ,
            Oe.prototype = Object.create(Q.prototype),
            Oe.prototype.constructor = Oe,
            Oe.prototype.isMeshPhongMaterial = !0,
            Oe.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.color.copy(t.color),
                this.specular.copy(t.specular),
                this.shininess = t.shininess,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this
            }
            ,
            Ne.prototype = Object.create(Q.prototype),
            Ne.prototype.constructor = Ne,
            Ne.prototype.isMeshNormalMaterial = !0,
            Ne.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this
            }
            ,
            Be.prototype = Object.create(Q.prototype),
            Be.prototype.constructor = Be,
            Be.prototype.isMeshLambertMaterial = !0,
            Be.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this
            }
            ,
            Fe.prototype = Object.create(Q.prototype),
            Fe.prototype.constructor = Fe,
            Fe.prototype.isLineDashedMaterial = !0,
            Fe.prototype.copy = function(t) {
                return Q.prototype.copy.call(this, t),
                this.color.copy(t.color),
                this.linewidth = t.linewidth,
                this.scale = t.scale,
                this.dashSize = t.dashSize,
                this.gapSize = t.gapSize,
                this
            }
            ,
            t.Cache = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    this.enabled !== !1 && (this.files[t] = e)
                },
                get: function(t) {
                    if (this.enabled !== !1)
                        return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            },
            t.DefaultLoadingManager = new ke,
            Object.assign(ze.prototype, {
                load: function(e, r, i, n) {
                    void 0 !== this.path && (e = this.path + e);
                    var o = this
                      , a = t.Cache.get(e);
                    if (void 0 !== a)
                        return o.manager.itemStart(e),
                        setTimeout(function() {
                            r && r(a),
                            o.manager.itemEnd(e)
                        }, 0),
                        a;
                    var s = new XMLHttpRequest;
                    return s.open("GET", e, !0),
                    s.addEventListener("load", function(i) {
                        var a = i.target.response;
                        t.Cache.add(e, a),
                        200 === this.status ? (r && r(a),
                        o.manager.itemEnd(e)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."),
                        r && r(a),
                        o.manager.itemEnd(e)) : (n && n(i),
                        o.manager.itemError(e))
                    }, !1),
                    void 0 !== i && s.addEventListener("progress", function(t) {
                        i(t)
                    }, !1),
                    s.addEventListener("error", function(t) {
                        n && n(t),
                        o.manager.itemError(e)
                    }, !1),
                    void 0 !== this.responseType && (s.responseType = this.responseType),
                    void 0 !== this.withCredentials && (s.withCredentials = this.withCredentials),
                    s.overrideMimeType && s.overrideMimeType("text/plain"),
                    s.send(null),
                    o.manager.itemStart(e),
                    s
                },
                setPath: function(t) {
                    return this.path = t,
                    this
                },
                setResponseType: function(t) {
                    return this.responseType = t,
                    this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t,
                    this
                }
            }),
            Object.assign(Ve.prototype, {
                load: function(t, e, r, i) {
                    function n(n) {
                        h.load(t[n], function(t) {
                            var r = o._parser(t, !0);
                            a[n] = {
                                width: r.width,
                                height: r.height,
                                format: r.format,
                                mipmaps: r.mipmaps
                            },
                            c += 1,
                            6 === c && (1 === r.mipmapCount && (s.minFilter = To),
                            s.format = r.format,
                            s.needsUpdate = !0,
                            e && e(s))
                        }, r, i)
                    }
                    var o = this
                      , a = []
                      , s = new Ae;
                    s.image = a;
                    var h = new ze(this.manager);
                    if (h.setPath(this.path),
                    h.setResponseType("arraybuffer"),
                    Array.isArray(t))
                        for (var c = 0, l = 0, u = t.length; l < u; ++l)
                            n(l);
                    else
                        h.load(t, function(t) {
                            var r = o._parser(t, !0);
                            if (r.isCubemap)
                                for (var i = r.mipmaps.length / r.mipmapCount, n = 0; n < i; n++) {
                                    a[n] = {
                                        mipmaps: []
                                    };
                                    for (var h = 0; h < r.mipmapCount; h++)
                                        a[n].mipmaps.push(r.mipmaps[n * r.mipmapCount + h]),
                                        a[n].format = r.format,
                                        a[n].width = r.width,
                                        a[n].height = r.height
                                }
                            else
                                s.image.width = r.width,
                                s.image.height = r.height,
                                s.mipmaps = r.mipmaps;
                            1 === r.mipmapCount && (s.minFilter = To),
                            s.format = r.format,
                            s.needsUpdate = !0,
                            e && e(s)
                        }, r, i);
                    return s
                },
                setPath: function(t) {
                    return this.path = t,
                    this
                }
            });
            var Nh = Ge;
            Object.assign(Ge.prototype, {
                load: function(t, e, r, i) {
                    var n = this
                      , o = new ge
                      , a = new ze(this.manager);
                    return a.setResponseType("arraybuffer"),
                    a.load(t, function(t) {
                        var r = n._parser(t);
                        r && (void 0 !== r.image ? o.image = r.image : void 0 !== r.data && (o.image.width = r.width,
                        o.image.height = r.height,
                        o.image.data = r.data),
                        o.wrapS = void 0 !== r.wrapS ? r.wrapS : wo,
                        o.wrapT = void 0 !== r.wrapT ? r.wrapT : wo,
                        o.magFilter = void 0 !== r.magFilter ? r.magFilter : To,
                        o.minFilter = void 0 !== r.minFilter ? r.minFilter : Lo,
                        o.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1,
                        void 0 !== r.format && (o.format = r.format),
                        void 0 !== r.type && (o.type = r.type),
                        void 0 !== r.mipmaps && (o.mipmaps = r.mipmaps),
                        1 === r.mipmapCount && (o.minFilter = To),
                        o.needsUpdate = !0,
                        e && e(o, r))
                    }, r, i),
                    o
                }
            }),
            Object.assign(je.prototype, {
                load: function(t, e, r, i) {
                    var n = this
                      , o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    if (o.onload = function() {
                        URL.revokeObjectURL(o.src),
                        e && e(o),
                        n.manager.itemEnd(t)
                    }
                    ,
                    0 === t.indexOf("data:"))
                        o.src = t;
                    else {
                        var a = new ze;
                        a.setPath(this.path),
                        a.setResponseType("blob"),
                        a.setWithCredentials(this.withCredentials),
                        a.load(t, function(t) {
                            o.src = URL.createObjectURL(t)
                        }, r, i)
                    }
                    return n.manager.itemStart(t),
                    o
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t,
                    this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t,
                    this
                },
                setPath: function(t) {
                    return this.path = t,
                    this
                }
            }),
            Object.assign(He.prototype, {
                load: function(t, e, r, i) {
                    function n(r) {
                        a.load(t[r], function(t) {
                            o.images[r] = t,
                            s++,
                            6 === s && (o.needsUpdate = !0,
                            e && e(o))
                        }, void 0, i)
                    }
                    var o = new u
                      , a = new je(this.manager);
                    a.setCrossOrigin(this.crossOrigin),
                    a.setPath(this.path);
                    for (var s = 0, h = 0; h < t.length; ++h)
                        n(h);
                    return o
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t,
                    this
                },
                setPath: function(t) {
                    return this.path = t,
                    this
                }
            }),
            Object.assign(We.prototype, {
                load: function(t, e, r, n) {
                    var o = new i
                      , a = new je(this.manager);
                    return a.setCrossOrigin(this.crossOrigin),
                    a.setWithCredentials(this.withCredentials),
                    a.setPath(this.path),
                    a.load(t, function(r) {
                        var i = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        o.format = i ? Go : jo,
                        o.image = r,
                        o.needsUpdate = !0,
                        void 0 !== e && e(o)
                    }, r, n),
                    o
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t,
                    this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t,
                    this
                },
                setPath: function(t) {
                    return this.path = t,
                    this
                }
            }),
            Xe.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: Xe,
                isLight: !0,
                copy: function(t) {
                    return Bt.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this.intensity = t.intensity,
                    this
                },
                toJSON: function(t) {
                    var e = Bt.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(),
                    e.object.intensity = this.intensity,
                    void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                    void 0 !== this.distance && (e.object.distance = this.distance),
                    void 0 !== this.angle && (e.object.angle = this.angle),
                    void 0 !== this.decay && (e.object.decay = this.decay),
                    void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                    void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                    e
                }
            }),
            Ye.prototype = Object.assign(Object.create(Xe.prototype), {
                constructor: Ye,
                isHemisphereLight: !0,
                copy: function(t) {
                    return Xe.prototype.copy.call(this, t),
                    this.groundColor.copy(t.groundColor),
                    this
                }
            }),
            Object.assign(qe.prototype, {
                copy: function(t) {
                    return this.camera = t.camera.clone(),
                    this.bias = t.bias,
                    this.radius = t.radius,
                    this.mapSize.copy(t.mapSize),
                    this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = {};
                    return 0 !== this.bias && (t.bias = this.bias),
                    1 !== this.radius && (t.radius = this.radius),
                    512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                    t.camera = this.camera.toJSON(!1).object,
                    delete t.camera.matrix,
                    t
                }
            }),
            Ze.prototype = Object.assign(Object.create(qe.prototype), {
                constructor: Ze,
                isSpotLightShadow: !0,
                update: function(e) {
                    var r = 2 * t.Math.RAD2DEG * e.angle
                      , i = this.mapSize.width / this.mapSize.height
                      , n = e.distance || 500
                      , o = this.camera;
                    r === o.fov && i === o.aspect && n === o.far || (o.fov = r,
                    o.aspect = i,
                    o.far = n,
                    o.updateProjectionMatrix())
                }
            }),
            Qe.prototype = Object.assign(Object.create(Xe.prototype), {
                constructor: Qe,
                isSpotLight: !0,
                copy: function(t) {
                    return Xe.prototype.copy.call(this, t),
                    this.distance = t.distance,
                    this.angle = t.angle,
                    this.penumbra = t.penumbra,
                    this.decay = t.decay,
                    this.target = t.target.clone(),
                    this.shadow = t.shadow.clone(),
                    this
                }
            }),
            Je.prototype = Object.assign(Object.create(Xe.prototype), {
                constructor: Je,
                isPointLight: !0,
                copy: function(t) {
                    return Xe.prototype.copy.call(this, t),
                    this.distance = t.distance,
                    this.decay = t.decay,
                    this.shadow = t.shadow.clone(),
                    this
                }
            }),
            Ke.prototype = Object.assign(Object.create(qe.prototype), {
                constructor: Ke
            }),
            $e.prototype = Object.assign(Object.create(Xe.prototype), {
                constructor: $e,
                isDirectionalLight: !0,
                copy: function(t) {
                    return Xe.prototype.copy.call(this, t),
                    this.target = t.target.clone(),
                    this.shadow = t.shadow.clone(),
                    this
                }
            }),
            tr.prototype = Object.assign(Object.create(Xe.prototype), {
                constructor: tr,
                isAmbientLight: !0
            }),
            t.AnimationUtils = {
                arraySlice: function(e, r, i) {
                    return t.AnimationUtils.isTypedArray(e) ? new e.constructor(e.subarray(r, i)) : e.slice(r, i)
                },
                convertArray: function(t, e, r) {
                    return !t || !r && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                },
                getKeyframeOrder: function(t) {
                    function e(e, r) {
                        return t[e] - t[r]
                    }
                    for (var r = t.length, i = new Array(r), n = 0; n !== r; ++n)
                        i[n] = n;
                    return i.sort(e),
                    i
                },
                sortedArray: function(t, e, r) {
                    for (var i = t.length, n = new t.constructor(i), o = 0, a = 0; a !== i; ++o)
                        for (var s = r[o] * e, h = 0; h !== e; ++h)
                            n[a++] = t[s + h];
                    return n
                },
                flattenJSON: function(t, e, r, i) {
                    for (var n = 1, o = t[0]; void 0 !== o && void 0 === o[i]; )
                        o = t[n++];
                    if (void 0 !== o) {
                        var a = o[i];
                        if (void 0 !== a)
                            if (Array.isArray(a)) {
                                do
                                    a = o[i],
                                    void 0 !== a && (e.push(o.time),
                                    r.push.apply(r, a)),
                                    o = t[n++];
                                while (void 0 !== o)
                            } else if (void 0 !== a.toArray) {
                                do
                                    a = o[i],
                                    void 0 !== a && (e.push(o.time),
                                    a.toArray(r, r.length)),
                                    o = t[n++];
                                while (void 0 !== o)
                            } else
                                do
                                    a = o[i],
                                    void 0 !== a && (e.push(o.time),
                                    r.push(a)),
                                    o = t[n++];
                                while (void 0 !== o)
                    }
                }
            },
            er.prototype = {
                constructor: er,
                evaluate: function(t) {
                    var e = this.parameterPositions
                      , r = this._cachedIndex
                      , i = e[r]
                      , n = e[r - 1];
                    t: {
                        e: {
                            var o;
                            r: {
                                i: if (!(t < i)) {
                                    for (var a = r + 2; ; ) {
                                        if (void 0 === i) {
                                            if (t < n)
                                                break i;
                                            return r = e.length,
                                            this._cachedIndex = r,
                                            this.afterEnd_(r - 1, t, n)
                                        }
                                        if (r === a)
                                            break;
                                        if (n = i,
                                        i = e[++r],
                                        t < i)
                                            break e
                                    }
                                    o = e.length;
                                    break r
                                }
                                {
                                    if (t >= n)
                                        break t;
                                    var s = e[1];
                                    t < s && (r = 2,
                                    n = s);
                                    for (var a = r - 2; ; ) {
                                        if (void 0 === n)
                                            return this._cachedIndex = 0,
                                            this.beforeStart_(0, t, i);
                                        if (r === a)
                                            break;
                                        if (i = n,
                                        n = e[--r - 1],
                                        t >= n)
                                            break e
                                    }
                                    o = r,
                                    r = 0
                                }
                            }
                            for (; r < o; ) {
                                var h = r + o >>> 1;
                                t < e[h] ? o = h : r = h + 1
                            }
                            if (i = e[r],
                            n = e[r - 1],
                            void 0 === n)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, t, i);
                            if (void 0 === i)
                                return r = e.length,
                                this._cachedIndex = r,
                                this.afterEnd_(r - 1, n, t)
                        }
                        this._cachedIndex = r,
                        this.intervalChanged_(r, n, i)
                    }
                    return this.interpolate_(r, n, t, i)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(t) {
                    for (var e = this.resultBuffer, r = this.sampleValues, i = this.valueSize, n = t * i, o = 0; o !== i; ++o)
                        e[o] = r[n + o];
                    return e
                },
                interpolate_: function(t, e, r, i) {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function(t, e, r) {}
            },
            Object.assign(er.prototype, {
                beforeStart_: er.prototype.copySampleValue_,
                afterEnd_: er.prototype.copySampleValue_
            }),
            rr.prototype = Object.assign(Object.create(er.prototype), {
                constructor: rr,
                DefaultSettings_: {
                    endingStart: la,
                    endingEnd: la
                },
                intervalChanged_: function(t, e, r) {
                    var i = this.parameterPositions
                      , n = t - 2
                      , o = t + 1
                      , a = i[n]
                      , s = i[o];
                    if (void 0 === a)
                        switch (this.getSettings_().endingStart) {
                        case ua:
                            n = t,
                            a = 2 * e - r;
                            break;
                        case pa:
                            n = i.length - 2,
                            a = e + i[n] - i[n + 1];
                            break;
                        default:
                            n = t,
                            a = r
                        }
                    if (void 0 === s)
                        switch (this.getSettings_().endingEnd) {
                        case ua:
                            o = t,
                            s = 2 * r - e;
                            break;
                        case pa:
                            o = 1,
                            s = r + i[1] - i[0];
                            break;
                        default:
                            o = t - 1,
                            s = e
                        }
                    var h = .5 * (r - e)
                      , c = this.valueSize;
                    this._weightPrev = h / (e - a),
                    this._weightNext = h / (s - r),
                    this._offsetPrev = n * c,
                    this._offsetNext = o * c
                },
                interpolate_: function(t, e, r, i) {
                    for (var n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, h = s - a, c = this._offsetPrev, l = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (r - e) / (i - e), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p * m - p * f, b = 0; b !== a; ++b)
                        n[b] = g * o[c + b] + v * o[h + b] + y * o[s + b] + x * o[l + b];
                    return n
                }
            }),
            ir.prototype = Object.assign(Object.create(er.prototype), {
                constructor: ir,
                interpolate_: function(t, e, r, i) {
                    for (var n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, h = s - a, c = (r - e) / (i - e), l = 1 - c, u = 0; u !== a; ++u)
                        n[u] = o[h + u] * l + o[s + u] * c;
                    return n
                }
            }),
            nr.prototype = Object.assign(Object.create(er.prototype), {
                constructor: nr,
                interpolate_: function(t, e, r, i) {
                    return this.copySampleValue_(t - 1)
                }
            });
            var Bh;
            Bh = {
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: ha,
                InterpolantFactoryMethodDiscrete: function(t) {
                    return new nr(this.times,this.values,this.getValueSize(),t)
                },
                InterpolantFactoryMethodLinear: function(t) {
                    return new ir(this.times,this.values,this.getValueSize(),t)
                },
                InterpolantFactoryMethodSmooth: function(t) {
                    return new rr(this.times,this.values,this.getValueSize(),t)
                },
                setInterpolation: function(t) {
                    var e;
                    switch (t) {
                    case sa:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case ha:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case ca:
                        e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === e) {
                        var r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation)
                                throw new Error(r);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return void console.warn(r)
                    }
                    this.createInterpolant = e
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return sa;
                    case this.InterpolantFactoryMethodLinear:
                        return ha;
                    case this.InterpolantFactoryMethodSmooth:
                        return ca
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(t) {
                    if (0 !== t)
                        for (var e = this.times, r = 0, i = e.length; r !== i; ++r)
                            e[r] += t;
                    return this
                },
                scale: function(t) {
                    if (1 !== t)
                        for (var e = this.times, r = 0, i = e.length; r !== i; ++r)
                            e[r] *= t;
                    return this
                },
                trim: function(e, r) {
                    for (var i = this.times, n = i.length, o = 0, a = n - 1; o !== n && i[o] < e; )
                        ++o;
                    for (; a !== -1 && i[a] > r; )
                        --a;
                    if (++a,
                    0 !== o || a !== n) {
                        o >= a && (a = Math.max(a, 1),
                        o = a - 1);
                        var s = this.getValueSize();
                        this.times = t.AnimationUtils.arraySlice(i, o, a),
                        this.values = t.AnimationUtils.arraySlice(this.values, o * s, a * s)
                    }
                    return this
                },
                validate: function() {
                    var e = !0
                      , r = this.getValueSize();
                    r - Math.floor(r) !== 0 && (console.error("invalid value size in track", this),
                    e = !1);
                    var i = this.times
                      , n = this.values
                      , o = i.length;
                    0 === o && (console.error("track is empty", this),
                    e = !1);
                    for (var a = null, s = 0; s !== o; s++) {
                        var h = i[s];
                        if ("number" == typeof h && isNaN(h)) {
                            console.error("time is not a valid number", this, s, h),
                            e = !1;
                            break
                        }
                        if (null !== a && a > h) {
                            console.error("out of order keys", this, s, h, a),
                            e = !1;
                            break
                        }
                        a = h
                    }
                    if (void 0 !== n && t.AnimationUtils.isTypedArray(n))
                        for (var s = 0, c = n.length; s !== c; ++s) {
                            var l = n[s];
                            if (isNaN(l)) {
                                console.error("value is not a valid number", this, s, l),
                                e = !1;
                                break
                            }
                        }
                    return e
                },
                optimize: function() {
                    for (var e = this.times, r = this.values, i = this.getValueSize(), n = 1, o = 1, a = e.length - 1; o <= a; ++o) {
                        var s = !1
                          , h = e[o]
                          , c = e[o + 1];
                        if (h !== c && (1 !== o || h !== h[0]))
                            for (var l = o * i, u = l - i, p = l + i, d = 0; d !== i; ++d) {
                                var f = r[l + d];
                                if (f !== r[u + d] || f !== r[p + d]) {
                                    s = !0;
                                    break
                                }
                            }
                        if (s) {
                            if (o !== n) {
                                e[n] = e[o];
                                for (var m = o * i, g = n * i, d = 0; d !== i; ++d)
                                    r[g + d] = r[m + d]
                            }
                            ++n
                        }
                    }
                    return n !== e.length && (this.times = t.AnimationUtils.arraySlice(e, 0, n),
                    this.values = t.AnimationUtils.arraySlice(r, 0, n * i)),
                    this
                }
            },
            ar.prototype = Object.assign(Object.create(Bh), {
                constructor: ar,
                ValueTypeName: "vector"
            }),
            sr.prototype = Object.assign(Object.create(er.prototype), {
                constructor: sr,
                interpolate_: function(t, e, r, i) {
                    for (var n = this.resultBuffer, o = this.sampleValues, s = this.valueSize, h = t * s, c = (r - e) / (i - e), l = h + s; h !== l; h += 4)
                        a.slerpFlat(n, 0, o, h - s, o, h, c);
                    return n
                }
            }),
            hr.prototype = Object.assign(Object.create(Bh), {
                constructor: hr,
                ValueTypeName: "quaternion",
                DefaultInterpolation: ha,
                InterpolantFactoryMethodLinear: function(t) {
                    return new sr(this.times,this.values,this.getValueSize(),t)
                },
                InterpolantFactoryMethodSmooth: void 0
            }),
            cr.prototype = Object.assign(Object.create(Bh), {
                constructor: cr,
                ValueTypeName: "number"
            }),
            lr.prototype = Object.assign(Object.create(Bh), {
                constructor: lr,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: sa,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }),
            ur.prototype = Object.assign(Object.create(Bh), {
                constructor: ur,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: sa,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }),
            pr.prototype = Object.assign(Object.create(Bh), {
                constructor: pr,
                ValueTypeName: "color"
            }),
            dr.prototype = Bh,
            Bh.constructor = dr,
            Object.assign(dr, {
                parse: function(e) {
                    if (void 0 === e.type)
                        throw new Error("track type undefined, can not parse");
                    var r = dr._getTrackTypeForValueTypeName(e.type);
                    if (void 0 === e.times) {
                        var i = []
                          , n = [];
                        t.AnimationUtils.flattenJSON(e.keys, i, n, "value"),
                        e.times = i,
                        e.values = n
                    }
                    return void 0 !== r.parse ? r.parse(e) : new r(e.name,e.times,e.values,e.interpolation)
                },
                toJSON: function(e) {
                    var r, i = e.constructor;
                    if (void 0 !== i.toJSON)
                        r = i.toJSON(e);
                    else {
                        r = {
                            name: e.name,
                            times: t.AnimationUtils.convertArray(e.times, Array),
                            values: t.AnimationUtils.convertArray(e.values, Array)
                        };
                        var n = e.getInterpolation();
                        n !== e.DefaultInterpolation && (r.interpolation = n)
                    }
                    return r.type = e.ValueTypeName,
                    r
                },
                _getTrackTypeForValueTypeName: function(t) {
                    switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return cr;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return ar;
                    case "color":
                        return pr;
                    case "quaternion":
                        return hr;
                    case "bool":
                    case "boolean":
                        return ur;
                    case "string":
                        return lr
                    }
                    throw new Error("Unsupported typeName: " + t)
                }
            }),
            fr.prototype = {
                constructor: fr,
                resetDuration: function() {
                    for (var t = this.tracks, e = 0, r = 0, i = t.length; r !== i; ++r) {
                        var n = this.tracks[r];
                        e = Math.max(e, n.times[n.times.length - 1])
                    }
                    this.duration = e
                },
                trim: function() {
                    for (var t = 0; t < this.tracks.length; t++)
                        this.tracks[t].trim(0, this.duration);
                    return this
                },
                optimize: function() {
                    for (var t = 0; t < this.tracks.length; t++)
                        this.tracks[t].optimize();
                    return this
                }
            },
            Object.assign(fr, {
                parse: function(t) {
                    for (var e = [], r = t.tracks, i = 1 / (t.fps || 1), n = 0, o = r.length; n !== o; ++n)
                        e.push(dr.parse(r[n]).scale(i));
                    return new fr(t.name,t.duration,e)
                },
                toJSON: function(t) {
                    for (var e = [], r = t.tracks, i = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e
                    }, n = 0, o = r.length; n !== o; ++n)
                        e.push(dr.toJSON(r[n]));
                    return i
                },
                CreateFromMorphTargetSequence: function(e, r, i, n) {
                    for (var o = r.length, a = [], s = 0; s < o; s++) {
                        var h = []
                          , c = [];
                        h.push((s + o - 1) % o, s, (s + 1) % o),
                        c.push(0, 1, 0);
                        var l = t.AnimationUtils.getKeyframeOrder(h);
                        h = t.AnimationUtils.sortedArray(h, 1, l),
                        c = t.AnimationUtils.sortedArray(c, 1, l),
                        n || 0 !== h[0] || (h.push(o),
                        c.push(c[0])),
                        a.push(new cr(".morphTargetInfluences[" + r[s].name + "]",h,c).scale(1 / i))
                    }
                    return new fr(e,(-1),a)
                },
                findByName: function(t, e) {
                    var r = t;
                    if (!Array.isArray(t)) {
                        var i = t;
                        r = i.geometry && i.geometry.animations || i.animations
                    }
                    for (var n = 0; n < r.length; n++)
                        if (r[n].name === e)
                            return r[n];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(t, e, r) {
                    for (var i = {}, n = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                        var s = t[o]
                          , h = s.name.match(n);
                        if (h && h.length > 1) {
                            var c = h[1]
                              , l = i[c];
                            l || (i[c] = l = []),
                            l.push(s)
                        }
                    }
                    var u = [];
                    for (var c in i)
                        u.push(fr.CreateFromMorphTargetSequence(c, i[c], e, r));
                    return u
                },
                parseAnimation: function(e, r, i) {
                    if (!e)
                        return console.error("  no animation in JSONLoader data"),
                        null;
                    for (var n = function(e, r, i, n, o) {
                        if (0 !== i.length) {
                            var a = []
                              , s = [];
                            t.AnimationUtils.flattenJSON(i, a, s, n),
                            0 !== a.length && o.push(new e(r,a,s))
                        }
                    }, o = [], a = e.name || "default", s = e.length || -1, h = e.fps || 30, c = e.hierarchy || [], l = 0; l < c.length; l++) {
                        var u = c[l].keys;
                        if (u && 0 !== u.length)
                            if (u[0].morphTargets) {
                                for (var p = {}, d = 0; d < u.length; d++)
                                    if (u[d].morphTargets)
                                        for (var f = 0; f < u[d].morphTargets.length; f++)
                                            p[u[d].morphTargets[f]] = -1;
                                for (var m in p) {
                                    for (var g = [], v = [], f = 0; f !== u[d].morphTargets.length; ++f) {
                                        var y = u[d];
                                        g.push(y.time),
                                        v.push(y.morphTarget === m ? 1 : 0)
                                    }
                                    o.push(new cr(".morphTargetInfluence[" + m + "]",g,v))
                                }
                                s = p.length * (h || 1)
                            } else {
                                var x = ".bones[" + r[l].name + "]";
                                n(ar, x + ".position", u, "pos", o),
                                n(hr, x + ".quaternion", u, "rot", o),
                                n(ar, x + ".scale", u, "scl", o)
                            }
                    }
                    if (0 === o.length)
                        return null;
                    var b = new fr(a,s,o);
                    return b
                }
            }),
            Object.assign(mr.prototype, {
                load: function(t, e, r, i) {
                    var n = this
                      , o = new ze(n.manager);
                    o.load(t, function(t) {
                        e(n.parse(JSON.parse(t)))
                    }, r, i)
                },
                setTextures: function(t) {
                    this.textures = t
                },
                parse: function(t) {
                    function e(t) {
                        return void 0 === i[t] && console.warn("THREE.MaterialLoader: Undefined texture", t),
                        i[t]
                    }
                    var i = this.textures
                      , n = new THREE[t.type];
                    if (void 0 !== t.uuid && (n.uuid = t.uuid),
                    void 0 !== t.name && (n.name = t.name),
                    void 0 !== t.color && n.color.setHex(t.color),
                    void 0 !== t.roughness && (n.roughness = t.roughness),
                    void 0 !== t.metalness && (n.metalness = t.metalness),
                    void 0 !== t.emissive && n.emissive.setHex(t.emissive),
                    void 0 !== t.specular && n.specular.setHex(t.specular),
                    void 0 !== t.shininess && (n.shininess = t.shininess),
                    void 0 !== t.uniforms && (n.uniforms = t.uniforms),
                    void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader),
                    void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader),
                    void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors),
                    void 0 !== t.fog && (n.fog = t.fog),
                    void 0 !== t.shading && (n.shading = t.shading),
                    void 0 !== t.blending && (n.blending = t.blending),
                    void 0 !== t.side && (n.side = t.side),
                    void 0 !== t.opacity && (n.opacity = t.opacity),
                    void 0 !== t.transparent && (n.transparent = t.transparent),
                    void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest),
                    void 0 !== t.depthTest && (n.depthTest = t.depthTest),
                    void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite),
                    void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite),
                    void 0 !== t.wireframe && (n.wireframe = t.wireframe),
                    void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth),
                    void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap),
                    void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin),
                    void 0 !== t.skinning && (n.skinning = t.skinning),
                    void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets),
                    void 0 !== t.size && (n.size = t.size),
                    void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation),
                    void 0 !== t.map && (n.map = e(t.map)),
                    void 0 !== t.alphaMap && (n.alphaMap = e(t.alphaMap),
                    n.transparent = !0),
                    void 0 !== t.bumpMap && (n.bumpMap = e(t.bumpMap)),
                    void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale),
                    void 0 !== t.normalMap && (n.normalMap = e(t.normalMap)),
                    void 0 !== t.normalScale) {
                        var o = t.normalScale;
                        Array.isArray(o) === !1 && (o = [o, o]),
                        n.normalScale = (new r).fromArray(o)
                    }
                    if (void 0 !== t.displacementMap && (n.displacementMap = e(t.displacementMap)),
                    void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale),
                    void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias),
                    void 0 !== t.roughnessMap && (n.roughnessMap = e(t.roughnessMap)),
                    void 0 !== t.metalnessMap && (n.metalnessMap = e(t.metalnessMap)),
                    void 0 !== t.emissiveMap && (n.emissiveMap = e(t.emissiveMap)),
                    void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity),
                    void 0 !== t.specularMap && (n.specularMap = e(t.specularMap)),
                    void 0 !== t.envMap && (n.envMap = e(t.envMap)),
                    void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity),
                    void 0 !== t.lightMap && (n.lightMap = e(t.lightMap)),
                    void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity),
                    void 0 !== t.aoMap && (n.aoMap = e(t.aoMap)),
                    void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity),
                    void 0 !== t.materials)
                        for (var a = 0, s = t.materials.length; a < s; a++)
                            n.materials.push(this.parse(t.materials[a]));
                    return n
                }
            }),
            Object.assign(gr.prototype, {
                load: function(t, e, r, i) {
                    var n = this
                      , o = new ze(n.manager);
                    o.load(t, function(t) {
                        e(n.parse(JSON.parse(t)))
                    }, r, i)
                },
                parse: function(t) {
                    var e = new Gt
                      , r = t.data.index
                      , i = {
                        Int8Array: Int8Array,
                        Uint8Array: Uint8Array,
                        Uint8ClampedArray: Uint8ClampedArray,
                        Int16Array: Int16Array,
                        Uint16Array: Uint16Array,
                        Int32Array: Int32Array,
                        Uint32Array: Uint32Array,
                        Float32Array: Float32Array,
                        Float64Array: Float64Array
                    };
                    if (void 0 !== r) {
                        var n = new i[r.type](r.array);
                        e.setIndex(new Mt(n,1))
                    }
                    var o = t.data.attributes;
                    for (var a in o) {
                        var h = o[a]
                          , n = new i[h.type](h.array);
                        e.addAttribute(a, new Mt(n,h.itemSize,h.normalized))
                    }
                    var c = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== c)
                        for (var l = 0, u = c.length; l !== u; ++l) {
                            var p = c[l];
                            e.addGroup(p.start, p.count, p.materialIndex)
                        }
                    var d = t.data.boundingSphere;
                    if (void 0 !== d) {
                        var f = new s;
                        void 0 !== d.center && f.fromArray(d.center),
                        e.boundingSphere = new rt(f,d.radius)
                    }
                    return e
                }
            }),
            vr.prototype = {
                constructor: vr,
                crossOrigin: void 0,
                extractUrlBase: function(t) {
                    var e = t.split("/");
                    return 1 === e.length ? "./" : (e.pop(),
                    e.join("/") + "/")
                },
                initMaterials: function(t, e, r) {
                    for (var i = [], n = 0; n < t.length; ++n)
                        i[n] = this.createMaterial(t[n], e, r);
                    return i
                },
                createMaterial: function() {
                    var e, r, i;
                    return function(n, o, a) {
                        function s(e, i, n, s, c) {
                            var l, u = o + e, p = vr.Handlers.get(u);
                            null !== p ? l = p.load(u) : (r.setCrossOrigin(a),
                            l = r.load(u)),
                            void 0 !== i && (l.repeat.fromArray(i),
                            1 !== i[0] && (l.wrapS = bo),
                            1 !== i[1] && (l.wrapT = bo)),
                            void 0 !== n && l.offset.fromArray(n),
                            void 0 !== s && ("repeat" === s[0] && (l.wrapS = bo),
                            "mirror" === s[0] && (l.wrapS = _o),
                            "repeat" === s[1] && (l.wrapT = bo),
                            "mirror" === s[1] && (l.wrapT = _o)),
                            void 0 !== c && (l.anisotropy = c);
                            var d = t.Math.generateUUID();
                            return h[d] = l,
                            d
                        }
                        void 0 === e && (e = new $),
                        void 0 === r && (r = new We),
                        void 0 === i && (i = new mr);
                        var h = {}
                          , c = {
                            uuid: t.Math.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                        for (var l in n) {
                            var u = n[l];
                            switch (l) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                c.name = u;
                                break;
                            case "blending":
                                c.blending = THREE[u];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                                break;
                            case "colorDiffuse":
                                c.color = e.fromArray(u).getHex();
                                break;
                            case "colorSpecular":
                                c.specular = e.fromArray(u).getHex();
                                break;
                            case "colorEmissive":
                                c.emissive = e.fromArray(u).getHex();
                                break;
                            case "specularCoef":
                                c.shininess = u;
                                break;
                            case "shading":
                                "basic" === u.toLowerCase() && (c.type = "MeshBasicMaterial"),
                                "phong" === u.toLowerCase() && (c.type = "MeshPhongMaterial"),
                                "standard" === u.toLowerCase() && (c.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                c.map = s(u, n.mapDiffuseRepeat, n.mapDiffuseOffset, n.mapDiffuseWrap, n.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                c.emissiveMap = s(u, n.mapEmissiveRepeat, n.mapEmissiveOffset, n.mapEmissiveWrap, n.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                c.lightMap = s(u, n.mapLightRepeat, n.mapLightOffset, n.mapLightWrap, n.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                c.aoMap = s(u, n.mapAORepeat, n.mapAOOffset, n.mapAOWrap, n.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                c.bumpMap = s(u, n.mapBumpRepeat, n.mapBumpOffset, n.mapBumpWrap, n.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                c.bumpScale = u;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                c.normalMap = s(u, n.mapNormalRepeat, n.mapNormalOffset, n.mapNormalWrap, n.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                c.normalScale = [u, u];
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                c.specularMap = s(u, n.mapSpecularRepeat, n.mapSpecularOffset, n.mapSpecularWrap, n.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                c.metalnessMap = s(u, n.mapMetalnessRepeat, n.mapMetalnessOffset, n.mapMetalnessWrap, n.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                c.roughnessMap = s(u, n.mapRoughnessRepeat, n.mapRoughnessOffset, n.mapRoughnessWrap, n.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                c.alphaMap = s(u, n.mapAlphaRepeat, n.mapAlphaOffset, n.mapAlphaWrap, n.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                c.side = bn;
                                break;
                            case "doubleSided":
                                c.side = wn;
                                break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                                c.opacity = u;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                c[l] = u;
                                break;
                            case "vertexColors":
                                u === !0 && (c.vertexColors = Tn),
                                "face" === u && (c.vertexColors = En);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", l, u)
                            }
                        }
                        return "MeshBasicMaterial" === c.type && delete c.emissive,
                        "MeshPhongMaterial" !== c.type && delete c.specular,
                        c.opacity < 1 && (c.transparent = !0),
                        i.setTextures(h),
                        i.parse(c)
                    }
                }()
            },
            vr.Handlers = {
                handlers: [],
                add: function(t, e) {
                    this.handlers.push(t, e)
                },
                get: function(t) {
                    for (var e = this.handlers, r = 0, i = e.length; r < i; r += 2) {
                        var n = e[r]
                          , o = e[r + 1];
                        if (n.test(t))
                            return o
                    }
                    return null
                }
            },
            Object.assign(yr.prototype, {
                load: function(t, e, r, i) {
                    var n = this
                      , o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : vr.prototype.extractUrlBase(t)
                      , a = new ze(this.manager);
                    a.setWithCredentials(this.withCredentials),
                    a.load(t, function(r) {
                        var i = JSON.parse(r)
                          , a = i.metadata;
                        if (void 0 !== a) {
                            var s = a.type;
                            if (void 0 !== s) {
                                if ("object" === s.toLowerCase())
                                    return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                                if ("scene" === s.toLowerCase())
                                    return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                            }
                        }
                        var h = n.parse(i, o);
                        e(h.geometry, h.materials)
                    }, r, i)
                },
                setTexturePath: function(t) {
                    this.texturePath = t
                },
                parse: function(t, e) {
                    function i(e) {
                        function i(t, e) {
                            return t & 1 << e
                        }
                        var n, o, a, c, l, u, p, d, f, m, g, v, y, x, b, w, _, M, S, E, T, A, L, C, R, P, U, I = t.faces, D = t.vertices, O = t.normals, N = t.colors, B = 0;
                        if (void 0 !== t.uvs) {
                            for (n = 0; n < t.uvs.length; n++)
                                t.uvs[n].length && B++;
                            for (n = 0; n < B; n++)
                                h.faceVertexUvs[n] = []
                        }
                        for (c = 0,
                        l = D.length; c < l; )
                            M = new s,
                            M.x = D[c++] * e,
                            M.y = D[c++] * e,
                            M.z = D[c++] * e,
                            h.vertices.push(M);
                        for (c = 0,
                        l = I.length; c < l; )
                            if (m = I[c++],
                            g = i(m, 0),
                            v = i(m, 1),
                            y = i(m, 3),
                            x = i(m, 4),
                            b = i(m, 5),
                            w = i(m, 6),
                            _ = i(m, 7),
                            g) {
                                if (E = new Dt,
                                E.a = I[c],
                                E.b = I[c + 1],
                                E.c = I[c + 3],
                                T = new Dt,
                                T.a = I[c + 1],
                                T.b = I[c + 2],
                                T.c = I[c + 3],
                                c += 4,
                                v && (f = I[c++],
                                E.materialIndex = f,
                                T.materialIndex = f),
                                a = h.faces.length,
                                y)
                                    for (n = 0; n < B; n++)
                                        for (C = t.uvs[n],
                                        h.faceVertexUvs[n][a] = [],
                                        h.faceVertexUvs[n][a + 1] = [],
                                        o = 0; o < 4; o++)
                                            d = I[c++],
                                            P = C[2 * d],
                                            U = C[2 * d + 1],
                                            R = new r(P,U),
                                            2 !== o && h.faceVertexUvs[n][a].push(R),
                                            0 !== o && h.faceVertexUvs[n][a + 1].push(R);
                                if (x && (p = 3 * I[c++],
                                E.normal.set(O[p++], O[p++], O[p]),
                                T.normal.copy(E.normal)),
                                b)
                                    for (n = 0; n < 4; n++)
                                        p = 3 * I[c++],
                                        L = new s(O[p++],O[p++],O[p]),
                                        2 !== n && E.vertexNormals.push(L),
                                        0 !== n && T.vertexNormals.push(L);
                                if (w && (u = I[c++],
                                A = N[u],
                                E.color.setHex(A),
                                T.color.setHex(A)),
                                _)
                                    for (n = 0; n < 4; n++)
                                        u = I[c++],
                                        A = N[u],
                                        2 !== n && E.vertexColors.push(new $(A)),
                                        0 !== n && T.vertexColors.push(new $(A));
                                h.faces.push(E),
                                h.faces.push(T)
                            } else {
                                if (S = new Dt,
                                S.a = I[c++],
                                S.b = I[c++],
                                S.c = I[c++],
                                v && (f = I[c++],
                                S.materialIndex = f),
                                a = h.faces.length,
                                y)
                                    for (n = 0; n < B; n++)
                                        for (C = t.uvs[n],
                                        h.faceVertexUvs[n][a] = [],
                                        o = 0; o < 3; o++)
                                            d = I[c++],
                                            P = C[2 * d],
                                            U = C[2 * d + 1],
                                            R = new r(P,U),
                                            h.faceVertexUvs[n][a].push(R);
                                if (x && (p = 3 * I[c++],
                                S.normal.set(O[p++], O[p++], O[p])),
                                b)
                                    for (n = 0; n < 3; n++)
                                        p = 3 * I[c++],
                                        L = new s(O[p++],O[p++],O[p]),
                                        S.vertexNormals.push(L);
                                if (w && (u = I[c++],
                                S.color.setHex(N[u])),
                                _)
                                    for (n = 0; n < 3; n++)
                                        u = I[c++],
                                        S.vertexColors.push(new $(N[u]));
                                h.faces.push(S)
                            }
                    }
                    function n() {
                        var e = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                        if (t.skinWeights)
                            for (var r = 0, i = t.skinWeights.length; r < i; r += e) {
                                var n = t.skinWeights[r]
                                  , o = e > 1 ? t.skinWeights[r + 1] : 0
                                  , a = e > 2 ? t.skinWeights[r + 2] : 0
                                  , s = e > 3 ? t.skinWeights[r + 3] : 0;
                                h.skinWeights.push(new Y(n,o,a,s))
                            }
                        if (t.skinIndices)
                            for (var r = 0, i = t.skinIndices.length; r < i; r += e) {
                                var c = t.skinIndices[r]
                                  , l = e > 1 ? t.skinIndices[r + 1] : 0
                                  , u = e > 2 ? t.skinIndices[r + 2] : 0
                                  , p = e > 3 ? t.skinIndices[r + 3] : 0;
                                h.skinIndices.push(new Y(c,l,u,p))
                            }
                        h.bones = t.bones,
                        h.bones && h.bones.length > 0 && (h.skinWeights.length !== h.skinIndices.length || h.skinIndices.length !== h.vertices.length) && console.warn("When skinning, number of vertices (" + h.vertices.length + "), skinIndices (" + h.skinIndices.length + "), and skinWeights (" + h.skinWeights.length + ") should match.")
                    }
                    function o(e) {
                        if (void 0 !== t.morphTargets)
                            for (var r = 0, i = t.morphTargets.length; r < i; r++) {
                                h.morphTargets[r] = {},
                                h.morphTargets[r].name = t.morphTargets[r].name,
                                h.morphTargets[r].vertices = [];
                                for (var n = h.morphTargets[r].vertices, o = t.morphTargets[r].vertices, a = 0, c = o.length; a < c; a += 3) {
                                    var l = new s;
                                    l.x = o[a] * e,
                                    l.y = o[a + 1] * e,
                                    l.z = o[a + 2] * e,
                                    n.push(l)
                                }
                            }
                        if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                            console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                            for (var u = h.faces, p = t.morphColors[0].colors, r = 0, i = u.length; r < i; r++)
                                u[r].color.fromArray(p, 3 * r)
                        }
                    }
                    function a() {
                        var e = []
                          , r = [];
                        void 0 !== t.animation && r.push(t.animation),
                        void 0 !== t.animations && (t.animations.length ? r = r.concat(t.animations) : r.push(t.animations));
                        for (var i = 0; i < r.length; i++) {
                            var n = fr.parseAnimation(r[i], h.bones);
                            n && e.push(n)
                        }
                        if (h.morphTargets) {
                            var o = fr.CreateClipsFromMorphTargetSequences(h.morphTargets, 10);
                            e = e.concat(o)
                        }
                        e.length > 0 && (h.animations = e)
                    }
                    var h = new kt
                      , c = void 0 !== t.scale ? 1 / t.scale : 1;
                    if (i(c),
                    n(),
                    o(c),
                    a(),
                    h.computeFaceNormals(),
                    h.computeBoundingSphere(),
                    void 0 === t.materials || 0 === t.materials.length)
                        return {
                            geometry: h
                        };
                    var l = vr.prototype.initMaterials(t.materials, e, this.crossOrigin);
                    return {
                        geometry: h,
                        materials: l
                    }
                }
            }),
            Object.assign(xr.prototype, {
                load: function(t, e, r, i) {
                    "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                    var n = this
                      , o = new ze(n.manager);
                    o.load(t, function(t) {
                        n.parse(JSON.parse(t), e)
                    }, r, i)
                },
                setTexturePath: function(t) {
                    this.texturePath = t
                },
                setCrossOrigin: function(t) {
                    this.crossOrigin = t
                },
                parse: function(t, e) {
                    var r = this.parseGeometries(t.geometries)
                      , i = this.parseImages(t.images, function() {
                        void 0 !== e && e(a)
                    })
                      , n = this.parseTextures(t.textures, i)
                      , o = this.parseMaterials(t.materials, n)
                      , a = this.parseObject(t.object, r, o);
                    return t.animations && (a.animations = this.parseAnimations(t.animations)),
                    void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(a),
                    a
                },
                parseGeometries: function(t) {
                    var e = {};
                    if (void 0 !== t)
                        for (var r = new yr, i = new gr, n = 0, o = t.length; n < o; n++) {
                            var a, s = t[n];
                            switch (s.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                a = new THREE[s.type](s.width,s.height,s.widthSegments,s.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                a = new THREE[s.type](s.width,s.height,s.depth,s.widthSegments,s.heightSegments,s.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                a = new THREE[s.type](s.radius,s.segments,s.thetaStart,s.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                a = new THREE[s.type](s.radiusTop,s.radiusBottom,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                a = new THREE[s.type](s.radius,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                a = new THREE[s.type](s.radius,s.widthSegments,s.heightSegments,s.phiStart,s.phiLength,s.thetaStart,s.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "IcosahedronGeometry":
                            case "OctahedronGeometry":
                            case "TetrahedronGeometry":
                                a = new THREE[s.type](s.radius,s.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                a = new THREE[s.type](s.innerRadius,s.outerRadius,s.thetaSegments,s.phiSegments,s.thetaStart,s.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                a = new THREE[s.type](s.radius,s.tube,s.radialSegments,s.tubularSegments,s.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                a = new THREE[s.type](s.radius,s.tube,s.tubularSegments,s.radialSegments,s.p,s.q);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                a = new THREE[s.type](s.points,s.segments,s.phiStart,s.phiLength);
                                break;
                            case "BufferGeometry":
                                a = i.parse(s);
                                break;
                            case "Geometry":
                                a = r.parse(s.data, this.texturePath).geometry;
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                continue
                            }
                            a.uuid = s.uuid,
                            void 0 !== s.name && (a.name = s.name),
                            e[s.uuid] = a
                        }
                    return e
                },
                parseMaterials: function(t, e) {
                    var r = {};
                    if (void 0 !== t) {
                        var i = new mr;
                        i.setTextures(e);
                        for (var n = 0, o = t.length; n < o; n++) {
                            var a = i.parse(t[n]);
                            r[a.uuid] = a
                        }
                    }
                    return r
                },
                parseAnimations: function(t) {
                    for (var e = [], r = 0; r < t.length; r++) {
                        var i = fr.parse(t[r]);
                        e.push(i)
                    }
                    return e
                },
                parseImages: function(t, e) {
                    function r(t) {
                        return i.manager.itemStart(t),
                        a.load(t, function() {
                            i.manager.itemEnd(t)
                        }, void 0, function() {
                            i.manager.itemError(t)
                        })
                    }
                    var i = this
                      , n = {};
                    if (void 0 !== t && t.length > 0) {
                        var o = new ke(e)
                          , a = new je(o);
                        a.setCrossOrigin(this.crossOrigin);
                        for (var s = 0, h = t.length; s < h; s++) {
                            var c = t[s]
                              , l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i.texturePath + c.url;
                            n[c.uuid] = r(l)
                        }
                    }
                    return n
                },
                parseTextures: function(t, e) {
                    function r(t) {
                        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t),
                        THREE[t])
                    }
                    var n = {};
                    if (void 0 !== t)
                        for (var o = 0, a = t.length; o < a; o++) {
                            var s = t[o];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
                            void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                            var h = new i(e[s.image]);
                            h.needsUpdate = !0,
                            h.uuid = s.uuid,
                            void 0 !== s.name && (h.name = s.name),
                            void 0 !== s.mapping && (h.mapping = r(s.mapping)),
                            void 0 !== s.offset && h.offset.fromArray(s.offset),
                            void 0 !== s.repeat && h.repeat.fromArray(s.repeat),
                            void 0 !== s.wrap && (h.wrapS = r(s.wrap[0]),
                            h.wrapT = r(s.wrap[1])),
                            void 0 !== s.minFilter && (h.minFilter = r(s.minFilter)),
                            void 0 !== s.magFilter && (h.magFilter = r(s.magFilter)),
                            void 0 !== s.anisotropy && (h.anisotropy = s.anisotropy),
                            void 0 !== s.flipY && (h.flipY = s.flipY),
                            n[s.uuid] = h
                        }
                    return n
                },
                parseObject: function() {
                    var t = new o;
                    return function(e, r, i) {
                        function n(t) {
                            return void 0 === r[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t),
                            r[t]
                        }
                        function o(t) {
                            if (void 0 !== t)
                                return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t),
                                i[t]
                        }
                        var a;
                        switch (e.type) {
                        case "Scene":
                            a = new ue,
                            void 0 !== e.background && Number.isInteger(e.background) && (a.background = new THREE.Color(e.background)),
                            void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new le(e.fog.color,e.fog.near,e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new ce(e.fog.color,e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            a = new ae(e.fov,e.aspect,e.near,e.far),
                            void 0 !== e.focus && (a.focus = e.focus),
                            void 0 !== e.zoom && (a.zoom = e.zoom),
                            void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge),
                            void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset),
                            void 0 !== e.view && (a.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            a = new se(e.left,e.right,e.top,e.bottom,e.near,e.far);
                            break;
                        case "AmbientLight":
                            a = new tr(e.color,e.intensity);
                            break;
                        case "DirectionalLight":
                            a = new $e(e.color,e.intensity);
                            break;
                        case "PointLight":
                            a = new Je(e.color,e.intensity,e.distance,e.decay);
                            break;
                        case "SpotLight":
                            a = new Qe(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                            break;
                        case "HemisphereLight":
                            a = new Ye(e.color,e.groundColor,e.intensity);
                            break;
                        case "Mesh":
                            var s = n(e.geometry)
                              , h = o(e.material);
                            a = s.bones && s.bones.length > 0 ? new xe(s,h) : new ie(s,h);
                            break;
                        case "LOD":
                            a = new me;
                            break;
                        case "Line":
                            a = new we(n(e.geometry),o(e.material),e.mode);
                            break;
                        case "LineSegments":
                            a = new _e(n(e.geometry),o(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            a = new Se(n(e.geometry),o(e.material));
                            break;
                        case "Sprite":
                            a = new fe(o(e.material));
                            break;
                        case "Group":
                            a = new Ee;
                            break;
                        default:
                            a = new Bt
                        }
                        if (a.uuid = e.uuid,
                        void 0 !== e.name && (a.name = e.name),
                        void 0 !== e.matrix ? (t.fromArray(e.matrix),
                        t.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position),
                        void 0 !== e.rotation && a.rotation.fromArray(e.rotation),
                        void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion),
                        void 0 !== e.scale && a.scale.fromArray(e.scale)),
                        void 0 !== e.castShadow && (a.castShadow = e.castShadow),
                        void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow),
                        e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias),
                        void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius),
                        void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize),
                        void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))),
                        void 0 !== e.visible && (a.visible = e.visible),
                        void 0 !== e.userData && (a.userData = e.userData),
                        void 0 !== e.children)
                            for (var c in e.children)
                                a.add(this.parseObject(e.children[c], r, i));
                        if ("LOD" === e.type)
                            for (var l = e.levels, u = 0; u < l.length; u++) {
                                var p = l[u]
                                  , c = a.getObjectByProperty("uuid", p.object);
                                void 0 !== c && a.addLevel(c, p.distance)
                            }
                        return a
                    }
                }()
            }),
            t.ShapeUtils = {
                area: function(t) {
                    for (var e = t.length, r = 0, i = e - 1, n = 0; n < e; i = n++)
                        r += t[i].x * t[n].y - t[n].x * t[i].y;
                    return .5 * r
                },
                triangulate: function() {
                    function e(t, e, r, i, n, o) {
                        var a, s, h, c, l, u, p, d, f;
                        if (s = t[o[e]].x,
                        h = t[o[e]].y,
                        c = t[o[r]].x,
                        l = t[o[r]].y,
                        u = t[o[i]].x,
                        p = t[o[i]].y,
                        Number.EPSILON > (c - s) * (p - h) - (l - h) * (u - s))
                            return !1;
                        var m, g, v, y, x, b, w, _, M, S, E, T, A, L, C;
                        for (m = u - c,
                        g = p - l,
                        v = s - u,
                        y = h - p,
                        x = c - s,
                        b = l - h,
                        a = 0; a < n; a++)
                            if (d = t[o[a]].x,
                            f = t[o[a]].y,
                            !(d === s && f === h || d === c && f === l || d === u && f === p) && (w = d - s,
                            _ = f - h,
                            M = d - c,
                            S = f - l,
                            E = d - u,
                            T = f - p,
                            C = m * S - g * M,
                            A = x * _ - b * w,
                            L = v * T - y * E,
                            C >= -Number.EPSILON && L >= -Number.EPSILON && A >= -Number.EPSILON))
                                return !1;
                        return !0
                    }
                    return function(r, i) {
                        var n = r.length;
                        if (n < 3)
                            return null;
                        var o, a, s, h = [], c = [], l = [];
                        if (t.ShapeUtils.area(r) > 0)
                            for (a = 0; a < n; a++)
                                c[a] = a;
                        else
                            for (a = 0; a < n; a++)
                                c[a] = n - 1 - a;
                        var u = n
                          , p = 2 * u;
                        for (a = u - 1; u > 2; ) {
                            if (p-- <= 0)
                                return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"),
                                i ? l : h;
                            if (o = a,
                            u <= o && (o = 0),
                            a = o + 1,
                            u <= a && (a = 0),
                            s = a + 1,
                            u <= s && (s = 0),
                            e(r, o, a, s, u, c)) {
                                var d, f, m, g, v;
                                for (d = c[o],
                                f = c[a],
                                m = c[s],
                                h.push([r[d], r[f], r[m]]),
                                l.push([c[o], c[a], c[s]]),
                                g = a,
                                v = a + 1; v < u; g++,
                                v++)
                                    c[g] = c[v];
                                u--,
                                p = 2 * u
                            }
                        }
                        return i ? l : h
                    }
                }(),
                triangulateShape: function(e, r) {
                    function i(t) {
                        var e = t.length;
                        e > 2 && t[e - 1].equals(t[0]) && t.pop()
                    }
                    function n(t, e, r) {
                        return t.x !== e.x ? t.x < e.x ? t.x <= r.x && r.x <= e.x : e.x <= r.x && r.x <= t.x : t.y < e.y ? t.y <= r.y && r.y <= e.y : e.y <= r.y && r.y <= t.y
                    }
                    function o(t, e, r, i, o) {
                        var a = e.x - t.x
                          , s = e.y - t.y
                          , h = i.x - r.x
                          , c = i.y - r.y
                          , l = t.x - r.x
                          , u = t.y - r.y
                          , p = s * h - a * c
                          , d = s * l - a * u;
                        if (Math.abs(p) > Number.EPSILON) {
                            var f;
                            if (p > 0) {
                                if (d < 0 || d > p)
                                    return [];
                                if (f = c * l - h * u,
                                f < 0 || f > p)
                                    return []
                            } else {
                                if (d > 0 || d < p)
                                    return [];
                                if (f = c * l - h * u,
                                f > 0 || f < p)
                                    return []
                            }
                            if (0 === f)
                                return !o || 0 !== d && d !== p ? [t] : [];
                            if (f === p)
                                return !o || 0 !== d && d !== p ? [e] : [];
                            if (0 === d)
                                return [r];
                            if (d === p)
                                return [i];
                            var m = f / p;
                            return [{
                                x: t.x + m * a,
                                y: t.y + m * s
                            }]
                        }
                        if (0 !== d || c * l !== h * u)
                            return [];
                        var g = 0 === a && 0 === s
                          , v = 0 === h && 0 === c;
                        if (g && v)
                            return t.x !== r.x || t.y !== r.y ? [] : [t];
                        if (g)
                            return n(r, i, t) ? [t] : [];
                        if (v)
                            return n(t, e, r) ? [r] : [];
                        var y, x, b, w, _, M, S, E;
                        return 0 !== a ? (t.x < e.x ? (y = t,
                        b = t.x,
                        x = e,
                        w = e.x) : (y = e,
                        b = e.x,
                        x = t,
                        w = t.x),
                        r.x < i.x ? (_ = r,
                        S = r.x,
                        M = i,
                        E = i.x) : (_ = i,
                        S = i.x,
                        M = r,
                        E = r.x)) : (t.y < e.y ? (y = t,
                        b = t.y,
                        x = e,
                        w = e.y) : (y = e,
                        b = e.y,
                        x = t,
                        w = t.y),
                        r.y < i.y ? (_ = r,
                        S = r.y,
                        M = i,
                        E = i.y) : (_ = i,
                        S = i.y,
                        M = r,
                        E = r.y)),
                        b <= S ? w < S ? [] : w === S ? o ? [] : [_] : w <= E ? [_, x] : [_, M] : b > E ? [] : b === E ? o ? [] : [y] : w <= E ? [y, x] : [y, M]
                    }
                    function a(t, e, r, i) {
                        var n = e.x - t.x
                          , o = e.y - t.y
                          , a = r.x - t.x
                          , s = r.y - t.y
                          , h = i.x - t.x
                          , c = i.y - t.y
                          , l = n * s - o * a
                          , u = n * c - o * h;
                        if (Math.abs(l) > Number.EPSILON) {
                            var p = h * s - c * a;
                            return l > 0 ? u >= 0 && p >= 0 : u >= 0 || p >= 0
                        }
                        return u > 0
                    }
                    function s(t, e) {
                        function r(t, e) {
                            var r = y.length - 1
                              , i = t - 1;
                            i < 0 && (i = r);
                            var n = t + 1;
                            n > r && (n = 0);
                            var o = a(y[t], y[i], y[n], s[e]);
                            if (!o)
                                return !1;
                            var h = s.length - 1
                              , c = e - 1;
                            c < 0 && (c = h);
                            var l = e + 1;
                            return l > h && (l = 0),
                            o = a(s[e], s[c], s[l], y[t]),
                            !!o
                        }
                        function i(t, e) {
                            var r, i, n;
                            for (r = 0; r < y.length; r++)
                                if (i = r + 1,
                                i %= y.length,
                                n = o(t, e, y[r], y[i], !0),
                                n.length > 0)
                                    return !0;
                            return !1
                        }
                        function n(t, r) {
                            var i, n, a, s, h;
                            for (i = 0; i < x.length; i++)
                                for (n = e[x[i]],
                                a = 0; a < n.length; a++)
                                    if (s = a + 1,
                                    s %= n.length,
                                    h = o(t, r, n[a], n[s], !0),
                                    h.length > 0)
                                        return !0;
                            return !1
                        }
                        for (var s, h, c, l, u, p, d, f, m, g, v, y = t.concat(), x = [], b = [], w = 0, _ = e.length; w < _; w++)
                            x.push(w);
                        for (var M = 0, S = 2 * x.length; x.length > 0; ) {
                            if (S--,
                            S < 0) {
                                console.log("Infinite Loop! Holes left:" + x.length + ", Probably Hole outside Shape!");
                                break
                            }
                            for (c = M; c < y.length; c++) {
                                l = y[c],
                                h = -1;
                                for (var w = 0; w < x.length; w++)
                                    if (p = x[w],
                                    d = l.x + ":" + l.y + ":" + p,
                                    void 0 === b[d]) {
                                        s = e[p];
                                        for (var E = 0; E < s.length; E++)
                                            if (u = s[E],
                                            r(c, E) && !i(l, u) && !n(l, u)) {
                                                h = E,
                                                x.splice(w, 1),
                                                f = y.slice(0, c + 1),
                                                m = y.slice(c),
                                                g = s.slice(h),
                                                v = s.slice(0, h + 1),
                                                y = f.concat(g).concat(v).concat(m),
                                                M = c;
                                                break
                                            }
                                        if (h >= 0)
                                            break;
                                        b[d] = !0
                                    }
                                if (h >= 0)
                                    break
                            }
                        }
                        return y
                    }
                    i(e),
                    r.forEach(i);
                    for (var h, c, l, u, p, d, f = {}, m = e.concat(), g = 0, v = r.length; g < v; g++)
                        Array.prototype.push.apply(m, r[g]);
                    for (h = 0,
                    c = m.length; h < c; h++)
                        p = m[h].x + ":" + m[h].y,
                        void 0 !== f[p] && console.warn("THREE.ShapeUtils: Duplicate point", p, h),
                        f[p] = h;
                    var y = s(e, r)
                      , x = t.ShapeUtils.triangulate(y, !1);
                    for (h = 0,
                    c = x.length; h < c; h++)
                        for (u = x[h],
                        l = 0; l < 3; l++)
                            p = u[l].x + ":" + u[l].y,
                            d = f[p],
                            void 0 !== d && (u[l] = d);
                    return x.concat()
                },
                isClockWise: function(e) {
                    return t.ShapeUtils.area(e) < 0
                },
                b2: function() {
                    function t(t, e) {
                        var r = 1 - t;
                        return r * r * e
                    }
                    function e(t, e) {
                        return 2 * (1 - t) * t * e
                    }
                    function r(t, e) {
                        return t * t * e
                    }
                    return function(i, n, o, a) {
                        return t(i, n) + e(i, o) + r(i, a)
                    }
                }(),
                b3: function() {
                    function t(t, e) {
                        var r = 1 - t;
                        return r * r * r * e
                    }
                    function e(t, e) {
                        var r = 1 - t;
                        return 3 * r * r * t * e
                    }
                    function r(t, e) {
                        var r = 1 - t;
                        return 3 * r * t * t * e
                    }
                    function i(t, e) {
                        return t * t * t * e
                    }
                    return function(n, o, a, s, h) {
                        return t(n, o) + e(n, a) + r(n, s) + i(n, h)
                    }
                }()
            },
            br.prototype = {
                constructor: br,
                getPoint: function(t) {
                    return console.warn("THREE.Curve: Warning, getPoint() not implemented!"),
                    null
                },
                getPointAt: function(t) {
                    var e = this.getUtoTmapping(t);
                    return this.getPoint(e)
                },
                getPoints: function(t) {
                    t || (t = 5);
                    for (var e = [], r = 0; r <= t; r++)
                        e.push(this.getPoint(r / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    t || (t = 5);
                    for (var e = [], r = 0; r <= t; r++)
                        e.push(this.getPointAt(r / t));
                    return e
                },
                getLength: function() {
                    var t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (t || (t = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200),
                    this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                        return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var e, r, i = [], n = this.getPoint(0), o = 0;
                    for (i.push(0),
                    r = 1; r <= t; r++)
                        e = this.getPoint(r / t),
                        o += e.distanceTo(n),
                        i.push(o),
                        n = e;
                    return this.cacheArcLengths = i,
                    i
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0,
                    this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    var r, i = this.getLengths(), n = 0, o = i.length;
                    r = e ? e : t * i[o - 1];
                    for (var a, s = 0, h = o - 1; s <= h; )
                        if (n = Math.floor(s + (h - s) / 2),
                        a = i[n] - r,
                        a < 0)
                            s = n + 1;
                        else {
                            if (!(a > 0)) {
                                h = n;
                                break
                            }
                            h = n - 1
                        }
                    if (n = h,
                    i[n] === r) {
                        var c = n / (o - 1);
                        return c
                    }
                    var l = i[n]
                      , u = i[n + 1]
                      , p = u - l
                      , d = (r - l) / p
                      , c = (n + d) / (o - 1);
                    return c
                },
                getTangent: function(t) {
                    var e = 1e-4
                      , r = t - e
                      , i = t + e;
                    r < 0 && (r = 0),
                    i > 1 && (i = 1);
                    var n = this.getPoint(r)
                      , o = this.getPoint(i)
                      , a = o.clone().sub(n);
                    return a.normalize()
                },
                getTangentAt: function(t) {
                    var e = this.getUtoTmapping(t);
                    return this.getTangent(e)
                }
            },
            br.create = function(t, e) {
                return t.prototype = Object.create(br.prototype),
                t.prototype.constructor = t,
                t.prototype.getPoint = e,
                t
            }
            ,
            wr.prototype = Object.create(br.prototype),
            wr.prototype.constructor = wr,
            wr.prototype.isLineCurve = !0,
            wr.prototype.getPoint = function(t) {
                if (1 === t)
                    return this.v2.clone();
                var e = this.v2.clone().sub(this.v1);
                return e.multiplyScalar(t).add(this.v1),
                e
            }
            ,
            wr.prototype.getPointAt = function(t) {
                return this.getPoint(t)
            }
            ,
            wr.prototype.getTangent = function(t) {
                var e = this.v2.clone().sub(this.v1);
                return e.normalize()
            }
            ,
            _r.prototype = Object.assign(Object.create(br.prototype), {
                constructor: _r,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    var t = this.curves[0].getPoint(0)
                      , e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new wr(e,t))
                },
                getPoint: function(t) {
                    for (var e = t * this.getLength(), r = this.getCurveLengths(), i = 0; i < r.length; ) {
                        if (r[i] >= e) {
                            var n = r[i] - e
                              , o = this.curves[i]
                              , a = o.getLength()
                              , s = 0 === a ? 0 : 1 - n / a;
                            return o.getPointAt(s)
                        }
                        i++
                    }
                    return null
                },
                getLength: function() {
                    var t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0,
                    this.cacheLengths = null,
                    this.getLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                        return this.cacheLengths;
                    for (var t = [], e = 0, r = 0, i = this.curves.length; r < i; r++)
                        e += this.curves[r].getLength(),
                        t.push(e);
                    return this.cacheLengths = t,
                    t
                },
                getSpacedPoints: function(t) {
                    t || (t = 40);
                    for (var e = [], r = 0; r <= t; r++)
                        e.push(this.getPoint(r / t));
                    return this.autoClose && e.push(e[0]),
                    e
                },
                getPoints: function(t) {
                    t = t || 12;
                    for (var e, r = [], i = 0, n = this.curves; i < n.length; i++)
                        for (var o = n[i], a = o && o.isEllipseCurve ? 2 * t : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), h = 0; h < s.length; h++) {
                            var c = s[h];
                            e && e.equals(c) || (r.push(c),
                            e = c)
                        }
                    return this.autoClose && r.length > 1 && !r[r.length - 1].equals(r[0]) && r.push(r[0]),
                    r
                },
                createPointsGeometry: function(t) {
                    var e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    var e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    for (var e = new kt, r = 0, i = t.length; r < i; r++) {
                        var n = t[r];
                        e.vertices.push(new s(n.x,n.y,n.z || 0))
                    }
                    return e
                }
            }),
            Mr.prototype = Object.create(br.prototype),
            Mr.prototype.constructor = Mr,
            Mr.prototype.isEllipseCurve = !0,
            Mr.prototype.getPoint = function(t) {
                for (var e = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, n = Math.abs(i) < Number.EPSILON; i < 0; )
                    i += e;
                for (; i > e; )
                    i -= e;
                i < Number.EPSILON && (i = n ? 0 : e),
                this.aClockwise !== !0 || n || (i === e ? i = -e : i -= e);
                var o = this.aStartAngle + t * i
                  , a = this.aX + this.xRadius * Math.cos(o)
                  , s = this.aY + this.yRadius * Math.sin(o);
                if (0 !== this.aRotation) {
                    var h = Math.cos(this.aRotation)
                      , c = Math.sin(this.aRotation)
                      , l = a - this.aX
                      , u = s - this.aY;
                    a = l * h - u * c + this.aX,
                    s = l * c + u * h + this.aY
                }
                return new r(a,s)
            }
            ,
            t.CurveUtils = {
                tangentQuadraticBezier: function(t, e, r, i) {
                    return 2 * (1 - t) * (r - e) + 2 * t * (i - r)
                },
                tangentCubicBezier: function(t, e, r, i, n) {
                    return -3 * e * (1 - t) * (1 - t) + 3 * r * (1 - t) * (1 - t) - 6 * t * r * (1 - t) + 6 * t * i * (1 - t) - 3 * t * t * i + 3 * t * t * n
                },
                tangentSpline: function(t, e, r, i, n) {
                    var o = 6 * t * t - 6 * t
                      , a = 3 * t * t - 4 * t + 1
                      , s = -6 * t * t + 6 * t
                      , h = 3 * t * t - 2 * t;
                    return o + a + s + h
                },
                interpolate: function(t, e, r, i, n) {
                    var o = .5 * (r - t)
                      , a = .5 * (i - e)
                      , s = n * n
                      , h = n * s;
                    return (2 * e - 2 * r + o + a) * h + (-3 * e + 3 * r - 2 * o - a) * s + o * n + e
                }
            },
            Sr.prototype = Object.create(br.prototype),
            Sr.prototype.constructor = Sr,
            Sr.prototype.isSplineCurve = !0,
            Sr.prototype.getPoint = function(e) {
                var i = this.points
                  , n = (i.length - 1) * e
                  , o = Math.floor(n)
                  , a = n - o
                  , s = i[0 === o ? o : o - 1]
                  , h = i[o]
                  , c = i[o > i.length - 2 ? i.length - 1 : o + 1]
                  , l = i[o > i.length - 3 ? i.length - 1 : o + 2]
                  , u = t.CurveUtils.interpolate;
                return new r(u(s.x, h.x, c.x, l.x, a),u(s.y, h.y, c.y, l.y, a))
            }
            ,
            Er.prototype = Object.create(br.prototype),
            Er.prototype.constructor = Er,
            Er.prototype.getPoint = function(e) {
                var i = t.ShapeUtils.b3;
                return new r(i(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x),i(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
            }
            ,
            Er.prototype.getTangent = function(e) {
                var i = t.CurveUtils.tangentCubicBezier;
                return new r(i(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x),i(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize()
            }
            ,
            Tr.prototype = Object.create(br.prototype),
            Tr.prototype.constructor = Tr,
            Tr.prototype.getPoint = function(e) {
                var i = t.ShapeUtils.b2;
                return new r(i(e, this.v0.x, this.v1.x, this.v2.x),i(e, this.v0.y, this.v1.y, this.v2.y))
            }
            ,
            Tr.prototype.getTangent = function(e) {
                var i = t.CurveUtils.tangentQuadraticBezier;
                return new r(i(e, this.v0.x, this.v1.x, this.v2.x),i(e, this.v0.y, this.v1.y, this.v2.y)).normalize()
            }
            ;
            var Fh = Object.assign(Object.create(_r.prototype), {
                fromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (var e = 1, r = t.length; e < r; e++)
                        this.lineTo(t[e].x, t[e].y)
                },
                moveTo: function(t, e) {
                    this.currentPoint.set(t, e)
                },
                lineTo: function(t, e) {
                    var i = new wr(this.currentPoint.clone(),new r(t,e));
                    this.curves.push(i),
                    this.currentPoint.set(t, e)
                },
                quadraticCurveTo: function(t, e, i, n) {
                    var o = new Tr(this.currentPoint.clone(),new r(t,e),new r(i,n));
                    this.curves.push(o),
                    this.currentPoint.set(i, n)
                },
                bezierCurveTo: function(t, e, i, n, o, a) {
                    var s = new Er(this.currentPoint.clone(),new r(t,e),new r(i,n),new r(o,a));
                    this.curves.push(s),
                    this.currentPoint.set(o, a)
                },
                splineThru: function(t) {
                    var e = [this.currentPoint.clone()].concat(t)
                      , r = new Sr(e);
                    this.curves.push(r),
                    this.currentPoint.copy(t[t.length - 1])
                },
                arc: function(t, e, r, i, n, o) {
                    var a = this.currentPoint.x
                      , s = this.currentPoint.y;
                    this.absarc(t + a, e + s, r, i, n, o)
                },
                absarc: function(t, e, r, i, n, o) {
                    this.absellipse(t, e, r, r, i, n, o)
                },
                ellipse: function(t, e, r, i, n, o, a, s) {
                    var h = this.currentPoint.x
                      , c = this.currentPoint.y;
                    this.absellipse(t + h, e + c, r, i, n, o, a, s)
                },
                absellipse: function(t, e, r, i, n, o, a, s) {
                    var h = new Mr(t,e,r,i,n,o,a,s);
                    if (this.curves.length > 0) {
                        var c = h.getPoint(0);
                        c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
                    }
                    this.curves.push(h);
                    var l = h.getPoint(1);
                    this.currentPoint.copy(l)
                }
            });
            Ar.prototype = Object.create(kt.prototype),
            Ar.prototype.constructor = Ar,
            Ar.NoTaper = function(t) {
                return 1
            }
            ,
            Ar.SinusoidalTaper = function(t) {
                return Math.sin(Math.PI * t)
            }
            ,
            Ar.FrenetFrames = function(e, r, i) {
                function n() {
                    g[0] = new s,
                    v[0] = new s,
                    h = Number.MAX_VALUE,
                    c = Math.abs(m[0].x),
                    l = Math.abs(m[0].y),
                    u = Math.abs(m[0].z),
                    c <= h && (h = c,
                    f.set(1, 0, 0)),
                    l <= h && (h = l,
                    f.set(0, 1, 0)),
                    u <= h && f.set(0, 0, 1),
                    y.crossVectors(m[0], f).normalize(),
                    g[0].crossVectors(m[0], y),
                    v[0].crossVectors(m[0], g[0])
                }
                var a, h, c, l, u, p, d, f = new s, m = [], g = [], v = [], y = new s, x = new o, b = r + 1;
                for (this.tangents = m,
                this.normals = g,
                this.binormals = v,
                p = 0; p < b; p++)
                    d = p / (b - 1),
                    m[p] = e.getTangentAt(d),
                    m[p].normalize();
                for (n(),
                p = 1; p < b; p++)
                    g[p] = g[p - 1].clone(),
                    v[p] = v[p - 1].clone(),
                    y.crossVectors(m[p - 1], m[p]),
                    y.length() > Number.EPSILON && (y.normalize(),
                    a = Math.acos(t.Math.clamp(m[p - 1].dot(m[p]), -1, 1)),
                    g[p].applyMatrix4(x.makeRotationAxis(y, a))),
                    v[p].crossVectors(m[p], g[p]);
                if (i)
                    for (a = Math.acos(t.Math.clamp(g[0].dot(g[b - 1]), -1, 1)),
                    a /= b - 1,
                    m[0].dot(y.crossVectors(g[0], g[b - 1])) > 0 && (a = -a),
                    p = 1; p < b; p++)
                        g[p].applyMatrix4(x.makeRotationAxis(m[p], a * p)),
                        v[p].crossVectors(m[p], g[p])
            }
            ,
            Lr.prototype = Object.create(kt.prototype),
            Lr.prototype.constructor = Lr,
            Lr.prototype.addShapeList = function(t, e) {
                for (var r = t.length, i = 0; i < r; i++) {
                    var n = t[i];
                    this.addShape(n, e)
                }
            }
            ,
            Lr.prototype.addShape = function(e, i) {
                function n(t, e, r) {
                    return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                    e.clone().multiplyScalar(r).add(t)
                }
                function o(t, e, i) {
                    var n, o, a = 1, s = t.x - e.x, h = t.y - e.y, c = i.x - t.x, l = i.y - t.y, u = s * s + h * h, p = s * l - h * c;
                    if (Math.abs(p) > Number.EPSILON) {
                        var d = Math.sqrt(u)
                          , f = Math.sqrt(c * c + l * l)
                          , m = e.x - h / d
                          , g = e.y + s / d
                          , v = i.x - l / f
                          , y = i.y + c / f
                          , x = ((v - m) * l - (y - g) * c) / (s * l - h * c);
                        n = m + s * x - t.x,
                        o = g + h * x - t.y;
                        var b = n * n + o * o;
                        if (b <= 2)
                            return new r(n,o);
                        a = Math.sqrt(b / 2)
                    } else {
                        var w = !1;
                        s > Number.EPSILON ? c > Number.EPSILON && (w = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (w = !0) : Math.sign(h) === Math.sign(l) && (w = !0),
                        w ? (n = -h,
                        o = s,
                        a = Math.sqrt(u)) : (n = s,
                        o = h,
                        a = Math.sqrt(u / 2))
                    }
                    return new r(n / a,o / a)
                }
                function a() {
                    if (_) {
                        var t = 0
                          , e = W * t;
                        for (q = 0; q < X; q++)
                            H = B[q],
                            u(H[2] + e, H[1] + e, H[0] + e);
                        for (t = S + 2 * w,
                        e = W * t,
                        q = 0; q < X; q++)
                            H = B[q],
                            u(H[0] + e, H[1] + e, H[2] + e)
                    } else {
                        for (q = 0; q < X; q++)
                            H = B[q],
                            u(H[2], H[1], H[0]);
                        for (q = 0; q < X; q++)
                            H = B[q],
                            u(H[0] + W * S, H[1] + W * S, H[2] + W * S)
                    }
                }
                function h() {
                    var t = 0;
                    for (c(F, t),
                    t += F.length,
                    C = 0,
                    R = O.length; C < R; C++)
                        L = O[C],
                        c(L, t),
                        t += L.length
                }
                function c(t, e) {
                    var r, i;
                    for (q = t.length; --q >= 0; ) {
                        r = q,
                        i = q - 1,
                        i < 0 && (i = t.length - 1);
                        var n = 0
                          , o = S + 2 * w;
                        for (n = 0; n < o; n++) {
                            var a = W * n
                              , s = W * (n + 1)
                              , h = e + r + a
                              , c = e + i + a
                              , l = e + i + s
                              , u = e + r + s;
                            p(h, c, l, u, t, n, o, r, i)
                        }
                    }
                }
                function l(t, e, r) {
                    P.vertices.push(new s(t,e,r))
                }
                function u(t, e, r) {
                    t += U,
                    e += U,
                    r += U,
                    P.faces.push(new Dt(t,e,r,null,null,0));
                    var i = A.generateTopUV(P, t, e, r);
                    P.faceVertexUvs[0].push(i)
                }
                function p(t, e, r, i, n, o, a, s, h) {
                    t += U,
                    e += U,
                    r += U,
                    i += U,
                    P.faces.push(new Dt(t,e,i,null,null,1)),
                    P.faces.push(new Dt(e,r,i,null,null,1));
                    var c = A.generateSideWallUV(P, t, e, r, i);
                    P.faceVertexUvs[0].push([c[0], c[1], c[3]]),
                    P.faceVertexUvs[0].push([c[1], c[2], c[3]])
                }
                var d, f, m, g, v, y = void 0 !== i.amount ? i.amount : 100, x = void 0 !== i.bevelThickness ? i.bevelThickness : 6, b = void 0 !== i.bevelSize ? i.bevelSize : x - 2, w = void 0 !== i.bevelSegments ? i.bevelSegments : 3, _ = void 0 === i.bevelEnabled || i.bevelEnabled, M = void 0 !== i.curveSegments ? i.curveSegments : 12, S = void 0 !== i.steps ? i.steps : 1, E = i.extrudePath, T = !1, A = void 0 !== i.UVGenerator ? i.UVGenerator : Lr.WorldUVGenerator;
                E && (d = E.getSpacedPoints(S),
                T = !0,
                _ = !1,
                f = void 0 !== i.frames ? i.frames : new Ar.FrenetFrames(E,S,(!1)),
                m = new s,
                g = new s,
                v = new s),
                _ || (w = 0,
                x = 0,
                b = 0);
                var L, C, R, P = this, U = this.vertices.length, I = e.extractPoints(M), D = I.shape, O = I.holes, N = !t.ShapeUtils.isClockWise(D);
                if (N) {
                    for (D = D.reverse(),
                    C = 0,
                    R = O.length; C < R; C++)
                        L = O[C],
                        t.ShapeUtils.isClockWise(L) && (O[C] = L.reverse());
                    N = !1
                }
                var B = t.ShapeUtils.triangulateShape(D, O)
                  , F = D;
                for (C = 0,
                R = O.length; C < R; C++)
                    L = O[C],
                    D = D.concat(L);
                for (var k, z, V, G, j, H, W = D.length, X = B.length, Y = [], q = 0, Z = F.length, Q = Z - 1, J = q + 1; q < Z; q++,
                Q++,
                J++)
                    Q === Z && (Q = 0),
                    J === Z && (J = 0),
                    Y[q] = o(F[q], F[Q], F[J]);
                var K, $ = [], tt = Y.concat();
                for (C = 0,
                R = O.length; C < R; C++) {
                    for (L = O[C],
                    K = [],
                    q = 0,
                    Z = L.length,
                    Q = Z - 1,
                    J = q + 1; q < Z; q++,
                    Q++,
                    J++)
                        Q === Z && (Q = 0),
                        J === Z && (J = 0),
                        K[q] = o(L[q], L[Q], L[J]);
                    $.push(K),
                    tt = tt.concat(K)
                }
                for (k = 0; k < w; k++) {
                    for (V = k / w,
                    G = x * Math.cos(V * Math.PI / 2),
                    z = b * Math.sin(V * Math.PI / 2),
                    q = 0,
                    Z = F.length; q < Z; q++)
                        j = n(F[q], Y[q], z),
                        l(j.x, j.y, -G);
                    for (C = 0,
                    R = O.length; C < R; C++)
                        for (L = O[C],
                        K = $[C],
                        q = 0,
                        Z = L.length; q < Z; q++)
                            j = n(L[q], K[q], z),
                            l(j.x, j.y, -G)
                }
                for (z = b,
                q = 0; q < W; q++)
                    j = _ ? n(D[q], tt[q], z) : D[q],
                    T ? (g.copy(f.normals[0]).multiplyScalar(j.x),
                    m.copy(f.binormals[0]).multiplyScalar(j.y),
                    v.copy(d[0]).add(g).add(m),
                    l(v.x, v.y, v.z)) : l(j.x, j.y, 0);
                var et;
                for (et = 1; et <= S; et++)
                    for (q = 0; q < W; q++)
                        j = _ ? n(D[q], tt[q], z) : D[q],
                        T ? (g.copy(f.normals[et]).multiplyScalar(j.x),
                        m.copy(f.binormals[et]).multiplyScalar(j.y),
                        v.copy(d[et]).add(g).add(m),
                        l(v.x, v.y, v.z)) : l(j.x, j.y, y / S * et);
                for (k = w - 1; k >= 0; k--) {
                    for (V = k / w,
                    G = x * Math.cos(V * Math.PI / 2),
                    z = b * Math.sin(V * Math.PI / 2),
                    q = 0,
                    Z = F.length; q < Z; q++)
                        j = n(F[q], Y[q], z),
                        l(j.x, j.y, y + G);
                    for (C = 0,
                    R = O.length; C < R; C++)
                        for (L = O[C],
                        K = $[C],
                        q = 0,
                        Z = L.length; q < Z; q++)
                            j = n(L[q], K[q], z),
                            T ? l(j.x, j.y + d[S - 1].y, d[S - 1].x + G) : l(j.x, j.y, y + G)
                }
                a(),
                h()
            }
            ,
            Lr.WorldUVGenerator = {
                generateTopUV: function(t, e, i, n) {
                    var o = t.vertices
                      , a = o[e]
                      , s = o[i]
                      , h = o[n];
                    return [new r(a.x,a.y), new r(s.x,s.y), new r(h.x,h.y)]
                },
                generateSideWallUV: function(t, e, i, n, o) {
                    var a = t.vertices
                      , s = a[e]
                      , h = a[i]
                      , c = a[n]
                      , l = a[o];
                    return Math.abs(s.y - h.y) < .01 ? [new r(s.x,1 - s.z), new r(h.x,1 - h.z), new r(c.x,1 - c.z), new r(l.x,1 - l.z)] : [new r(s.y,1 - s.z), new r(h.y,1 - h.z), new r(c.y,1 - c.z), new r(l.y,1 - l.z)]
                }
            },
            Cr.prototype = Object.create(kt.prototype),
            Cr.prototype.constructor = Cr,
            Cr.prototype.addShapeList = function(t, e) {
                for (var r = 0, i = t.length; r < i; r++)
                    this.addShape(t[r], e);
                return this
            }
            ,
            Cr.prototype.addShape = function(e, r) {
                void 0 === r && (r = {});
                var i, n, o, a = void 0 !== r.curveSegments ? r.curveSegments : 12, h = r.material, c = void 0 === r.UVGenerator ? Lr.WorldUVGenerator : r.UVGenerator, l = this.vertices.length, u = e.extractPoints(a), p = u.shape, d = u.holes, f = !t.ShapeUtils.isClockWise(p);
                if (f) {
                    for (p = p.reverse(),
                    i = 0,
                    n = d.length; i < n; i++)
                        o = d[i],
                        t.ShapeUtils.isClockWise(o) && (d[i] = o.reverse());
                    f = !1
                }
                var m = t.ShapeUtils.triangulateShape(p, d);
                for (i = 0,
                n = d.length; i < n; i++)
                    o = d[i],
                    p = p.concat(o);
                var g, v, y = p.length, x = m.length;
                for (i = 0; i < y; i++)
                    g = p[i],
                    this.vertices.push(new s(g.x,g.y,0));
                for (i = 0; i < x; i++) {
                    v = m[i];
                    var b = v[0] + l
                      , w = v[1] + l
                      , _ = v[2] + l;
                    this.faces.push(new Dt(b,w,_,null,null,h)),
                    this.faceVertexUvs[0].push(c.generateTopUV(this, b, w, _))
                }
            }
            ,
            Rr.prototype = Object.assign(Object.create(Fh), {
                constructor: Rr,
                extrude: function(t) {
                    return new Lr(this,t)
                },
                makeGeometry: function(t) {
                    return new Cr(this,t)
                },
                getPointsHoles: function(t) {
                    for (var e = [], r = 0, i = this.holes.length; r < i; r++)
                        e[r] = this.holes[r].getPoints(t);
                    return e
                },
                extractAllPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                extractPoints: function(t) {
                    return this.extractAllPoints(t)
                }
            }),
            Pr.prototype = Fh,
            Fh.constructor = Pr,
            Ur.prototype = {
                moveTo: function(t, e) {
                    this.currentPath = new Pr,
                    this.subPaths.push(this.currentPath),
                    this.currentPath.moveTo(t, e)
                },
                lineTo: function(t, e) {
                    this.currentPath.lineTo(t, e)
                },
                quadraticCurveTo: function(t, e, r, i) {
                    this.currentPath.quadraticCurveTo(t, e, r, i)
                },
                bezierCurveTo: function(t, e, r, i, n, o) {
                    this.currentPath.bezierCurveTo(t, e, r, i, n, o)
                },
                splineThru: function(t) {
                    this.currentPath.splineThru(t)
                },
                toShapes: function(e, r) {
                    function i(t) {
                        for (var e = [], r = 0, i = t.length; r < i; r++) {
                            var n = t[r]
                              , o = new Rr;
                            o.curves = n.curves,
                            e.push(o)
                        }
                        return e
                    }
                    function n(t, e) {
                        for (var r = e.length, i = !1, n = r - 1, o = 0; o < r; n = o++) {
                            var a = e[n]
                              , s = e[o]
                              , h = s.x - a.x
                              , c = s.y - a.y;
                            if (Math.abs(c) > Number.EPSILON) {
                                if (c < 0 && (a = e[o],
                                h = -h,
                                s = e[n],
                                c = -c),
                                t.y < a.y || t.y > s.y)
                                    continue;
                                if (t.y === a.y) {
                                    if (t.x === a.x)
                                        return !0
                                } else {
                                    var l = c * (t.x - a.x) - h * (t.y - a.y);
                                    if (0 === l)
                                        return !0;
                                    if (l < 0)
                                        continue;
                                    i = !i
                                }
                            } else {
                                if (t.y !== a.y)
                                    continue;
                                if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x)
                                    return !0
                            }
                        }
                        return i
                    }
                    var o = t.ShapeUtils.isClockWise
                      , a = this.subPaths;
                    if (0 === a.length)
                        return [];
                    if (r === !0)
                        return i(a);
                    var s, h, c, l = [];
                    if (1 === a.length)
                        return h = a[0],
                        c = new Rr,
                        c.curves = h.curves,
                        l.push(c),
                        l;
                    var u = !o(a[0].getPoints());
                    u = e ? !u : u;
                    var p, d = [], f = [], m = [], g = 0;
                    f[g] = void 0,
                    m[g] = [];
                    for (var v = 0, y = a.length; v < y; v++)
                        h = a[v],
                        p = h.getPoints(),
                        s = o(p),
                        s = e ? !s : s,
                        s ? (!u && f[g] && g++,
                        f[g] = {
                            s: new Rr,
                            p: p
                        },
                        f[g].s.curves = h.curves,
                        u && g++,
                        m[g] = []) : m[g].push({
                            h: h,
                            p: p[0]
                        });
                    if (!f[0])
                        return i(a);
                    if (f.length > 1) {
                        for (var x = !1, b = [], w = 0, _ = f.length; w < _; w++)
                            d[w] = [];
                        for (var w = 0, _ = f.length; w < _; w++)
                            for (var M = m[w], S = 0; S < M.length; S++) {
                                for (var E = M[S], T = !0, A = 0; A < f.length; A++)
                                    n(E.p, f[A].p) && (w !== A && b.push({
                                        froms: w,
                                        tos: A,
                                        hole: S
                                    }),
                                    T ? (T = !1,
                                    d[A].push(E)) : x = !0);
                                T && d[w].push(E)
                            }
                        b.length > 0 && (x || (m = d))
                    }
                    for (var L, v = 0, C = f.length; v < C; v++) {
                        c = f[v].s,
                        l.push(c),
                        L = m[v];
                        for (var R = 0, P = L.length; R < P; R++)
                            c.holes.push(L[R].h)
                    }
                    return l
                }
            },
            Object.assign(Ir.prototype, {
                isFont: !0,
                generateShapes: function(e, r, i) {
                    function n(t) {
                        for (var e = String(t).split(""), i = r / a.resolution, n = 0, s = [], h = 0; h < e.length; h++) {
                            var c = o(e[h], i, n);
                            n += c.offset,
                            s.push(c.path)
                        }
                        return s
                    }
                    function o(e, r, n) {
                        var o = a.glyphs[e] || a.glyphs["?"];
                        if (o) {
                            var s, h, c, l, u, p, d, f, m, g, v, y = new Ur, x = [], b = t.ShapeUtils.b2, w = t.ShapeUtils.b3;
                            if (o.o)
                                for (var _ = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), M = 0, S = _.length; M < S; ) {
                                    var E = _[M++];
                                    switch (E) {
                                    case "m":
                                        s = _[M++] * r + n,
                                        h = _[M++] * r,
                                        y.moveTo(s, h);
                                        break;
                                    case "l":
                                        s = _[M++] * r + n,
                                        h = _[M++] * r,
                                        y.lineTo(s, h);
                                        break;
                                    case "q":
                                        if (c = _[M++] * r + n,
                                        l = _[M++] * r,
                                        d = _[M++] * r + n,
                                        f = _[M++] * r,
                                        y.quadraticCurveTo(d, f, c, l),
                                        v = x[x.length - 1]) {
                                            u = v.x,
                                            p = v.y;
                                            for (var T = 1; T <= i; T++) {
                                                var A = T / i;
                                                b(A, u, d, c),
                                                b(A, p, f, l)
                                            }
                                        }
                                        break;
                                    case "b":
                                        if (c = _[M++] * r + n,
                                        l = _[M++] * r,
                                        d = _[M++] * r + n,
                                        f = _[M++] * r,
                                        m = _[M++] * r + n,
                                        g = _[M++] * r,
                                        y.bezierCurveTo(d, f, m, g, c, l),
                                        v = x[x.length - 1]) {
                                            u = v.x,
                                            p = v.y;
                                            for (var T = 1; T <= i; T++) {
                                                var A = T / i;
                                                w(A, u, d, m, c),
                                                w(A, p, f, g, l)
                                            }
                                        }
                                    }
                                }
                            return {
                                offset: o.ha * r,
                                path: y
                            }
                        }
                    }
                    void 0 === r && (r = 100),
                    void 0 === i && (i = 4);
                    for (var a = this.data, s = n(e), h = [], c = 0, l = s.length; c < l; c++)
                        Array.prototype.push.apply(h, s[c].toShapes());
                    return h
                }
            }),
            Object.assign(Dr.prototype, {
                load: function(t, e, r, i) {
                    var n = this
                      , o = new ze(this.manager);
                    o.load(t, function(t) {
                        var r;
                        try {
                            r = JSON.parse(t)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                            r = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var i = n.parse(r);
                        e && e(i)
                    }, r, i)
                },
                parse: function(t) {
                    return new Ir(t)
                }
            });
            var kh;
            Object.assign(Nr.prototype, {
                load: function(t, e, r, i) {
                    var n = new ze(this.manager);
                    n.setResponseType("arraybuffer"),
                    n.load(t, function(t) {
                        var r = Or();
                        r.decodeAudioData(t, function(t) {
                            e(t)
                        })
                    }, r, i)
                }
            }),
            Object.assign(Br.prototype, {
                update: function() {
                    var e, r, i, n, a, s = new o, h = new o;
                    return function(o) {
                        var c = e !== o.focus || r !== o.fov || i !== o.aspect * this.aspect || n !== o.near || a !== o.far;
                        if (c) {
                            e = o.focus,
                            r = o.fov,
                            i = o.aspect * this.aspect,
                            n = o.near,
                            a = o.far;
                            var l, u, p = o.projectionMatrix.clone(), d = this.eyeSep / 2, f = d * n / e, m = n * Math.tan(t.Math.DEG2RAD * r * .5);
                            h.elements[12] = -d,
                            s.elements[12] = d,
                            l = -m * i + f,
                            u = m * i + f,
                            p.elements[0] = 2 * n / (u - l),
                            p.elements[8] = (u + l) / (u - l),
                            this.cameraL.projectionMatrix.copy(p),
                            l = -m * i - f,
                            u = m * i - f,
                            p.elements[0] = 2 * n / (u - l),
                            p.elements[8] = (u + l) / (u - l),
                            this.cameraR.projectionMatrix.copy(p)
                        }
                        this.cameraL.matrixWorld.copy(o.matrixWorld).multiply(h),
                        this.cameraR.matrixWorld.copy(o.matrixWorld).multiply(s)
                    }
                }()
            }),
            Fr.prototype = Object.create(Bt.prototype),
            Fr.prototype.constructor = Fr,
            kr.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: kr,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    null !== this.filter && (this.gain.disconnect(this.filter),
                    this.filter.disconnect(this.context.destination),
                    this.gain.connect(this.context.destination),
                    this.filter = null)
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(t) {
                    null !== this.filter ? (this.gain.disconnect(this.filter),
                    this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                    this.filter = t,
                    this.gain.connect(this.filter),
                    this.filter.connect(this.context.destination)
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(t) {
                    this.gain.gain.value = t
                },
                updateMatrixWorld: function() {
                    var t = new s
                      , e = new a
                      , r = new s
                      , i = new s;
                    return function(n) {
                        Bt.prototype.updateMatrixWorld.call(this, n);
                        var o = this.context.listener
                          , a = this.up;
                        this.matrixWorld.decompose(t, e, r),
                        i.set(0, 0, -1).applyQuaternion(e),
                        o.setPosition(t.x, t.y, t.z),
                        o.setOrientation(i.x, i.y, i.z, a.x, a.y, a.z)
                    }
                }()
            }),
            zr.prototype = Object.assign(Object.create(Bt.prototype), {
                constructor: zr,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(t) {
                    return this.hasPlaybackControl = !1,
                    this.sourceType = "audioNode",
                    this.source = t,
                    this.connect(),
                    this
                },
                setBuffer: function(t) {
                    return this.source.buffer = t,
                    this.sourceType = "buffer",
                    this.autoplay && this.play(),
                    this
                },
                play: function() {
                    if (this.isPlaying === !0)
                        return void console.warn("THREE.Audio: Audio is already playing.");
                    if (this.hasPlaybackControl === !1)
                        return void console.warn("THREE.Audio: this Audio has no playback control.");
                    var t = this.context.createBufferSource();
                    return t.buffer = this.source.buffer,
                    t.loop = this.source.loop,
                    t.onended = this.source.onended,
                    t.start(0, this.startTime),
                    t.playbackRate.value = this.playbackRate,
                    this.isPlaying = !0,
                    this.source = t,
                    this.connect()
                },
                pause: function() {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
                    this.startTime = this.context.currentTime,
                    this.isPlaying = !1,
                    this)
                },
                stop: function() {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
                    this.startTime = 0,
                    this.isPlaying = !1,
                    this)
                },
                connect: function() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++)
                            this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else
                        this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++)
                            this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else
                        this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(t) {
                    return t || (t = []),
                    this.isPlaying === !0 ? (this.disconnect(),
                    this.filters = t,
                    this.connect()) : this.filters = t,
                    this
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(t) {
                    return this.setFilters(t ? [t] : [])
                },
                setPlaybackRate: function(t) {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = t,
                    this.isPlaying === !0 && (this.source.playbackRate.value = this.playbackRate),
                    this)
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = !1
                },
                getLoop: function() {
                    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
                    !1) : this.source.loop
                },
                setLoop: function(t) {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : void (this.source.loop = t)
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(t) {
                    return this.gain.gain.value = t,
                    this
                }
            }),
            Vr.prototype = Object.assign(Object.create(zr.prototype), {
                constructor: Vr,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(t) {
                    this.panner.refDistance = t
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(t) {
                    this.panner.rolloffFactor = t
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(t) {
                    this.panner.distanceModel = t
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(t) {
                    this.panner.maxDistance = t
                },
                updateMatrixWorld: function() {
                    var t = new s;
                    return function(e) {
                        Bt.prototype.updateMatrixWorld.call(this, e),
                        t.setFromMatrixPosition(this.matrixWorld),
                        this.panner.setPosition(t.x, t.y, t.z)
                    }
                }()
            }),
            Object.assign(Gr.prototype, {
                getFrequencyData: function() {
                    return this.analyser.getByteFrequencyData(this.data),
                    this.data
                },
                getAverageFrequency: function() {
                    for (var t = 0, e = this.getFrequencyData(), r = 0; r < e.length; r++)
                        t += e[r];
                    return t / e.length
                }
            }),
            jr.prototype = {
                constructor: jr,
                accumulate: function(t, e) {
                    var r = this.buffer
                      , i = this.valueSize
                      , n = t * i + i
                      , o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== i; ++a)
                            r[n + a] = r[a];
                        o = e
                    } else {
                        o += e;
                        var s = e / o;
                        this._mixBufferRegion(r, n, 0, s, i)
                    }
                    this.cumulativeWeight = o
                },
                apply: function(t) {
                    var e = this.valueSize
                      , r = this.buffer
                      , i = t * e + e
                      , n = this.cumulativeWeight
                      , o = this.binding;
                    if (this.cumulativeWeight = 0,
                    n < 1) {
                        var a = 3 * e;
                        this._mixBufferRegion(r, i, a, 1 - n, e)
                    }
                    for (var s = e, h = e + e; s !== h; ++s)
                        if (r[s] !== r[s + e]) {
                            o.setValue(r, i);
                            break
                        }
                },
                saveOriginalState: function() {
                    var t = this.binding
                      , e = this.buffer
                      , r = this.valueSize
                      , i = 3 * r;
                    t.getValue(e, i);
                    for (var n = r, o = i; n !== o; ++n)
                        e[n] = e[i + n % r];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _select: function(t, e, r, i, n) {
                    if (i >= .5)
                        for (var o = 0; o !== n; ++o)
                            t[e + o] = t[r + o]
                },
                _slerp: function(t, e, r, i, n) {
                    a.slerpFlat(t, e, t, e, t, r, i)
                },
                _lerp: function(t, e, r, i, n) {
                    for (var o = 1 - i, a = 0; a !== n; ++a) {
                        var s = e + a;
                        t[s] = t[s] * o + t[r + a] * i
                    }
                }
            },
            Hr.prototype = {
                constructor: Hr,
                getValue: function(t, e) {
                    this.bind(),
                    this.getValue(t, e)
                },
                setValue: function(t, e) {
                    this.bind(),
                    this.setValue(t, e)
                },
                bind: function() {
                    var t = this.node
                      , e = this.parsedPath
                      , r = e.objectName
                      , i = e.propertyName
                      , n = e.propertyIndex;
                    if (t || (t = Hr.findNode(this.rootNode, e.nodeName) || this.rootNode,
                    this.node = t),
                    this.getValue = this._getValue_unavailable,
                    this.setValue = this._setValue_unavailable,
                    !t)
                        return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                    if (r) {
                        var o = e.objectIndex;
                        switch (r) {
                        case "materials":
                            if (!t.material)
                                return void console.error("  can not bind to material as node does not have a material", this);
                            if (!t.material.materials)
                                return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton)
                                return void console.error("  can not bind to bones as node does not have a skeleton", this);
                            t = t.skeleton.bones;
                            for (var a = 0; a < t.length; a++)
                                if (t[a].name === o) {
                                    o = a;
                                    break
                                }
                            break;
                        default:
                            if (void 0 === t[r])
                                return void console.error("  can not bind to objectName of node, undefined", this);
                            t = t[r]
                        }
                        if (void 0 !== o) {
                            if (void 0 === t[o])
                                return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, t);
                            t = t[o]
                        }
                    }
                    var s = t[i];
                    if (void 0 === s) {
                        var h = e.nodeName;
                        return void console.error("  trying to update property for track: " + h + "." + i + " but it wasn't found.", t)
                    }
                    var c = this.Versioning.None;
                    void 0 !== t.needsUpdate ? (c = this.Versioning.NeedsUpdate,
                    this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate,
                    this.targetObject = t);
                    var l = this.BindingType.Direct;
                    if (void 0 !== n) {
                        if ("morphTargetInfluences" === i) {
                            if (!t.geometry)
                                return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                            if (!t.geometry.morphTargets)
                                return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                            for (var a = 0; a < this.node.geometry.morphTargets.length; a++)
                                if (t.geometry.morphTargets[a].name === n) {
                                    n = a;
                                    break
                                }
                        }
                        l = this.BindingType.ArrayElement,
                        this.resolvedProperty = s,
                        this.propertyIndex = n
                    } else
                        void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray,
                        this.resolvedProperty = s) : void 0 !== s.length ? (l = this.BindingType.EntireArray,
                        this.resolvedProperty = s) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[l],
                    this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                },
                unbind: function() {
                    this.node = null,
                    this.getValue = this._getValue_unbound,
                    this.setValue = this._setValue_unbound
                }
            },
            Object.assign(Hr.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                _getValue_unbound: Hr.prototype.getValue,
                _setValue_unbound: Hr.prototype.setValue,
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(t, e) {
                    t[e] = this.node[this.propertyName]
                }
                , function(t, e) {
                    for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                        t[e++] = r[i]
                }
                , function(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }
                , function(t, e) {
                    this.resolvedProperty.toArray(t, e);
                }
                ],
                SetterByBindingTypeAndVersioning: [[function(t, e) {
                    this.node[this.propertyName] = t[e]
                }
                , function(t, e) {
                    this.node[this.propertyName] = t[e],
                    this.targetObject.needsUpdate = !0
                }
                , function(t, e) {
                    this.node[this.propertyName] = t[e],
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                ], [function(t, e) {
                    for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                        r[i] = t[e++]
                }
                , function(t, e) {
                    for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                        r[i] = t[e++];
                    this.targetObject.needsUpdate = !0
                }
                , function(t, e) {
                    for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                        r[i] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                ], [function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }
                , function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e],
                    this.targetObject.needsUpdate = !0
                }
                , function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e],
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                ], [function(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }
                , function(t, e) {
                    this.resolvedProperty.fromArray(t, e),
                    this.targetObject.needsUpdate = !0
                }
                , function(t, e) {
                    this.resolvedProperty.fromArray(t, e),
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                ]]
            }),
            Hr.Composite = function(t, e, r) {
                var i = r || Hr.parseTrackName(e);
                this._targetGroup = t,
                this._bindings = t.subscribe_(e, i)
            }
            ,
            Hr.Composite.prototype = {
                constructor: Hr.Composite,
                getValue: function(t, e) {
                    this.bind();
                    var r = this._targetGroup.nCachedObjects_
                      , i = this._bindings[r];
                    void 0 !== i && i.getValue(t, e)
                },
                setValue: function(t, e) {
                    for (var r = this._bindings, i = this._targetGroup.nCachedObjects_, n = r.length; i !== n; ++i)
                        r[i].setValue(t, e)
                },
                bind: function() {
                    for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, r = t.length; e !== r; ++e)
                        t[e].bind()
                },
                unbind: function() {
                    for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, r = t.length; e !== r; ++e)
                        t[e].unbind()
                }
            },
            Hr.create = function(t, e, r) {
                return t && t.isAnimationObjectGroup ? new Hr.Composite(t,e,r) : new Hr(t,e,r)
            }
            ,
            Hr.parseTrackName = function(t) {
                var e = /^((?:\w+\/)*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/
                  , r = e.exec(t);
                if (!r)
                    throw new Error("cannot parse trackName at all: " + t);
                var i = {
                    nodeName: r[2],
                    objectName: r[3],
                    objectIndex: r[4],
                    propertyName: r[5],
                    propertyIndex: r[6]
                };
                if (null === i.propertyName || 0 === i.propertyName.length)
                    throw new Error("can not parse propertyName from trackName: " + t);
                return i
            }
            ,
            Hr.findNode = function(t, e) {
                if (!e || "" === e || "root" === e || "." === e || e === -1 || e === t.name || e === t.uuid)
                    return t;
                if (t.skeleton) {
                    var r = function(t) {
                        for (var r = 0; r < t.bones.length; r++) {
                            var i = t.bones[r];
                            if (i.name === e)
                                return i
                        }
                        return null
                    }
                      , i = r(t.skeleton);
                    if (i)
                        return i
                }
                if (t.children) {
                    var n = function(t) {
                        for (var r = 0; r < t.length; r++) {
                            var i = t[r];
                            if (i.name === e || i.uuid === e)
                                return i;
                            var o = n(i.children);
                            if (o)
                                return o
                        }
                        return null
                    }
                      , o = n(t.children);
                    if (o)
                        return o
                }
                return null
            }
            ,
            Wr.prototype = {
                constructor: Wr,
                isAnimationObjectGroup: !0,
                add: function(t) {
                    for (var e = this._objects, r = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, o = this._paths, a = this._parsedPaths, s = this._bindings, h = s.length, c = 0, l = arguments.length; c !== l; ++c) {
                        var u = arguments[c]
                          , p = u.uuid
                          , d = n[p];
                        if (void 0 === d) {
                            d = r++,
                            n[p] = d,
                            e.push(u);
                            for (var f = 0, m = h; f !== m; ++f)
                                s[f].push(new Hr(u,o[f],a[f]))
                        } else if (d < i) {
                            var g = e[d]
                              , v = --i
                              , y = e[v];
                            n[y.uuid] = d,
                            e[d] = y,
                            n[p] = v,
                            e[v] = u;
                            for (var f = 0, m = h; f !== m; ++f) {
                                var x = s[f]
                                  , b = x[v]
                                  , w = x[d];
                                x[d] = b,
                                void 0 === w && (w = new Hr(u,o[f],a[f])),
                                x[v] = w
                            }
                        } else
                            e[d] !== g && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                    }
                    this.nCachedObjects_ = i
                },
                remove: function(t) {
                    for (var e = this._objects, r = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, o = n.length, a = 0, s = arguments.length; a !== s; ++a) {
                        var h = arguments[a]
                          , c = h.uuid
                          , l = i[c];
                        if (void 0 !== l && l >= r) {
                            var u = r++
                              , p = e[u];
                            i[p.uuid] = l,
                            e[l] = p,
                            i[c] = u,
                            e[u] = h;
                            for (var d = 0, f = o; d !== f; ++d) {
                                var m = n[d]
                                  , g = m[u]
                                  , v = m[l];
                                m[l] = g,
                                m[u] = v
                            }
                        }
                    }
                    this.nCachedObjects_ = r
                },
                uncache: function(t) {
                    for (var e = this._objects, r = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, o = this._bindings, a = o.length, s = 0, h = arguments.length; s !== h; ++s) {
                        var c = arguments[s]
                          , l = c.uuid
                          , u = n[l];
                        if (void 0 !== u)
                            if (delete n[l],
                            u < i) {
                                var p = --i
                                  , d = e[p]
                                  , f = --r
                                  , m = e[f];
                                n[d.uuid] = u,
                                e[u] = d,
                                n[m.uuid] = p,
                                e[p] = m,
                                e.pop();
                                for (var g = 0, v = a; g !== v; ++g) {
                                    var y = o[g]
                                      , x = y[p]
                                      , b = y[f];
                                    y[u] = x,
                                    y[p] = b,
                                    y.pop()
                                }
                            } else {
                                var f = --r
                                  , m = e[f];
                                n[m.uuid] = u,
                                e[u] = m,
                                e.pop();
                                for (var g = 0, v = a; g !== v; ++g) {
                                    var y = o[g];
                                    y[u] = y[f],
                                    y.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = i
                },
                subscribe_: function(t, e) {
                    var r = this._bindingsIndicesByPath
                      , i = r[t]
                      , n = this._bindings;
                    if (void 0 !== i)
                        return n[i];
                    var o = this._paths
                      , a = this._parsedPaths
                      , s = this._objects
                      , h = s.length
                      , c = this.nCachedObjects_
                      , l = new Array(h);
                    i = n.length,
                    r[t] = i,
                    o.push(t),
                    a.push(e),
                    n.push(l);
                    for (var u = c, p = s.length; u !== p; ++u) {
                        var d = s[u];
                        l[u] = new Hr(d,t,e)
                    }
                    return l
                },
                unsubscribe_: function(t) {
                    var e = this._bindingsIndicesByPath
                      , r = e[t];
                    if (void 0 !== r) {
                        var i = this._paths
                          , n = this._parsedPaths
                          , o = this._bindings
                          , a = o.length - 1
                          , s = o[a]
                          , h = t[a];
                        e[h] = r,
                        o[r] = s,
                        o.pop(),
                        n[r] = n[a],
                        n.pop(),
                        i[r] = i[a],
                        i.pop()
                    }
                }
            },
            Xr.prototype = {
                constructor: Xr,
                play: function() {
                    return this._mixer._activateAction(this),
                    this
                },
                stop: function() {
                    return this._mixer._deactivateAction(this),
                    this.reset()
                },
                reset: function() {
                    return this.paused = !1,
                    this.enabled = !0,
                    this.time = 0,
                    this._loopCount = -1,
                    this._startTime = null,
                    this.stopFading().stopWarping()
                },
                isRunning: function() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                },
                isScheduled: function() {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function(t) {
                    return this._startTime = t,
                    this
                },
                setLoop: function(t, e) {
                    return this.loop = t,
                    this.repetitions = e,
                    this
                },
                setEffectiveWeight: function(t) {
                    return this.weight = t,
                    this._effectiveWeight = this.enabled ? t : 0,
                    this.stopFading()
                },
                getEffectiveWeight: function() {
                    return this._effectiveWeight
                },
                fadeIn: function(t) {
                    return this._scheduleFading(t, 0, 1)
                },
                fadeOut: function(t) {
                    return this._scheduleFading(t, 1, 0)
                },
                crossFadeFrom: function(t, e, r) {
                    if (t.fadeOut(e),
                    this.fadeIn(e),
                    r) {
                        var i = this._clip.duration
                          , n = t._clip.duration
                          , o = n / i
                          , a = i / n;
                        t.warp(1, o, e),
                        this.warp(a, 1, e)
                    }
                    return this
                },
                crossFadeTo: function(t, e, r) {
                    return t.crossFadeFrom(this, e, r)
                },
                stopFading: function() {
                    var t = this._weightInterpolant;
                    return null !== t && (this._weightInterpolant = null,
                    this._mixer._takeBackControlInterpolant(t)),
                    this
                },
                setEffectiveTimeScale: function(t) {
                    return this.timeScale = t,
                    this._effectiveTimeScale = this.paused ? 0 : t,
                    this.stopWarping()
                },
                getEffectiveTimeScale: function() {
                    return this._effectiveTimeScale
                },
                setDuration: function(t) {
                    return this.timeScale = this._clip.duration / t,
                    this.stopWarping()
                },
                syncWith: function(t) {
                    return this.time = t.time,
                    this.timeScale = t.timeScale,
                    this.stopWarping()
                },
                halt: function(t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                },
                warp: function(t, e, r) {
                    var i = this._mixer
                      , n = i.time
                      , o = this._timeScaleInterpolant
                      , a = this.timeScale;
                    null === o && (o = i._lendControlInterpolant(),
                    this._timeScaleInterpolant = o);
                    var s = o.parameterPositions
                      , h = o.sampleValues;
                    return s[0] = n,
                    s[1] = n + r,
                    h[0] = t / a,
                    h[1] = e / a,
                    this
                },
                stopWarping: function() {
                    var t = this._timeScaleInterpolant;
                    return null !== t && (this._timeScaleInterpolant = null,
                    this._mixer._takeBackControlInterpolant(t)),
                    this
                },
                getMixer: function() {
                    return this._mixer
                },
                getClip: function() {
                    return this._clip
                },
                getRoot: function() {
                    return this._localRoot || this._mixer._root
                },
                _update: function(t, e, r, i) {
                    var n = this._startTime;
                    if (null !== n) {
                        var o = (t - n) * r;
                        if (o < 0 || 0 === r)
                            return;
                        this._startTime = null,
                        e = r * o
                    }
                    e *= this._updateTimeScale(t);
                    var a = this._updateTime(e)
                      , s = this._updateWeight(t);
                    if (s > 0)
                        for (var h = this._interpolants, c = this._propertyBindings, l = 0, u = h.length; l !== u; ++l)
                            h[l].evaluate(a),
                            c[l].accumulate(i, s)
                },
                _updateWeight: function(t) {
                    var e = 0;
                    if (this.enabled) {
                        e = this.weight;
                        var r = this._weightInterpolant;
                        if (null !== r) {
                            var i = r.evaluate(t)[0];
                            e *= i,
                            t > r.parameterPositions[1] && (this.stopFading(),
                            0 === i && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = e,
                    e
                },
                _updateTimeScale: function(t) {
                    var e = 0;
                    if (!this.paused) {
                        e = this.timeScale;
                        var r = this._timeScaleInterpolant;
                        if (null !== r) {
                            var i = r.evaluate(t)[0];
                            e *= i,
                            t > r.parameterPositions[1] && (this.stopWarping(),
                            0 === e ? this.paused = !0 : this.timeScale = e)
                        }
                    }
                    return this._effectiveTimeScale = e,
                    e
                },
                _updateTime: function(t) {
                    var e = this.time + t;
                    if (0 === t)
                        return e;
                    var r = this._clip.duration
                      , i = this.loop
                      , n = this._loopCount;
                    if (i === na) {
                        n === -1 && (this.loopCount = 0,
                        this._setEndings(!0, !0, !1));
                        t: {
                            if (e >= r)
                                e = r;
                            else {
                                if (!(e < 0))
                                    break t;
                                e = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                        }
                    } else {
                        var o = i === aa;
                        if (n === -1 && (t >= 0 ? (n = 0,
                        this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)),
                        e >= r || e < 0) {
                            var a = Math.floor(e / r);
                            e -= r * a,
                            n += Math.abs(a);
                            var s = this.repetitions - n;
                            if (s < 0)
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                e = t > 0 ? r : 0,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                            else {
                                if (0 === s) {
                                    var h = t < 0;
                                    this._setEndings(h, !h, o)
                                } else
                                    this._setEndings(!1, !1, o);
                                this._loopCount = n,
                                this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: a
                                })
                            }
                        }
                        if (o && 1 === (1 & n))
                            return this.time = e,
                            r - e
                    }
                    return this.time = e,
                    e
                },
                _setEndings: function(t, e, r) {
                    var i = this._interpolantSettings;
                    r ? (i.endingStart = ua,
                    i.endingEnd = ua) : (t ? i.endingStart = this.zeroSlopeAtStart ? ua : la : i.endingStart = pa,
                    e ? i.endingEnd = this.zeroSlopeAtEnd ? ua : la : i.endingEnd = pa)
                },
                _scheduleFading: function(t, e, r) {
                    var i = this._mixer
                      , n = i.time
                      , o = this._weightInterpolant;
                    null === o && (o = i._lendControlInterpolant(),
                    this._weightInterpolant = o);
                    var a = o.parameterPositions
                      , s = o.sampleValues;
                    return a[0] = n,
                    s[0] = e,
                    a[1] = n + t,
                    s[1] = r,
                    this
                }
            },
            Object.assign(Yr.prototype, e.prototype, {
                clipAction: function(t, e) {
                    var r = e || this._root
                      , i = r.uuid
                      , n = "string" == typeof t ? fr.findByName(r, t) : t
                      , o = null !== n ? n.uuid : t
                      , a = this._actionsByClip[o]
                      , s = null;
                    if (void 0 !== a) {
                        var h = a.actionByRoot[i];
                        if (void 0 !== h)
                            return h;
                        s = a.knownActions[0],
                        null === n && (n = s._clip)
                    }
                    if (null === n)
                        return null;
                    var c = new Xr(this,n,e);
                    return this._bindAction(c, s),
                    this._addInactiveAction(c, o, i),
                    c
                },
                existingAction: function(t, e) {
                    var r = e || this._root
                      , i = r.uuid
                      , n = "string" == typeof t ? fr.findByName(r, t) : t
                      , o = n ? n.uuid : t
                      , a = this._actionsByClip[o];
                    return void 0 !== a ? a.actionByRoot[i] || null : null
                },
                stopAllAction: function() {
                    var t = this._actions
                      , e = this._nActiveActions
                      , r = this._bindings
                      , i = this._nActiveBindings;
                    this._nActiveActions = 0,
                    this._nActiveBindings = 0;
                    for (var n = 0; n !== e; ++n)
                        t[n].reset();
                    for (var n = 0; n !== i; ++n)
                        r[n].useCount = 0;
                    return this
                },
                update: function(t) {
                    t *= this.timeScale;
                    for (var e = this._actions, r = this._nActiveActions, i = this.time += t, n = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== r; ++a) {
                        var s = e[a];
                        s.enabled && s._update(i, t, n, o)
                    }
                    for (var h = this._bindings, c = this._nActiveBindings, a = 0; a !== c; ++a)
                        h[a].apply(o);
                    return this
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(t) {
                    var e = this._actions
                      , r = t.uuid
                      , i = this._actionsByClip
                      , n = i[r];
                    if (void 0 !== n) {
                        for (var o = n.knownActions, a = 0, s = o.length; a !== s; ++a) {
                            var h = o[a];
                            this._deactivateAction(h);
                            var c = h._cacheIndex
                              , l = e[e.length - 1];
                            h._cacheIndex = null,
                            h._byClipCacheIndex = null,
                            l._cacheIndex = c,
                            e[c] = l,
                            e.pop(),
                            this._removeInactiveBindingsForAction(h)
                        }
                        delete i[r]
                    }
                },
                uncacheRoot: function(t) {
                    var e = t.uuid
                      , r = this._actionsByClip;
                    for (var i in r) {
                        var n = r[i].actionByRoot
                          , o = n[e];
                        void 0 !== o && (this._deactivateAction(o),
                        this._removeInactiveAction(o))
                    }
                    var a = this._bindingsByRootAndName
                      , s = a[e];
                    if (void 0 !== s)
                        for (var h in s) {
                            var c = s[h];
                            c.restoreOriginalState(),
                            this._removeInactiveBinding(c)
                        }
                },
                uncacheAction: function(t, e) {
                    var r = this.existingAction(t, e);
                    null !== r && (this._deactivateAction(r),
                    this._removeInactiveAction(r))
                }
            }),
            Object.assign(Yr.prototype, {
                _bindAction: function(t, e) {
                    var r = t._localRoot || this._root
                      , i = t._clip.tracks
                      , n = i.length
                      , o = t._propertyBindings
                      , a = t._interpolants
                      , s = r.uuid
                      , h = this._bindingsByRootAndName
                      , c = h[s];
                    void 0 === c && (c = {},
                    h[s] = c);
                    for (var l = 0; l !== n; ++l) {
                        var u = i[l]
                          , p = u.name
                          , d = c[p];
                        if (void 0 !== d)
                            o[l] = d;
                        else {
                            if (d = o[l],
                            void 0 !== d) {
                                null === d._cacheIndex && (++d.referenceCount,
                                this._addInactiveBinding(d, s, p));
                                continue
                            }
                            var f = e && e._propertyBindings[l].binding.parsedPath;
                            d = new jr(Hr.create(r, p, f),u.ValueTypeName,u.getValueSize()),
                            ++d.referenceCount,
                            this._addInactiveBinding(d, s, p),
                            o[l] = d
                        }
                        a[l].resultBuffer = d.buffer
                    }
                },
                _activateAction: function(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            var e = (t._localRoot || this._root).uuid
                              , r = t._clip.uuid
                              , i = this._actionsByClip[r];
                            this._bindAction(t, i && i.knownActions[0]),
                            this._addInactiveAction(t, r, e)
                        }
                        for (var n = t._propertyBindings, o = 0, a = n.length; o !== a; ++o) {
                            var s = n[o];
                            0 === s.useCount++ && (this._lendBinding(s),
                            s.saveOriginalState())
                        }
                        this._lendAction(t)
                    }
                },
                _deactivateAction: function(t) {
                    if (this._isActiveAction(t)) {
                        for (var e = t._propertyBindings, r = 0, i = e.length; r !== i; ++r) {
                            var n = e[r];
                            0 === --n.useCount && (n.restoreOriginalState(),
                            this._takeBackBinding(n))
                        }
                        this._takeBackAction(t)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [],
                    this._nActiveActions = 0,
                    this._actionsByClip = {},
                    this._bindings = [],
                    this._nActiveBindings = 0,
                    this._bindingsByRootAndName = {},
                    this._controlInterpolants = [],
                    this._nActiveControlInterpolants = 0;
                    var t = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return t._actions.length
                            },
                            get inUse() {
                                return t._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return t._bindings.length
                            },
                            get inUse() {
                                return t._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return t._controlInterpolants.length
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(t) {
                    var e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions
                },
                _addInactiveAction: function(t, e, r) {
                    var i = this._actions
                      , n = this._actionsByClip
                      , o = n[e];
                    if (void 0 === o)
                        o = {
                            knownActions: [t],
                            actionByRoot: {}
                        },
                        t._byClipCacheIndex = 0,
                        n[e] = o;
                    else {
                        var a = o.knownActions;
                        t._byClipCacheIndex = a.length,
                        a.push(t)
                    }
                    t._cacheIndex = i.length,
                    i.push(t),
                    o.actionByRoot[r] = t
                },
                _removeInactiveAction: function(t) {
                    var e = this._actions
                      , r = e[e.length - 1]
                      , i = t._cacheIndex;
                    r._cacheIndex = i,
                    e[i] = r,
                    e.pop(),
                    t._cacheIndex = null;
                    var n = t._clip.uuid
                      , o = this._actionsByClip
                      , a = o[n]
                      , s = a.knownActions
                      , h = s[s.length - 1]
                      , c = t._byClipCacheIndex;
                    h._byClipCacheIndex = c,
                    s[c] = h,
                    s.pop(),
                    t._byClipCacheIndex = null;
                    var l = a.actionByRoot
                      , u = (e._localRoot || this._root).uuid;
                    delete l[u],
                    0 === s.length && delete o[n],
                    this._removeInactiveBindingsForAction(t)
                },
                _removeInactiveBindingsForAction: function(t) {
                    for (var e = t._propertyBindings, r = 0, i = e.length; r !== i; ++r) {
                        var n = e[r];
                        0 === --n.referenceCount && this._removeInactiveBinding(n)
                    }
                },
                _lendAction: function(t) {
                    var e = this._actions
                      , r = t._cacheIndex
                      , i = this._nActiveActions++
                      , n = e[i];
                    t._cacheIndex = i,
                    e[i] = t,
                    n._cacheIndex = r,
                    e[r] = n
                },
                _takeBackAction: function(t) {
                    var e = this._actions
                      , r = t._cacheIndex
                      , i = --this._nActiveActions
                      , n = e[i];
                    t._cacheIndex = i,
                    e[i] = t,
                    n._cacheIndex = r,
                    e[r] = n
                },
                _addInactiveBinding: function(t, e, r) {
                    var i = this._bindingsByRootAndName
                      , n = i[e]
                      , o = this._bindings;
                    void 0 === n && (n = {},
                    i[e] = n),
                    n[r] = t,
                    t._cacheIndex = o.length,
                    o.push(t)
                },
                _removeInactiveBinding: function(t) {
                    var e = this._bindings
                      , r = t.binding
                      , i = r.rootNode.uuid
                      , n = r.path
                      , o = this._bindingsByRootAndName
                      , a = o[i]
                      , s = e[e.length - 1]
                      , h = t._cacheIndex;
                    s._cacheIndex = h,
                    e[h] = s,
                    e.pop(),
                    delete a[n];
                    t: {
                        for (var c in a)
                            break t;
                        delete o[i]
                    }
                },
                _lendBinding: function(t) {
                    var e = this._bindings
                      , r = t._cacheIndex
                      , i = this._nActiveBindings++
                      , n = e[i];
                    t._cacheIndex = i,
                    e[i] = t,
                    n._cacheIndex = r,
                    e[r] = n
                },
                _takeBackBinding: function(t) {
                    var e = this._bindings
                      , r = t._cacheIndex
                      , i = --this._nActiveBindings
                      , n = e[i];
                    t._cacheIndex = i,
                    e[i] = t,
                    n._cacheIndex = r,
                    e[r] = n
                },
                _lendControlInterpolant: function() {
                    var t = this._controlInterpolants
                      , e = this._nActiveControlInterpolants++
                      , r = t[e];
                    return void 0 === r && (r = new ir(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
                    r.__cacheIndex = e,
                    t[e] = r),
                    r
                },
                _takeBackControlInterpolant: function(t) {
                    var e = this._controlInterpolants
                      , r = t.__cacheIndex
                      , i = --this._nActiveControlInterpolants
                      , n = e[i];
                    t.__cacheIndex = i,
                    e[i] = t,
                    n.__cacheIndex = r,
                    e[r] = n
                },
                _controlInterpolantsResultBuffer: new Float32Array(1)
            }),
            qr.prototype = {
                constructor: qr,
                onUpdate: function(t) {
                    return this.dynamic = !0,
                    this.onUpdateCallback = t,
                    this
                }
            },
            Zr.prototype = Object.create(Gt.prototype),
            Zr.prototype.constructor = Zr,
            Zr.prototype.isInstancedBufferGeometry = !0,
            Zr.prototype.addGroup = function(t, e, r) {
                this.groups.push({
                    start: t,
                    count: e,
                    instances: r
                })
            }
            ,
            Zr.prototype.copy = function(t) {
                var e = t.index;
                null !== e && this.setIndex(e.clone());
                var r = t.attributes;
                for (var i in r) {
                    var n = r[i];
                    this.addAttribute(i, n.clone())
                }
                for (var o = t.groups, a = 0, s = o.length; a < s; a++) {
                    var h = o[a];
                    this.addGroup(h.start, h.count, h.instances)
                }
                return this
            }
            ,
            Qr.prototype = {
                constructor: Qr,
                isInterleavedBufferAttribute: !0,
                get length() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
                    this.array.length
                },
                get count() {
                    return this.data.count
                },
                get array() {
                    return this.data.array
                },
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e,
                    this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e,
                    this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e,
                    this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e,
                    this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, r) {
                    return t = t * this.data.stride + this.offset,
                    this.data.array[t + 0] = e,
                    this.data.array[t + 1] = r,
                    this
                },
                setXYZ: function(t, e, r, i) {
                    return t = t * this.data.stride + this.offset,
                    this.data.array[t + 0] = e,
                    this.data.array[t + 1] = r,
                    this.data.array[t + 2] = i,
                    this
                },
                setXYZW: function(t, e, r, i, n) {
                    return t = t * this.data.stride + this.offset,
                    this.data.array[t + 0] = e,
                    this.data.array[t + 1] = r,
                    this.data.array[t + 2] = i,
                    this.data.array[t + 3] = n,
                    this
                }
            },
            Jr.prototype = {
                constructor: Jr,
                isInterleavedBuffer: !0,
                get length() {
                    return this.array.length
                },
                get count() {
                    return this.array.length / this.stride
                },
                set needsUpdate(t) {
                    t === !0 && this.version++
                },
                setDynamic: function(t) {
                    return this.dynamic = t,
                    this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array),
                    this.stride = t.stride,
                    this.dynamic = t.dynamic,
                    this
                },
                copyAt: function(t, e, r) {
                    t *= this.stride,
                    r *= e.stride;
                    for (var i = 0, n = this.stride; i < n; i++)
                        this.array[t + i] = e.array[r + i];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0),
                    this.array.set(t, e),
                    this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            },
            Kr.prototype = Object.create(Jr.prototype),
            Kr.prototype.constructor = Kr,
            Kr.prototype.isInstancedInterleavedBuffer = !0,
            Kr.prototype.copy = function(t) {
                return Jr.prototype.copy.call(this, t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            }
            ,
            $r.prototype = Object.create(Mt.prototype),
            $r.prototype.constructor = $r,
            $r.prototype.isInstancedBufferAttribute = !0,
            $r.prototype.copy = function(t) {
                return Mt.prototype.copy.call(this, t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            }
            ,
            ti.prototype = {
                constructor: ti,
                linePrecision: 1,
                set: function(t, e) {
                    this.ray.set(t, e)
                },
                setFromCamera: function(t, e) {
                    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                    this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                    this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function(t, e) {
                    var r = [];
                    return ri(t, this, r, e),
                    r.sort(ei),
                    r
                },
                intersectObjects: function(t, e) {
                    var r = [];
                    if (Array.isArray(t) === !1)
                        return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                        r;
                    for (var i = 0, n = t.length; i < n; i++)
                        ri(t[i], this, r, e);
                    return r.sort(ei),
                    r
                }
            },
            ii.prototype = {
                constructor: ii,
                start: function() {
                    this.startTime = (performance || Date).now(),
                    this.oldTime = this.startTime,
                    this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(),
                    this.running = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(),
                    this.elapsedTime
                },
                getDelta: function() {
                    var t = 0;
                    if (this.autoStart && !this.running && this.start(),
                    this.running) {
                        var e = (performance || Date).now();
                        t = (e - this.oldTime) / 1e3,
                        this.oldTime = e,
                        this.elapsedTime += t
                    }
                    return t
                }
            },
            oi.prototype = {
                constructor: oi,
                set: function(t, e, r) {
                    return this.radius = t,
                    this.phi = e,
                    this.theta = r,
                    this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.radius.copy(t.radius),
                    this.phi.copy(t.phi),
                    this.theta.copy(t.theta),
                    this
                },
                makeSafe: function() {
                    var t = 1e-6;
                    return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)),
                    this
                },
                setFromVector3: function(e) {
                    return this.radius = e.length(),
                    0 === this.radius ? (this.theta = 0,
                    this.phi = 0) : (this.theta = Math.atan2(e.x, e.z),
                    this.phi = Math.acos(t.Math.clamp(e.y / this.radius, -1, 1))),
                    this
                }
            },
            ai.prototype = Object.create(ie.prototype),
            ai.prototype.constructor = ai,
            ai.prototype.createAnimation = function(t, e, r, i) {
                var n = {
                    start: e,
                    end: r,
                    length: r - e + 1,
                    fps: i,
                    duration: (r - e) / i,
                    lastFrame: 0,
                    currentFrame: 0,
                    active: !1,
                    time: 0,
                    direction: 1,
                    weight: 1,
                    directionBackwards: !1,
                    mirroredLoop: !1
                };
                this.animationsMap[t] = n,
                this.animationsList.push(n)
            }
            ,
            ai.prototype.autoCreateAnimations = function(t) {
                for (var e, r = /([a-z]+)_?(\d+)/i, i = {}, n = this.geometry, o = 0, a = n.morphTargets.length; o < a; o++) {
                    var s = n.morphTargets[o]
                      , h = s.name.match(r);
                    if (h && h.length > 1) {
                        var c = h[1];
                        i[c] || (i[c] = {
                            start: 1 / 0,
                            end: -(1 / 0)
                        });
                        var l = i[c];
                        o < l.start && (l.start = o),
                        o > l.end && (l.end = o),
                        e || (e = c)
                    }
                }
                for (var c in i) {
                    var l = i[c];
                    this.createAnimation(c, l.start, l.end, t)
                }
                this.firstAnimation = e
            }
            ,
            ai.prototype.setAnimationDirectionForward = function(t) {
                var e = this.animationsMap[t];
                e && (e.direction = 1,
                e.directionBackwards = !1)
            }
            ,
            ai.prototype.setAnimationDirectionBackward = function(t) {
                var e = this.animationsMap[t];
                e && (e.direction = -1,
                e.directionBackwards = !0)
            }
            ,
            ai.prototype.setAnimationFPS = function(t, e) {
                var r = this.animationsMap[t];
                r && (r.fps = e,
                r.duration = (r.end - r.start) / r.fps)
            }
            ,
            ai.prototype.setAnimationDuration = function(t, e) {
                var r = this.animationsMap[t];
                r && (r.duration = e,
                r.fps = (r.end - r.start) / r.duration)
            }
            ,
            ai.prototype.setAnimationWeight = function(t, e) {
                var r = this.animationsMap[t];
                r && (r.weight = e)
            }
            ,
            ai.prototype.setAnimationTime = function(t, e) {
                var r = this.animationsMap[t];
                r && (r.time = e)
            }
            ,
            ai.prototype.getAnimationTime = function(t) {
                var e = 0
                  , r = this.animationsMap[t];
                return r && (e = r.time),
                e
            }
            ,
            ai.prototype.getAnimationDuration = function(t) {
                var e = -1
                  , r = this.animationsMap[t];
                return r && (e = r.duration),
                e
            }
            ,
            ai.prototype.playAnimation = function(t) {
                var e = this.animationsMap[t];
                e ? (e.time = 0,
                e.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()")
            }
            ,
            ai.prototype.stopAnimation = function(t) {
                var e = this.animationsMap[t];
                e && (e.active = !1)
            }
            ,
            ai.prototype.update = function(e) {
                for (var r = 0, i = this.animationsList.length; r < i; r++) {
                    var n = this.animationsList[r];
                    if (n.active) {
                        var o = n.duration / n.length;
                        n.time += n.direction * e,
                        n.mirroredLoop ? (n.time > n.duration || n.time < 0) && (n.direction *= -1,
                        n.time > n.duration && (n.time = n.duration,
                        n.directionBackwards = !0),
                        n.time < 0 && (n.time = 0,
                        n.directionBackwards = !1)) : (n.time = n.time % n.duration,
                        n.time < 0 && (n.time += n.duration));
                        var a = n.start + t.Math.clamp(Math.floor(n.time / o), 0, n.length - 1)
                          , s = n.weight;
                        a !== n.currentFrame && (this.morphTargetInfluences[n.lastFrame] = 0,
                        this.morphTargetInfluences[n.currentFrame] = 1 * s,
                        this.morphTargetInfluences[a] = 0,
                        n.lastFrame = n.currentFrame,
                        n.currentFrame = a);
                        var h = n.time % o / o;
                        n.directionBackwards && (h = 1 - h),
                        n.currentFrame !== n.lastFrame ? (this.morphTargetInfluences[n.currentFrame] = h * s,
                        this.morphTargetInfluences[n.lastFrame] = (1 - h) * s) : this.morphTargetInfluences[n.currentFrame] = s
                    }
                }
            }
            ,
            si.prototype = Object.create(Bt.prototype),
            si.prototype.constructor = si,
            si.prototype.isImmediateRenderObject = !0,
            hi.prototype = Object.create(Gt.prototype),
            hi.prototype.constructor = hi,
            ci.prototype = Object.create(_e.prototype),
            ci.prototype.constructor = ci,
            li.prototype = Object.create(_e.prototype),
            li.prototype.constructor = li,
            li.prototype.update = function() {
                var t = new s
                  , e = new s
                  , r = new it;
                return function() {
                    var i = ["a", "b", "c"];
                    this.object.updateMatrixWorld(!0),
                    r.getNormalMatrix(this.object.matrixWorld);
                    var n = this.object.matrixWorld
                      , o = this.geometry.attributes.position
                      , a = this.object.geometry;
                    if (a && a.isGeometry)
                        for (var s = a.vertices, h = a.faces, c = 0, l = 0, u = h.length; l < u; l++)
                            for (var p = h[l], d = 0, f = p.vertexNormals.length; d < f; d++) {
                                var m = s[p[i[d]]]
                                  , g = p.vertexNormals[d];
                                t.copy(m).applyMatrix4(n),
                                e.copy(g).applyMatrix3(r).normalize().multiplyScalar(this.size).add(t),
                                o.setXYZ(c, t.x, t.y, t.z),
                                c += 1,
                                o.setXYZ(c, e.x, e.y, e.z),
                                c += 1
                            }
                    else if (a && a.isBufferGeometry)
                        for (var v = a.attributes.position, y = a.attributes.normal, c = 0, d = 0, f = v.count; d < f; d++)
                            t.set(v.getX(d), v.getY(d), v.getZ(d)).applyMatrix4(n),
                            e.set(y.getX(d), y.getY(d), y.getZ(d)),
                            e.applyMatrix3(r).normalize().multiplyScalar(this.size).add(t),
                            o.setXYZ(c, t.x, t.y, t.z),
                            c += 1,
                            o.setXYZ(c, e.x, e.y, e.z),
                            c += 1;
                    return o.needsUpdate = !0,
                    this
                }
            }(),
            ui.prototype = Object.create(Bt.prototype),
            ui.prototype.constructor = ui,
            ui.prototype.dispose = function() {
                this.cone.geometry.dispose(),
                this.cone.material.dispose()
            }
            ,
            ui.prototype.update = function() {
                var t = new s
                  , e = new s;
                return function() {
                    var r = this.light.distance ? this.light.distance : 1e3
                      , i = r * Math.tan(this.light.angle);
                    this.cone.scale.set(i, i, r),
                    t.setFromMatrixPosition(this.light.matrixWorld),
                    e.setFromMatrixPosition(this.light.target.matrixWorld),
                    this.cone.lookAt(e.sub(t)),
                    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
                }
            }(),
            pi.prototype = Object.create(_e.prototype),
            pi.prototype.constructor = pi,
            pi.prototype.getBoneList = function(t) {
                var e = [];
                t && t.isBone && e.push(t);
                for (var r = 0; r < t.children.length; r++)
                    e.push.apply(e, this.getBoneList(t.children[r]));
                return e
            }
            ,
            pi.prototype.update = function() {
                for (var t = this.geometry, e = (new o).getInverse(this.root.matrixWorld), r = new o, i = 0, n = 0; n < this.bones.length; n++) {
                    var a = this.bones[n];
                    a.parent && a.parent.isBone && (r.multiplyMatrices(e, a.matrixWorld),
                    t.vertices[i].setFromMatrixPosition(r),
                    r.multiplyMatrices(e, a.parent.matrixWorld),
                    t.vertices[i + 1].setFromMatrixPosition(r),
                    i += 2)
                }
                t.verticesNeedUpdate = !0,
                t.computeBoundingSphere()
            }
            ,
            di.prototype = Object.create(Gt.prototype),
            di.prototype.constructor = di,
            fi.prototype = Object.create(ie.prototype),
            fi.prototype.constructor = fi,
            fi.prototype.dispose = function() {
                this.geometry.dispose(),
                this.material.dispose()
            }
            ,
            fi.prototype.update = function() {
                this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
            }
            ,
            mi.prototype = Object.create(kt.prototype),
            mi.prototype.constructor = mi,
            gi.prototype = Object.create(Bt.prototype),
            gi.prototype.constructor = gi,
            gi.prototype.dispose = function() {
                this.lightSphere.geometry.dispose(),
                this.lightSphere.material.dispose()
            }
            ,
            gi.prototype.update = function() {
                var t = new s;
                return function() {
                    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity),
                    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity),
                    this.lightSphere.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()),
                    this.lightSphere.geometry.colorsNeedUpdate = !0
                }
            }(),
            vi.prototype = Object.create(_e.prototype),
            vi.prototype.constructor = vi,
            vi.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }
            ,
            yi.prototype = Object.create(_e.prototype),
            yi.prototype.constructor = yi,
            yi.prototype.update = function() {
                var t = new s
                  , e = new s
                  , r = new it;
                return function() {
                    this.object.updateMatrixWorld(!0),
                    r.getNormalMatrix(this.object.matrixWorld);
                    for (var i = this.object.matrixWorld, n = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, h = 0, c = 0, l = s.length; c < l; c++) {
                        var u = s[c]
                          , p = u.normal;
                        t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(i),
                        e.copy(p).applyMatrix3(r).normalize().multiplyScalar(this.size).add(t),
                        n.setXYZ(h, t.x, t.y, t.z),
                        h += 1,
                        n.setXYZ(h, e.x, e.y, e.z),
                        h += 1
                    }
                    return n.needsUpdate = !0,
                    this
                }
            }(),
            xi.prototype = Object.create(Gt.prototype),
            xi.prototype.constructor = xi,
            bi.prototype = Object.create(_e.prototype),
            bi.prototype.constructor = bi,
            wi.prototype = Object.create(Bt.prototype),
            wi.prototype.constructor = wi,
            wi.prototype.dispose = function() {
                var t = this.children[0]
                  , e = this.children[1];
                t.geometry.dispose(),
                t.material.dispose(),
                e.geometry.dispose(),
                e.material.dispose()
            }
            ,
            wi.prototype.update = function() {
                var t = new s
                  , e = new s
                  , r = new s;
                return function() {
                    t.setFromMatrixPosition(this.light.matrixWorld),
                    e.setFromMatrixPosition(this.light.target.matrixWorld),
                    r.subVectors(e, t);
                    var i = this.children[0]
                      , n = this.children[1];
                    i.lookAt(r),
                    i.material.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                    n.lookAt(r),
                    n.scale.z = r.length()
                }
            }(),
            _i.prototype = Object.create(_e.prototype),
            _i.prototype.constructor = _i,
            _i.prototype.update = function() {
                function t(t, o, a, s) {
                    i.set(o, a, s).unproject(n);
                    var h = r[t];
                    if (void 0 !== h)
                        for (var c = 0, l = h.length; c < l; c++)
                            e.vertices[h[c]].copy(i)
                }
                var e, r, i = new s, n = new oe;
                return function() {
                    e = this.geometry,
                    r = this.pointMap;
                    var i = 1
                      , o = 1;
                    n.projectionMatrix.copy(this.camera.projectionMatrix),
                    t("c", 0, 0, -1),
                    t("t", 0, 0, 1),
                    t("n1", -i, -o, -1),
                    t("n2", i, -o, -1),
                    t("n3", -i, o, -1),
                    t("n4", i, o, -1),
                    t("f1", -i, -o, 1),
                    t("f2", i, -o, 1),
                    t("f3", -i, o, 1),
                    t("f4", i, o, 1),
                    t("u1", .7 * i, 1.1 * o, -1),
                    t("u2", .7 * -i, 1.1 * o, -1),
                    t("u3", 0, 2 * o, -1),
                    t("cf1", -i, 0, 1),
                    t("cf2", i, 0, 1),
                    t("cf3", 0, -o, 1),
                    t("cf4", 0, o, 1),
                    t("cn1", -i, 0, -1),
                    t("cn2", i, 0, -1),
                    t("cn3", 0, -o, -1),
                    t("cn4", 0, o, -1),
                    e.verticesNeedUpdate = !0
                }
            }(),
            Mi.prototype = Object.create(kt.prototype),
            Mi.prototype.constructor = Mi,
            Si.prototype = Object.create(ie.prototype),
            Si.prototype.constructor = Si,
            Si.prototype.update = function() {
                this.box.setFromObject(this.object),
                this.box.size(this.scale),
                this.box.center(this.position)
            }
            ,
            Ei.prototype = Object.create(_e.prototype),
            Ei.prototype.constructor = Ei,
            Ei.prototype.update = function() {
                var t = new et;
                return function(e) {
                    if (e && e.isBox3 ? t.copy(e) : t.setFromObject(e),
                    !t.isEmpty()) {
                        var r = t.min
                          , i = t.max
                          , n = this.geometry.attributes.position
                          , o = n.array;
                        o[0] = i.x,
                        o[1] = i.y,
                        o[2] = i.z,
                        o[3] = r.x,
                        o[4] = i.y,
                        o[5] = i.z,
                        o[6] = r.x,
                        o[7] = r.y,
                        o[8] = i.z,
                        o[9] = i.x,
                        o[10] = r.y,
                        o[11] = i.z,
                        o[12] = i.x,
                        o[13] = i.y,
                        o[14] = r.z,
                        o[15] = r.x,
                        o[16] = i.y,
                        o[17] = r.z,
                        o[18] = r.x,
                        o[19] = r.y,
                        o[20] = r.z,
                        o[21] = i.x,
                        o[22] = r.y,
                        o[23] = r.z,
                        n.needsUpdate = !0,
                        this.geometry.computeBoundingSphere()
                    }
                }
            }(),
            Ti.prototype = Object.create(Gt.prototype),
            Ti.prototype.constructor = Ti;
            var zh = new Gt;
            zh.addAttribute("position", new Pt([0, 0, 0, 0, 1, 0],3));
            var Vh = new Ti(0,.5,1,5,1);
            Vh.translate(0, -.5, 0),
            Ai.prototype = Object.create(Bt.prototype),
            Ai.prototype.constructor = Ai,
            Ai.prototype.setDirection = function() {
                var t, e = new s;
                return function(r) {
                    r.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : r.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(r.z, 0, -r.x).normalize(),
                    t = Math.acos(r.y),
                    this.quaternion.setFromAxisAngle(e, t))
                }
            }(),
            Ai.prototype.setLength = function(t, e, r) {
                void 0 === e && (e = .2 * t),
                void 0 === r && (r = .2 * e),
                this.line.scale.set(1, Math.max(0, t - e), 1),
                this.line.updateMatrix(),
                this.cone.scale.set(r, e, r),
                this.cone.position.y = t,
                this.cone.updateMatrix()
            }
            ,
            Ai.prototype.setColor = function(t) {
                this.line.material.color.copy(t),
                this.cone.material.color.copy(t)
            }
            ,
            Li.prototype = Object.create(_e.prototype),
            Li.prototype.constructor = Li,
            Ci.prototype = Object.create(kt.prototype),
            Ci.prototype.constructor = Ci,
            Ri.prototype = Object.create(kt.prototype),
            Ri.prototype.constructor = Ri,
            Pi.prototype = Object.create(Ri.prototype),
            Pi.prototype.constructor = Pi,
            Ui.prototype = Object.create(Ri.prototype),
            Ui.prototype.constructor = Ui,
            Ii.prototype = Object.create(Ri.prototype),
            Ii.prototype.constructor = Ii,
            Di.prototype = Object.create(Ri.prototype),
            Di.prototype.constructor = Di,
            Oi.prototype = Object.create(Gt.prototype),
            Oi.prototype.constructor = Oi,
            Ni.prototype = Object.create(kt.prototype),
            Ni.prototype.constructor = Ni,
            Bi.prototype = Object.create(Gt.prototype),
            Bi.prototype.constructor = Bi,
            Fi.prototype = Object.create(kt.prototype),
            Fi.prototype.constructor = Fi,
            ki.prototype = Object.create(Lr.prototype),
            ki.prototype.constructor = ki,
            zi.prototype = Object.create(Gt.prototype),
            zi.prototype.constructor = zi,
            Vi.prototype = Object.create(kt.prototype),
            Vi.prototype.constructor = Vi,
            Gi.prototype = Object.create(kt.prototype),
            Gi.prototype.constructor = Gi,
            ji.prototype = Object.create(Gt.prototype),
            ji.prototype.constructor = ji,
            Hi.prototype = Object.create(kt.prototype),
            Hi.prototype.constructor = Hi,
            Wi.prototype = Object.create(kt.prototype),
            Wi.prototype.constructor = Wi,
            Xi.prototype = Object.create(Wi.prototype),
            Xi.prototype.constructor = Xi,
            Yi.prototype = Object.create(Gt.prototype),
            Yi.prototype.constructor = Yi,
            qi.prototype = Object.create(Gt.prototype),
            qi.prototype.constructor = qi,
            Zi.prototype = Object.create(kt.prototype),
            Zi.prototype.constructor = Zi,
            t.CatmullRomCurve3 = function() {
                function t() {}
                var e = new s
                  , r = new t
                  , i = new t
                  , n = new t;
                return t.prototype.init = function(t, e, r, i) {
                    this.c0 = t,
                    this.c1 = r,
                    this.c2 = -3 * t + 3 * e - 2 * r - i,
                    this.c3 = 2 * t - 2 * e + r + i
                }
                ,
                t.prototype.initNonuniformCatmullRom = function(t, e, r, i, n, o, a) {
                    var s = (e - t) / n - (r - t) / (n + o) + (r - e) / o
                      , h = (r - e) / o - (i - e) / (o + a) + (i - r) / a;
                    s *= o,
                    h *= o,
                    this.init(e, r, s, h)
                }
                ,
                t.prototype.initCatmullRom = function(t, e, r, i, n) {
                    this.init(e, r, n * (r - t), n * (i - e))
                }
                ,
                t.prototype.calc = function(t) {
                    var e = t * t
                      , r = e * t;
                    return this.c0 + this.c1 * t + this.c2 * e + this.c3 * r
                }
                ,
                br.create(function(t) {
                    this.points = t || [],
                    this.closed = !1
                }, function(t) {
                    var o, a, h, c, l = this.points;
                    c = l.length,
                    c < 2 && console.log("duh, you need at least 2 points"),
                    o = (c - (this.closed ? 0 : 1)) * t,
                    a = Math.floor(o),
                    h = o - a,
                    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / l.length) + 1) * l.length : 0 === h && a === c - 1 && (a = c - 2,
                    h = 1);
                    var u, p, d, f;
                    if (this.closed || a > 0 ? u = l[(a - 1) % c] : (e.subVectors(l[0], l[1]).add(l[0]),
                    u = e),
                    p = l[a % c],
                    d = l[(a + 1) % c],
                    this.closed || a + 2 < c ? f = l[(a + 2) % c] : (e.subVectors(l[c - 1], l[c - 2]).add(l[c - 1]),
                    f = e),
                    void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                        var m = "chordal" === this.type ? .5 : .25
                          , g = Math.pow(u.distanceToSquared(p), m)
                          , v = Math.pow(p.distanceToSquared(d), m)
                          , y = Math.pow(d.distanceToSquared(f), m);
                        v < 1e-4 && (v = 1),
                        g < 1e-4 && (g = v),
                        y < 1e-4 && (y = v),
                        r.initNonuniformCatmullRom(u.x, p.x, d.x, f.x, g, v, y),
                        i.initNonuniformCatmullRom(u.y, p.y, d.y, f.y, g, v, y),
                        n.initNonuniformCatmullRom(u.z, p.z, d.z, f.z, g, v, y)
                    } else if ("catmullrom" === this.type) {
                        var x = void 0 !== this.tension ? this.tension : .5;
                        r.initCatmullRom(u.x, p.x, d.x, f.x, x),
                        i.initCatmullRom(u.y, p.y, d.y, f.y, x),
                        n.initCatmullRom(u.z, p.z, d.z, f.z, x)
                    }
                    var b = new s(r.calc(h),i.calc(h),n.calc(h));
                    return b
                })
            }(),
            Qi.prototype = Object.create(t.CatmullRomCurve3.prototype);
            var Gh = br.create(function(t) {
                console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"),
                this.points = void 0 === t ? [] : t
            }, function(e) {
                var r = this.points
                  , i = (r.length - 1) * e
                  , n = Math.floor(i)
                  , o = i - n
                  , a = r[0 == n ? n : n - 1]
                  , h = r[n]
                  , c = r[n > r.length - 2 ? r.length - 1 : n + 1]
                  , l = r[n > r.length - 3 ? r.length - 1 : n + 2]
                  , u = t.CurveUtils.interpolate;
                return new s(u(a.x, h.x, c.x, l.x, o),u(a.y, h.y, c.y, l.y, o),u(a.z, h.z, c.z, l.z, o))
            });
            t.CubicBezierCurve3 = br.create(function(t, e, r, i) {
                this.v0 = t,
                this.v1 = e,
                this.v2 = r,
                this.v3 = i
            }, function(e) {
                var r = t.ShapeUtils.b3;
                return new s(r(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x),r(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y),r(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
            }),
            t.QuadraticBezierCurve3 = br.create(function(t, e, r) {
                this.v0 = t,
                this.v1 = e,
                this.v2 = r
            }, function(e) {
                var r = t.ShapeUtils.b2;
                return new s(r(e, this.v0.x, this.v1.x, this.v2.x),r(e, this.v0.y, this.v1.y, this.v2.y),r(e, this.v0.z, this.v1.z, this.v2.z))
            }),
            t.LineCurve3 = br.create(function(t, e) {
                this.v1 = t,
                this.v2 = e
            }, function(t) {
                if (1 === t)
                    return this.v2.clone();
                var e = new s;
                return e.subVectors(this.v2, this.v1),
                e.multiplyScalar(t),
                e.add(this.v1),
                e
            }),
            Ji.prototype = Object.create(Mr.prototype),
            Ji.prototype.constructor = Ji,
            t.SceneUtils = {
                createMultiMaterialObject: function(t, e) {
                    for (var r = new Ee, i = 0, n = e.length; i < n; i++)
                        r.add(new ie(t,e[i]));
                    return r
                },
                detach: function(t, e, r) {
                    t.applyMatrix(e.matrixWorld),
                    e.remove(t),
                    r.add(t)
                },
                attach: function(t, e, r) {
                    var i = new o;
                    i.getInverse(r.matrixWorld),
                    t.applyMatrix(i),
                    e.remove(t),
                    r.add(t)
                }
            };
            var jh = 0
              , Hh = 1;
            Object.assign(c.prototype, {
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
                    this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(t)
                }
            }),
            Object.assign(et.prototype, {
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
                    this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                    this.intersectsSphere(t)
                }
            }),
            Object.assign(it.prototype, {
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
                    t.applyMatrix3(this)
                },
                multiplyVector3Array: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
                    this.applyToVector3Array(t)
                }
            }),
            Object.assign(o.prototype, {
                extractPosition: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
                    this.copyPosition(t)
                },
                setRotationFromQuaternion: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
                    this.makeRotationFromQuaternion(t)
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."),
                    t.applyProjection(this)
                },
                multiplyVector4: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                    t.applyMatrix4(this)
                },
                multiplyVector3Array: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
                    this.applyToVector3Array(t)
                },
                rotateAxis: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
                    t.transformDirection(this)
                },
                crossVector: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                    t.applyMatrix4(this)
                },
                translate: function(t) {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function(t) {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function(t) {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function(t) {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function(t, e) {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                }
            }),
            Object.assign(nt.prototype, {
                isIntersectionLine: function(t) {
                    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
                    this.intersectsLine(t)
                }
            }),
            Object.assign(a.prototype, {
                multiplyVector3: function(t) {
                    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
                    t.applyQuaternion(this)
                }
            }),
            Object.assign($t.prototype, {
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
                    this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                    this.intersectsSphere(t)
                }
            }),
            Object.assign(s.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
                    this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
                    this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
                    this.setFromMatrixColumn(e, t)
                }
            }),
            Object.assign(Bt.prototype, {
                getChildByName: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
                    this.getObjectByName(t)
                },
                renderDepth: function(t) {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
                    this.translateOnAxis(e, t)
                }
            }),
            Object.defineProperties(Bt.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                        this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                        this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }),
            Object.defineProperties(me.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                        this.levels
                    }
                }
            }),
            ae.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
                void 0 !== e && (this.filmGauge = e),
                this.setFocalLength(t)
            }
            ,
            Object.defineProperties(Xe.prototype, {
                onlyShadow: {
                    set: function(t) {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                        this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                        this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                        this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                        this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                        this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                        this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                        this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                        this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                        this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                        this.shadow.mapSize.height = t
                    }
                }
            }),
            Object.defineProperties(Mt.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
                        this.array.length
                    }
                }
            }),
            Object.assign(Gt.prototype, {
                addIndex: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
                    this.setIndex(t)
                },
                addDrawCall: function(t, e, r) {
                    void 0 !== r && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
                    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
                    this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
                    this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }),
            Object.defineProperties(Gt.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                        this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                        this.groups
                    }
                }
            }),
            Object.defineProperties(Q.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .wrapRGB has been removed."),
                        new $
                    }
                }
            }),
            Object.defineProperties(Oe.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                        !1
                    },
                    set: function(t) {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }),
            Object.defineProperties(K.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                        this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                        this.extensions.derivatives = t
                    }
                }
            }),
            e.prototype = Object.assign(Object.create({
                constructor: e,
                apply: function(t) {
                    console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in."),
                    Object.assign(t, this)
                }
            }), e.prototype),
            Object.assign(he.prototype, {
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
                    this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
                    this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
                    this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
                    this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
                    this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
                    this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
                    this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
                    this.setScissorTest(t)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                }
            }),
            Object.defineProperties(he.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                        this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                        this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        return this.shadowMap.cullFace
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."),
                        this.shadowMap.cullFace = t
                    }
                }
            }),
            Object.defineProperties(at.prototype, {
                cullFace: {
                    get: function() {
                        return this.renderReverseSided ? pn : un
                    },
                    set: function(t) {
                        var e = t !== un;
                        console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + e + "."),
                        this.renderReverseSided = e
                    }
                }
            }),
            Object.defineProperties(Z.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                        this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                        this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                        this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                        this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                        this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                        this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                        this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                        this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                        this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                        this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                        this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                        this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                        this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                        this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                        this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                        this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                        this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                        this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                        this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                        this.texture.generateMipmaps = t
                    }
                }
            }),
            Object.assign(zr.prototype, {
                load: function(t) {
                    console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
                    var e = this
                      , r = new Nr;
                    return r.load(t, function(t) {
                        e.setBuffer(t)
                    }),
                    this
                }
            }),
            Object.assign(Gr.prototype, {
                getData: function(t) {
                    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
                    this.getFrequencyData()
                }
            });
            var Wh = {
                merge: function(t, e, r) {
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                    var i;
                    e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(),
                    i = e.matrix,
                    e = e.geometry),
                    t.merge(e, i, r)
                },
                center: function(t) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
                    t.center()
                }
            }
              , Xh = {
                crossOrigin: void 0,
                loadTexture: function(t, e, r, i) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    var n = new We;
                    n.setCrossOrigin(this.crossOrigin);
                    var o = n.load(t, r, void 0, i);
                    return e && (o.mapping = e),
                    o
                },
                loadTextureCube: function(t, e, r, i) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    var n = new He;
                    n.setCrossOrigin(this.crossOrigin);
                    var o = n.load(t, r, void 0, i);
                    return e && (o.mapping = e),
                    o
                },
                loadCompressedTexture: function() {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                },
                loadCompressedTextureCube: function() {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }
            };
            Object.defineProperty(t, "AudioContext", {
                get: function() {
                    return t.getAudioContext()
                }
            }),
            t.SpritePlugin = h,
            t.LensFlarePlugin = l,
            t.WebGLUniforms = W,
            t.WebGLTextures = X,
            t.WebGLState = q,
            t.WebGLShadowMap = at,
            t.WebGLShader = ht,
            t.WebGLProperties = ct,
            t.WebGLPrograms = _t,
            t.WebGLProgram = wt,
            t.WebGLObjects = Ht,
            t.WebGLLights = Wt,
            t.WebGLGeometries = jt,
            t.WebGLCapabilities = Xt,
            t.WebGLExtensions = Yt,
            t.WebGLIndexedBufferRenderer = qt,
            t.WebGLClipping = Zt,
            t.WebGLBufferRenderer = Qt,
            t.WebGLRenderTargetCube = Jt,
            t.WebGLRenderTarget = Z,
            t.WebGLRenderer = he,
            t.ShaderLib = Uh,
            t.UniformsLib = Ph,
            t.ShaderChunk = Rh,
            t.FogExp2 = ce,
            t.Fog = le,
            t.Scene = ue,
            t.LensFlare = pe,
            t.Sprite = fe,
            t.LOD = me,
            t.SkinnedMesh = xe,
            t.Skeleton = ve,
            t.Bone = ye,
            t.Mesh = ie,
            t.LineSegments = _e,
            t.Line = we,
            t.Points = Se,
            t.Group = Ee,
            t.VideoTexture = Te,
            t.DataTexture = ge,
            t.CompressedTexture = Ae,
            t.CubeTexture = u,
            t.CanvasTexture = Le,
            t.DepthTexture = Ce,
            t.TextureIdCount = n,
            t.Texture = i,
            t.ShadowMaterial = Re,
            t.SpriteMaterial = de,
            t.RawShaderMaterial = Pe,
            t.ShaderMaterial = K,
            t.PointsMaterial = Me,
            t.MultiMaterial = Ue,
            t.MeshPhysicalMaterial = De,
            t.MeshStandardMaterial = Ie,
            t.MeshPhongMaterial = Oe,
            t.MeshNormalMaterial = Ne,
            t.MeshLambertMaterial = Be,
            t.MeshDepthMaterial = tt,
            t.MeshBasicMaterial = re,
            t.LineDashedMaterial = Fe,
            t.LineBasicMaterial = be,
            t.MaterialIdCount = J,
            t.Material = Q,
            t.CompressedTextureLoader = Ve,
            t.BinaryTextureLoader = Ge,
            t.DataTextureLoader = Nh,
            t.CubeTextureLoader = He,
            t.TextureLoader = We,
            t.ObjectLoader = xr,
            t.MaterialLoader = mr,
            t.BufferGeometryLoader = gr,
            t.LoadingManager = ke,
            t.JSONLoader = yr,
            t.ImageLoader = je,
            t.FontLoader = Dr,
            t.XHRLoader = ze,
            t.Loader = vr,
            t.AudioLoader = Nr,
            t.SpotLightShadow = Ze,
            t.SpotLight = Qe,
            t.PointLight = Je,
            t.HemisphereLight = Ye,
            t.DirectionalLightShadow = Ke,
            t.DirectionalLight = $e,
            t.AmbientLight = tr,
            t.LightShadow = qe,
            t.Light = Xe,
            t.StereoCamera = Br,
            t.PerspectiveCamera = ae,
            t.OrthographicCamera = se,
            t.CubeCamera = Fr,
            t.Camera = oe,
            t.AudioListener = kr,
            t.PositionalAudio = Vr,
            t.getAudioContext = Or,
            t.AudioAnalyser = Gr,
            t.Audio = zr,
            t.VectorKeyframeTrack = ar,
            t.StringKeyframeTrack = lr,
            t.QuaternionKeyframeTrack = hr,
            t.NumberKeyframeTrack = cr,
            t.ColorKeyframeTrack = pr,
            t.BooleanKeyframeTrack = ur,
            t.PropertyMixer = jr,
            t.PropertyBinding = Hr,
            t.KeyframeTrack = dr,
            t.AnimationObjectGroup = Wr,
            t.AnimationMixer = Yr,
            t.AnimationClip = fr,
            t.Uniform = qr,
            t.InstancedBufferGeometry = Zr,
            t.BufferGeometry = Gt,
            t.DirectGeometry = Vt,
            t.GeometryIdCount = zt,
            t.Geometry = kt,
            t.InterleavedBufferAttribute = Qr,
            t.InstancedInterleavedBuffer = Kr,
            t.InterleavedBuffer = Jr,
            t.InstancedBufferAttribute = $r,
            t.DynamicBufferAttribute = It,
            t.Float64Attribute = Ut,
            t.Float32Attribute = Pt,
            t.Uint32Attribute = Rt,
            t.Int32Attribute = Ct,
            t.Uint16Attribute = Lt,
            t.Int16Attribute = At,
            t.Uint8ClampedAttribute = Tt,
            t.Uint8Attribute = Et,
            t.Int8Attribute = St,
            t.BufferAttribute = Mt,
            t.Face3 = Dt,
            t.Object3DIdCount = Ft,
            t.Object3D = Bt,
            t.Raycaster = ti,
            t.Layers = Nt,
            t.EventDispatcher = e,
            t.Clock = ii,
            t.QuaternionLinearInterpolant = sr,
            t.LinearInterpolant = ir,
            t.DiscreteInterpolant = nr,
            t.CubicInterpolant = rr,
            t.Interpolant = er,
            t.Triangle = ee,
            t.Spline = ni,
            t.Spherical = oi,
            t.Plane = nt,
            t.Frustum = ot,
            t.Sphere = rt,
            t.Ray = $t,
            t.Matrix4 = o,
            t.Matrix3 = it,
            t.Box3 = et,
            t.Box2 = c,
            t.Line3 = te,
            t.Euler = Ot,
            t.Vector4 = Y,
            t.Vector3 = s,
            t.Vector2 = r,
            t.Quaternion = a,
            t.Color = $,
            t.MorphBlendMesh = ai,
            t.ImmediateRenderObject = si,
            t.WireframeHelper = ci,
            t.VertexNormalsHelper = li,
            t.SpotLightHelper = ui,
            t.SkeletonHelper = pi,
            t.PointLightHelper = fi,
            t.HemisphereLightHelper = gi,
            t.GridHelper = vi,
            t.FaceNormalsHelper = yi,
            t.EdgesHelper = bi,
            t.DirectionalLightHelper = wi,
            t.CameraHelper = _i,
            t.BoundingBoxHelper = Si,
            t.BoxHelper = Ei,
            t.ArrowHelper = Ai,
            t.AxisHelper = Li,
            t.WireframeGeometry = hi,
            t.ParametricGeometry = Ci,
            t.TetrahedronGeometry = Pi,
            t.OctahedronGeometry = Ui,
            t.IcosahedronGeometry = Ii,
            t.DodecahedronGeometry = Di,
            t.PolyhedronGeometry = Ri,
            t.TubeGeometry = Ar,
            t.TorusKnotGeometry = Ni,
            t.TorusKnotBufferGeometry = Oi,
            t.TorusGeometry = Fi,
            t.TorusBufferGeometry = Bi,
            t.TextGeometry = ki,
            t.SphereBufferGeometry = di,
            t.SphereGeometry = mi,
            t.RingGeometry = Vi,
            t.RingBufferGeometry = zi,
            t.PlaneBufferGeometry = ne,
            t.PlaneGeometry = Gi,
            t.LatheGeometry = Hi,
            t.LatheBufferGeometry = ji,
            t.ShapeGeometry = Cr;
            t.ExtrudeGeometry = Lr;
            t.EdgesGeometry = xi,
            t.ConeGeometry = Xi,
            t.ConeBufferGeometry = Yi,
            t.CylinderGeometry = Wi,
            t.CylinderBufferGeometry = Ti,
            t.CircleBufferGeometry = qi,
            t.CircleGeometry = Zi,
            t.BoxBufferGeometry = Kt,
            t.BoxGeometry = Mi,
            t.ClosedSplineCurve3 = Qi,
            t.SplineCurve3 = Gh,
            t.ArcCurve = Ji,
            t.EllipseCurve = Mr,
            t.SplineCurve = Sr,
            t.CubicBezierCurve = Er,
            t.QuadraticBezierCurve = Tr,
            t.LineCurve = wr,
            t.Shape = Rr,
            t.ShapePath = Ur,
            t.Path = Pr,
            t.Font = Ir,
            t.CurvePath = _r,
            t.Curve = br,
            t.REVISION = hn,
            t.MOUSE = cn,
            t.CullFaceNone = ln,
            t.CullFaceBack = un,
            t.CullFaceFront = pn,
            t.CullFaceFrontBack = dn,
            t.FrontFaceDirectionCW = fn,
            t.FrontFaceDirectionCCW = mn,
            t.BasicShadowMap = gn,
            t.PCFShadowMap = vn,
            t.PCFSoftShadowMap = yn,
            t.FrontSide = xn,
            t.BackSide = bn,
            t.DoubleSide = wn,
            t.FlatShading = _n,
            t.SmoothShading = Mn,
            t.NoColors = Sn,
            t.FaceColors = En,
            t.VertexColors = Tn,
            t.NoBlending = An,
            t.NormalBlending = Ln,
            t.AdditiveBlending = Cn,
            t.SubtractiveBlending = Rn,
            t.MultiplyBlending = Pn,
            t.CustomBlending = Un,
            t.AddEquation = In,
            t.SubtractEquation = Dn,
            t.ReverseSubtractEquation = On,
            t.MinEquation = Nn,
            t.MaxEquation = Bn,
            t.ZeroFactor = Fn,
            t.OneFactor = kn,
            t.SrcColorFactor = zn,
            t.OneMinusSrcColorFactor = Vn,
            t.SrcAlphaFactor = Gn,
            t.OneMinusSrcAlphaFactor = jn,
            t.DstAlphaFactor = Hn,
            t.OneMinusDstAlphaFactor = Wn,
            t.DstColorFactor = Xn,
            t.OneMinusDstColorFactor = Yn,
            t.SrcAlphaSaturateFactor = qn,
            t.NeverDepth = Zn,
            t.AlwaysDepth = Qn,
            t.LessDepth = Jn,
            t.LessEqualDepth = Kn,
            t.EqualDepth = $n,
            t.GreaterEqualDepth = to,
            t.GreaterDepth = eo,
            t.NotEqualDepth = ro,
            t.MultiplyOperation = io,
            t.MixOperation = no,
            t.AddOperation = oo,
            t.NoToneMapping = ao,
            t.LinearToneMapping = so,
            t.ReinhardToneMapping = ho,
            t.Uncharted2ToneMapping = co,
            t.CineonToneMapping = lo,
            t.UVMapping = uo,
            t.CubeReflectionMapping = po,
            t.CubeRefractionMapping = fo,
            t.EquirectangularReflectionMapping = mo,
            t.EquirectangularRefractionMapping = go,
            t.SphericalReflectionMapping = vo,
            t.CubeUVReflectionMapping = yo,
            t.CubeUVRefractionMapping = xo,
            t.RepeatWrapping = bo,
            t.ClampToEdgeWrapping = wo,
            t.MirroredRepeatWrapping = _o,
            t.NearestFilter = Mo,
            t.NearestMipMapNearestFilter = So,
            t.NearestMipMapLinearFilter = Eo,
            t.LinearFilter = To,
            t.LinearMipMapNearestFilter = Ao,
            t.LinearMipMapLinearFilter = Lo,
            t.UnsignedByteType = Co,
            t.ByteType = Ro,
            t.ShortType = Po,
            t.UnsignedShortType = Uo,
            t.IntType = Io,
            t.UnsignedIntType = Do,
            t.FloatType = Oo,
            t.HalfFloatType = No,
            t.UnsignedShort4444Type = Bo,
            t.UnsignedShort5551Type = Fo,
            t.UnsignedShort565Type = ko,
            t.UnsignedInt248Type = zo,
            t.AlphaFormat = Vo,
            t.RGBFormat = Go,
            t.RGBAFormat = jo,
            t.LuminanceFormat = Ho,
            t.LuminanceAlphaFormat = Wo,
            t.RGBEFormat = Xo,
            t.DepthFormat = Yo,
            t.DepthStencilFormat = qo,
            t.RGB_S3TC_DXT1_Format = Zo,
            t.RGBA_S3TC_DXT1_Format = Qo,
            t.RGBA_S3TC_DXT3_Format = Jo,
            t.RGBA_S3TC_DXT5_Format = Ko,
            t.RGB_PVRTC_4BPPV1_Format = $o,
            t.RGB_PVRTC_2BPPV1_Format = ta,
            t.RGBA_PVRTC_4BPPV1_Format = ea,
            t.RGBA_PVRTC_2BPPV1_Format = ra,
            t.RGB_ETC1_Format = ia,
            t.LoopOnce = na,
            t.LoopRepeat = oa,
            t.LoopPingPong = aa,
            t.InterpolateDiscrete = sa,
            t.InterpolateLinear = ha,
            t.InterpolateSmooth = ca,
            t.ZeroCurvatureEnding = la,
            t.ZeroSlopeEnding = ua,
            t.WrapAroundEnding = pa,
            t.TrianglesDrawMode = da,
            t.TriangleStripDrawMode = fa,
            t.TriangleFanDrawMode = ma,
            t.LinearEncoding = ga,
            t.sRGBEncoding = va,
            t.GammaEncoding = ya,
            t.RGBEEncoding = xa,
            t.LogLuvEncoding = ba,
            t.RGBM7Encoding = wa,
            t.RGBM16Encoding = _a,
            t.RGBDEncoding = Ma,
            t.BasicDepthPacking = Sa,
            t.RGBADepthPacking = Ea,
            t.CubeGeometry = Mi,
            t.Face4 = Ki,
            t.LineStrip = jh,
            t.LinePieces = Hh,
            t.MeshFaceMaterial = Ue,
            t.PointCloud = $i,
            t.Particle = fe,
            t.ParticleSystem = tn,
            t.PointCloudMaterial = en,
            t.ParticleBasicMaterial = rn,
            t.ParticleSystemMaterial = nn,
            t.Vertex = on,
            t.GeometryUtils = Wh,
            t.ImageUtils = Xh,
            t.Projector = an,
            t.CanvasRenderer = sn,
            Object.defineProperty(t, "__esModule", {
                value: !0
            })
        })
    }
    , {}],
    10: [function(t, e, r) {
        !function() {
            "use strict";
            function e() {
                window.alert("File read aborted.")
            }
            function r(t) {
                var e;
                switch (t.target.error.name) {
                case "NotFoundError":
                    e = "The file could not be found at the time the read was processed.";
                    break;
                case "SecurityError":
                    e = "<p>A file security error occured. This can be due to:</p>",
                    e += "<ul><li>Accessing certain files deemed unsafe for Web applications.</li>",
                    e += "<li>Performing too many read calls on file resources.</li>",
                    e += "<li>The file has changed on disk since the user selected it.</li></ul>";
                    break;
                case "NotReadableError":
                    e = "The file cannot be read. This can occur if the file is open in another application.";
                    break;
                case "EncodingError":
                    e = "The length of the data URL for the file is too long.";
                    break;
                default:
                    e = "File error code " + t.target.error.name
                }
                window.alert(e)
            }
            function i(t, e) {
                var r = new s(e.target.result,0,e.size);
                E = new c.Pattern,
                t = t.toLowerCase(),
                t.endsWith("dst") ? l.read(r, E) : t.endsWith("exp") ? u.read(r, E) : t.endsWith("exy") ? p.read(r, E) : t.endsWith("jef") ? d.read(r, E) : t.endsWith("pcs") ? f.read(r, E) : t.endsWith("pec") ? m.read(r, E) : t.endsWith("pes") ? g.read(r, E) : t.endsWith("sew") ? v.read(r, E) : t.endsWith("vp3") ? y.read(r, E) : t.endsWith("xxx") ? x.read(r, E) : (t.endsWith("zsk") || t.endsWith("z00")) && b.read(r, E),
                document.getElementById("saveFile").disabled = !1,
                T.show(E)
            }
            function n(t) {
                var n = new FileReader;
                n.onloadend = function(e) {
                    i.apply(null, [t.name, e])
                }
                ,
                n.abort = e,
                n.onerror = r,
                t && n.readAsArrayBuffer(t)
            }
            function o(t) {
                var e, r;
                if (t.stopPropagation(),
                t.preventDefault(),
                e = t.dataTransfer ? t.dataTransfer.files : t.target.files,
                !e)
                    return void window.alert("<p>At least one selected file is invalid - do not select any folders.</p><p>Please reselect and try again.</p>");
                for (var i = 0; i < e.length; i++)
                    r = e[i],
                    r ? 0 !== r.size ? n(r) : window.alert("Skipping " + r.name.toUpperCase() + " because it is empty.") : window.alert("Unable to access " + r.name)
            }
            function a(t, e) {
                var r = m
                  , i = r.write(t.getInvertedPattern(), e);
                if (i.success) {
                    var n = i.file
                      , o = n._offset;
                    n.position = 0;
                    var a = new Uint8Array(n.getBytes(o, 0, !0, !0))
                      , s = new Blob([a.buffer],{
                        type: "application/octet-binary"
                    });
                    h.saveAs(s, e + r.extension)
                } else
                    console.log(i.message)
            }
            var s = t("jdataview")
              , h = t("file-saver")
              , c = t("./embroidery.js")()
              , l = t("./dstformat.js")()
              , u = t("./expformat.js")()
              , p = t("./exyformat.js")()
              , d = t("./jefformat.js")()
              , f = t("./pcsformat.js")()
              , m = t("./pecformat.js")()
              , g = t("./pesformat.js")()
              , v = t("./sewformat.js")()
              , y = t("./vp3format.js")()
              , x = t("./xxxformat.js")()
              , b = t("./zskformat.js")()
              , w = t("./display3d.js")()
              , _ = t("./display2d.js")()
              , M = ""
              , S = !1
              , E = null
              , T = _;
            document.getElementById("saveFile").disabled = !0,
            document.getElementById("renderAs").onclick = function() {
                S = !S,
                null !== E && (S === !0 ? (T.hide(),
                T = w,
                T.show(E)) : (T.hide(),
                T = _,
                T.show(E)))
            }
            ,
            window.FileReader ? document.getElementById("files").addEventListener("change", o, !1) : (M = '<p>The <a href="http://dev.w3.org/2006/webapi/FileAPI/" target="_blank">File API</a>s are not fully supported by this browser.</p><p>Upgrade your browser to the latest version.</p>',
            document.querySelector("body").innerHTML = M),
            String.prototype.endsWith = function(t) {
                return this.indexOf(t, this.length - t.length) !== -1
            }
            ,
            document.getElementById("saveFile").onclick = function() {
                a(E, "data")
            }
        }()
    }
    , {
        "./display2d.js": 11,
        "./display3d.js": 12,
        "./dstformat.js": 13,
        "./embroidery.js": 14,
        "./expformat.js": 15,
        "./exyformat.js": 16,
        "./jefformat.js": 17,
        "./pcsformat.js": 18,
        "./pecformat.js": 19,
        "./pesformat.js": 20,
        "./sewformat.js": 21,
        "./vp3format.js": 22,
        "./xxxformat.js": 23,
        "./zskformat.js": 24,
        "file-saver": 3,
        jdataview: 6
    }],
    11: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            var t = {
                show: function(t) {
                    t.moveToPositive();
                    var e = document.getElementById("theCanvas");
                    t.drawShape(e),
                    e.style.display = "block"
                },
                hide: function() {
                    var t = document.getElementById("theCanvas");
                    t.getContext("2d").clearRect(0, 0, t.width, t.height),
                    t.style.display = "block"
                }
            };
            return t
        }
    }
    , {}],
    12: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t) {
                for (var e = [], r = 0; r < t.length; r++) {
                    var i = t[r]
                      , n = [];
                    if (i.points.length > 0) {
                        for (var o = 0; o < i.points.length; o++) {
                            var a = i.points[o];
                            n.push(new f.Vector3(a.x,a.y,a.z))
                        }
                        var s = new f.CatmullRomCurve3(n);
                        s.dynamic = !0;
                        var h = new f.TubeGeometry(s,4 * n.length,2.5,4,(!1),(!1))
                          , c = i.color.r << 16 | i.color.g << 8 | i.color.b
                          , l = new f.Mesh(h,new f.MeshPhongMaterial({
                            color: c,
                            specular: 328965,
                            shininess: 0
                        }));
                        l.name = "actualTube" + r.toString(),
                        e.push(l)
                    }
                }
                return e
            }
            function r() {
                c.aspect = window.innerWidth / window.innerHeight,
                c.updateProjectionMatrix(),
                u.setSize(window.innerWidth, window.innerHeight)
            }
            function i() {
                u = new f.WebGLRenderer({
                    antialiasing: !0
                }),
                u.setSize(window.innerWidth, window.innerHeight),
                document.body.appendChild(u.domElement),
                c = new f.PerspectiveCamera(45,window.innerWidth / window.innerHeight,1,1e4),
                c.position.set(0, 0, 1e3),
                l = new f.Scene,
                p = new f.PointLight(16777215),
                p.position.x = 100,
                p.position.y = 100,
                p.position.z = 250,
                l.add(p),
                h = new m(c,u.domElement),
                h.rotateSpeed = 1,
                h.zoomSpeed = 1.2,
                h.panSpeed = .8,
                h.noZoom = !1,
                h.noPan = !1,
                h.staticMoving = !0,
                h.dynamicDampingFactor = .3,
                h.target.set(0, 0, 0),
                window.addEventListener("resize", r, !1)
            }
            function n() {
                var t = v.getDelta();
                h.update(t),
                u.render(l, c)
            }
            function o() {
                d = window.requestAnimationFrame(o),
                n()
            }
            function a(t) {
                i();
                for (var r = e(t.drawShape3d()), n = 0; n < r.length; n++)
                    l.add(r[n]);
                o()
            }
            function s() {
                cancelAnimationFrame(d),
                u.domElement.addEventListener("dblclick", null, !1),
                l = null,
                c = null,
                h = null,
                p = null
            }
            var h, c, l, u, p, d, f = t("three"), m = t("three-trackballcontrols"), g = {}, v = new f.Clock;
            return g.show = a,
            g.hide = s,
            g
        }
    }
    , {
        three: 9,
        "three-trackballcontrols": 7
    }],
    13: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t) {
                var e = 0;
                return 243 === t ? o.stitchTypes.end : 195 === (195 & t) ? o.stitchTypes.trim | o.stitchTypes.stop : (128 & t && (e |= o.stitchTypes.trim),
                64 & t && (e |= o.stitchTypes.stop),
                e)
            }
            function r(t) {
                return 1 << t
            }
            function i(t, e, i, n) {
                var a = 0
                  , s = 0
                  , h = 0;
                e = Math.round(e),
                i = Math.round(i),
                e >= 41 && (h += r(2),
                e -= 81),
                e <= -41 && (h += r(3),
                e += 81),
                e >= 14 && (s += r(2),
                e -= 27),
                e <= -14 && (s += r(3),
                e += 27),
                e >= 5 && (a += r(2),
                e -= 9),
                e <= -5 && (a += r(3),
                e += 9),
                e >= 2 && (s += r(0),
                e -= 3),
                e <= -2 && (s += r(1),
                e += 3),
                e >= 1 && (a += r(0),
                e -= 1),
                e <= -1 && (a += r(1),
                e += 1),
                i >= 41 && (h += r(5),
                i -= 81),
                i <= -41 && (h += r(4),
                i += 81),
                i >= 14 && (s += r(5),
                i -= 27),
                i <= -14 && (s += r(4),
                i += 27),
                i >= 5 && (a += r(5),
                i -= 9),
                i <= -5 && (a += r(4),
                i += 9),
                i >= 2 && (s += r(7),
                i -= 3),
                i <= -2 && (s += r(6),
                i += 3),
                i >= 1 && (a += r(7),
                i -= 1),
                i <= -1 && (a += r(6),
                i += 1),
                h |= 3,
                n & o.stitchTypes.end && (h = 243,
                a = 0,
                s = 0),
                n & (o.stitchTypes.jump | o.stitchTypes.trim) && (h = 131 | h),
                n & o.stitchTypes.stop && (h = 195 | h),
                t.writeUint8(a),
                t.writeUint8(s),
                t.writeUint8(h)
            }
            function n(t, e, r, i) {
                var n, o = r.toString();
                for (t.writeString(e),
                n = 0; n < i - o.length; n += 1)
                    t.writeUint8(50);
                t.writeString(o),
                t.writeUint8(13)
            }
            var o = t("./embroidery.js")()
              , a = {
                extension: ".dst",
                canRead: !0,
                canWrite: !1
            };
            return a.read = function(t, r) {
                var i, n, a, s = !1, h = !1, c = [], l = t.byteLength;
                for (t.seek(512); t.tell() < l - 3; )
                    c[0] = t.getUint8(),
                    c[1] = t.getUint8(),
                    c[2] = t.getUint8(),
                    n = 0,
                    a = 0,
                    1 & c[0] && (n += 1),
                    2 & c[0] && (n -= 1),
                    4 & c[0] && (n += 9),
                    8 & c[0] && (n -= 9),
                    128 & c[0] && (a += 1),
                    64 & c[0] && (a -= 1),
                    32 & c[0] && (a += 9),
                    16 & c[0] && (a -= 9),
                    1 & c[1] && (n += 3),
                    2 & c[1] && (n -= 3),
                    4 & c[1] && (n += 27),
                    8 & c[1] && (n -= 27),
                    128 & c[1] && (a += 3),
                    64 & c[1] && (a -= 3),
                    32 & c[1] && (a += 27),
                    16 & c[1] && (a -= 27),
                    4 & c[2] && (n += 81),
                    8 & c[2] && (n -= 81),
                    32 & c[2] && (a += 81),
                    16 & c[2] && (a -= 81),
                    i = e(c[2]),
                    h = i & o.stitchTypes.jump,
                    s && (i |= o.stitchTypes.jump),
                    r.addStitchRel(n, a, i, !0),
                    s = h;
                r.addStitchRel(0, 0, o.stitchTypes.end, !0),
                r.invertPatternVertical()
            }
            ,
            a.write = function(t) {
                var e, r, a, s, h, c, l, u = 1, p = 0;
                if (!t)
                    return {
                        success: !1,
                        file: null,
                        message: "pattern argument is null"
                    };
                if (t.colors.length > 16)
                    return {
                        success: !1,
                        file: null,
                        message: "Error PCS does not support greater that 16 colors"
                    };
                if (0 === t.stitches.length)
                    return {
                        success: !1,
                        file: null,
                        message: "pattern contains no stitches"
                    };
                for (t.invertPatternVertical(),
                e = new jDataView(1e5),
                a = 0,
                s = 0,
                u = 1,
                u = t.colors.length,
                p = 0,
                p = t.stitches.length,
                l = o.stitchTypes.normal,
                t.calculateBoundingBox(),
                n(e, "LA:Untitled        ", "Untitled", 0, 0),
                n(e, "ST:", p, 7),
                n(e, "CO:", u - 1, 3),
                n(e, "+X:", +(10 * t.right), 5),
                n(e, "-X:", +(10 * Math.abs(t.left)), 5),
                n(e, "+Y:", +(10 * t.bottom), 5),
                n(e, "-Y:", +(10 * Math.abs(t.top)), 5),
                n(e, "AX:    0", 0, 0),
                n(e, "AY:    0", 0, 0),
                n(e, "MX:    0", 0, 0),
                n(e, "MY:    0", 0, 0),
                n(e, "PD:******", 0, 0),
                e.WriteUint8(26),
                r = 125; r < 512; r++)
                    e.WriteUint8(50);
                for (a = 0,
                s = 0,
                r = 0; r < t.stitches.length; r += 1) {
                    var d = t.stitches[r];
                    h = 10 * d.X - a,
                    c = 10 * d.Y - s,
                    a = 10 * d.X,
                    s = 10 * d.Y,
                    l = d.flags,
                    i(e, h, c, l)
                }
                return e.WriteUint8(161),
                e.WriteUint16(0),
                {
                    success: !0,
                    file: e,
                    message: ""
                }
            }
            ,
            a
        }
    }
    , {
        "./embroidery.js": 14
    }],
    14: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function t(t, e) {
                return Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)
            }
            function e(t, e, r, i) {
                var n, o, a, s, h = {
                    x: null,
                    y: null,
                    b: !1
                }, c = (i.y - r.y) * (e.x - t.x) - (i.x - r.x) * (e.y - t.y);
                return 0 === c ? h : (n = t.y - r.y,
                o = t.x - r.x,
                a = (i.x - r.x) * n - (i.y - r.y) * o,
                s = (e.x - t.x) * n - (e.y - t.y) * o,
                n = a / c,
                o = s / c,
                h.x = t.x + n * (e.x - t.x),
                h.y = t.y + n * (e.y - t.y),
                h.b = n > 0 && n < 1 && o > 0 && o < 1,
                h)
            }
            function r(t, e) {
                return t.distance < e.distance ? 1 : t.distance > e.distance ? -1 : 0
            }
            var i = {};
            return i.Stitch = function(t, e, r, i) {
                this.flags = r,
                this.x = t,
                this.y = e,
                this.color = i
            }
            ,
            i.log = function(t) {
                console.log(t)
            }
            ,
            i.BoundingBox = function(t, e, r, i) {
                this.minX = t,
                this.minY = e,
                this.maxX = r,
                this.maxY = i
            }
            ,
            i.Color = function(t, e, r, i) {
                this.r = t,
                this.g = e,
                this.b = r,
                this.description = i,
                this.findNearestColorIndex = function(t) {
                    var e, r, i, n, o, a, s = 9999999, h = -1;
                    for (e = 0; e < t.length; e += 1)
                        o = t[e],
                        r = this.r - o.r,
                        i = this.g - o.g,
                        n = this.b - o.b,
                        a = r * r + i * i + n * n,
                        a <= s && (s = a,
                        h = e);
                    return h
                }
            }
            ,
            i.stitchTypes = {
                normal: 0,
                jump: 1,
                trim: 2,
                stop: 4,
                end: 8
            },
            i.Pattern = function() {
                this.colors = [],
                this.stitches = [],
                this.hoop = {},
                this.lastX = 0,
                this.lastY = 0,
                this.top = 0,
                this.bottom = 0,
                this.left = 0,
                this.right = 0,
                this.currentColorIndex = 0
            }
            ,
            i.Pattern.prototype.width = function() {
                return this.right - this.left
            }
            ,
            i.Pattern.prototype.height = function() {
                return this.bottom - this.top
            }
            ,
            i.Pattern.prototype.addColorRgb = function(t, e, r, n) {
                this.colors[this.colors.length] = new i.Color(t,e,r,n)
            }
            ,
            i.Pattern.prototype.addColor = function(t) {
                this.colors[this.colors.length] = t
            }
            ,
            i.Pattern.prototype.addStitchAbs = function(t, e, r, n) {
                (r & i.stitchTypes.end) === i.stitchTypes.end && (this.calculateBoundingBox(),
                this.fixColorCount()),
                (r & i.stitchTypes.stop) === i.stitchTypes.stop && 0 === this.stitches.length || ((r & i.stitchTypes.stop) === i.stitchTypes.stop && n && (this.currentColorIndex += 1),
                this.stitches[this.stitches.length] = new i.Stitch(t,e,r,this.currentColorIndex))
            }
            ,
            i.Pattern.prototype.addStitchRel = function(t, e, r, i) {
                if (0 !== this.stitches.length) {
                    var n = this.lastX + t
                      , o = this.lastY + e;
                    this.lastX = n,
                    this.lastY = o,
                    this.addStitchAbs(n, o, r, i)
                } else
                    this.addStitchAbs(t, e, r, i)
            }
            ,
            i.Pattern.prototype.calculateBoundingBox = function() {
                var t, e, r = this.stitches.length;
                if (0 === r)
                    return this.bottom = 1,
                    void (this.right = 1);
                for (this.left = 99999,
                this.top = 99999,
                this.right = -99999,
                this.bottom = -99999,
                t = 0; t < r; t += 1)
                    e = this.stitches[t],
                    e.flags & i.stitchTypes.trim || (this.left = this.left < e.x ? this.left : e.x,
                    this.top = this.top < e.y ? this.top : e.y,
                    this.right = this.right > e.x ? this.right : e.x,
                    this.bottom = this.bottom > e.y ? this.bottom : e.y)
            }
            ,
            i.Pattern.prototype.moveToPositive = function() {
                var t, e = this.stitches.length;
                for (t = 0; t < e; t += 1)
                    this.stitches[t].x -= this.left,
                    this.stitches[t].y -= this.top;
                this.right -= this.left,
                this.left = 0,
                this.bottom -= this.top,
                this.top = 0
            }
            ,
            i.Pattern.prototype.moveToCenter = function() {
                var t, e = this.stitches.length, r = (this.right + this.left) / 2, i = (this.bottom + this.top) / 2;
                for (t = 0; t < e; t += 1)
                    this.stitches[t].x -= r,
                    this.stitches[t].y -= i;
                this.right -= r,
                this.left -= r,
                this.bottom -= i,
                this.top -= i
            }
            ,
            i.Pattern.prototype.invertPatternVertical = function() {
                var t, e = -this.top, r = this.stitches.length;
                for (t = 0; t < r; t += 1)
                    this.stitches[t].y = -this.stitches[t].y;
                this.top = -this.bottom,
                this.bottom = e
            }
            ,
            i.Pattern.prototype.getInvertedPattern = function() {
                var t, e, r, n = this.stitches.length;
                for (e = new i.Pattern,
                t = 0; t < this.colors.length; t += 1)
                    r = this.colors[t],
                    e.addColorRgb(r.r, r.g, r.b);
                for (t = 0; t < n; t += 1)
                    r = this.stitches[t],
                    e.addStitchAbs(r.x, -r.y, r.flags);
                return e
            }
            ,
            i.Pattern.prototype.addColorRandom = function() {
                this.colors[this.colors.length] = new i.Color(Math.round(256 * Math.random()),Math.round(256 * Math.random()),Math.round(256 * Math.random()),"random")
            }
            ,
            i.Pattern.prototype.changeColor = function(t) {
                this.currentColorIndex = t
            }
            ,
            i.Pattern.prototype.fixColorCount = function() {
                var t, e = 0, r = this.stitches.length;
                for (t = 0; t < r; t += 1)
                    e = Math.max(e, this.stitches[t].color);
                for (; this.colors.length <= e; )
                    this.addColorRandom();
                this.colors.splice(e + 1, this.colors.length - e - 1)
            }
            ,
            i.Pattern.prototype.drawShape = function(t) {
                var e, r, n, o;
                if (t.width = this.right,
                t.height = this.bottom,
                0 !== this.stitches.length)
                    if (t.getContext) {
                        for (r = this.colors[this.stitches[0].color],
                        n = t.getContext("2d"),
                        n.beginPath(),
                        n.strokeStyle = "rgb(" + r.r + "," + r.g + "," + r.b + ")",
                        e = 0; e < this.stitches.length; e += 1)
                            o = this.stitches[e],
                            o.flags !== i.stitchTypes.jump && o.flags !== i.stitchTypes.trim && o.flags !== i.stitchTypes.stop || (n.stroke(),
                            r = this.colors[o.color],
                            n.beginPath(),
                            n.strokeStyle = "rgb(" + r.r + "," + r.g + "," + r.b + ")",
                            n.moveTo(o.x, o.y)),
                            n.lineTo(o.x, o.y);
                        n.stroke()
                    } else
                        i.log("You need Safari or Firefox 1.5+ to see this demo.")
            }
            ,
            i.Pattern.prototype.drawShape3d = function() {
                if (0 === this.stitches.length)
                    return null;
                var t, e, r = 1, n = [], o = {
                    color: this.colors[this.stitches[0].color],
                    points: []
                };
                for (this.invertPatternVertical(),
                this.moveToCenter(),
                this.RemoveUnderlayment(r),
                n.push(o),
                t = 0; t < this.stitches.length - 1; t += 1)
                    e = this.stitches[t],
                    e.flags !== i.stitchTypes.jump && e.flags !== i.stitchTypes.trim && e.flags !== i.stitchTypes.stop || (o = {
                        color: this.colors[e.color],
                        points: []
                    },
                    n.push(o),
                    o.points.push({
                        x: e.x,
                        y: e.y,
                        z: 0
                    })),
                    o.points.push({
                        x: e.x,
                        y: e.y,
                        z: e.z
                    });
                return n
            }
            ,
            i.Pattern.prototype.RemoveUnderlayment = function(n) {
                var o, a, s, h, c, l, u, p, d;
                for (this.stitches[0].z = n,
                o = 1; o < this.stitches.length; o += 1) {
                    for (s = this.stitches[o - 1],
                    h = this.stitches[o],
                    h.z = n,
                    a = 1; a < o - 1; a += 1)
                        c = e(s, h, this.stitches[a - 1], this.stitches[a]),
                        c.b && (h.crossed || (h.crossed = []),
                        l = new i.Stitch(c.x,c.y,h.flags,h.color),
                        u = t(this.stitches[a], this.stitches[a - 1]),
                        0 !== u && (p = t(this.stitches[a - 1], c) / u * (this.stitches[a].z - this.stitches[a - 1].z) + 2 * n + this.stitches[a - 1].z,
                        l.z = p,
                        l.distance = t(l, h),
                        h.crossed.push(l)));
                    if (h.crossed) {
                        for (h.crossed.sort(r),
                        d = h.z,
                        a = 0; a < h.crossed.length; a += 1)
                            d < h.crossed[a].z && (this.stitches.splice(o, 0, h.crossed[a]),
                            d = h.crossed[a].z,
                            o += 1);
                        h.crossed = null
                    }
                }
                for (o = 1; o < this.stitches.length; o += 1)
                    s = this.stitches[o - 1],
                    h = this.stitches[o],
                    (Math.abs(s.x - h.x) > 128 || Math.abs(s.y - h.y) > 128) && (this.stitches[o].flags = i.stitchTypes.trim)
            }
            ,
            i.Pattern.prototype.scale = function(t) {
                var e;
                for (e = 0; e < this.stitches.length; e += 1)
                    this.stitches[e].x *= t,
                    this.stitches[e].y *= t;
                this.left *= t,
                this.top *= t,
                this.right *= t,
                this.bottom *= t
            }
            ,
            i
        }
    }
    , {}],
    15: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t) {
                return t > 128 ? -(255 & ~t) - 1 : t
            }
            function r(t, e, r, i) {
                i === n.stitchTypes.trim ? (t[0] = 128,
                t[1] = 2,
                t[2] = e,
                t[3] = r) : i === n.stitchTypes.stop ? (t[0] = 128,
                t[1] = 1,
                t[2] = e,
                t[3] = r) : (t[0] = e,
                t[1] = r)
            }
            function i(t) {
                return t < 0 ? Math.ceil(t - .5) : Math.floor(t + .5)
            }
            var n = t("./embroidery.js")()
              , o = {
                extension: ".exp",
                canRead: !0,
                canWrite: !0
            };
            return o.read = function(t, r) {
                for (var i, o, a, s, h, c = 0, l = t.byteLength; c < l; )
                    h = n.stitchTypes.normal,
                    i = t.getInt8(c),
                    c += 1,
                    o = t.getInt8(c),
                    c += 1,
                    i === -128 && (1 & o ? (i = t.getInt8(c),
                    c += 1,
                    o = t.getInt8(c),
                    c += 1,
                    h = n.stitchTypes.stop) : 2 === o || 4 === o ? (i = t.getInt8(c),
                    c += 1,
                    o = t.getInt8(c),
                    c += 1,
                    h = n.stitchTypes.trim) : o === -128 && (i = t.getInt8(c),
                    c += 1,
                    o = t.getInt8(c),
                    c += 1,
                    i = 0,
                    o = 0,
                    h = n.stitchTypes.trim)),
                    a = e(i),
                    s = e(o),
                    r.addStitchRel(a, s, h, !0);
                r.addStitchRel(0, 0, n.stitchTypes.end),
                r.invertPatternVertical()
            }
            ,
            o.write = function(t) {
                var e, n, o, a, s, h = 0, c = 0, l = [0, 0, 0, 0], u = new jDataView(1e5);
                for (a = 0; a < t.stitches.length; a += 1)
                    s = t.stitches[a],
                    e = 10 * s.x - h,
                    n = 10 * s.y - c,
                    h = 10 * s.x,
                    c = 10 * s.y,
                    o = s.flags,
                    r(l, i(e), i(n), o),
                    128 !== l[0] || 1 !== l[1] && 2 !== l[1] && 4 !== l[1] ? (u.writeUint8(l[0]),
                    u.writeUint8(l[1])) : (u.writeUint8(l[0]),
                    u.writeUint8(l[1]),
                    u.writeUint8(l[2]),
                    u.writeUint8(l[3]));
                return u.writeUint8(26),
                {
                    success: !0,
                    file: u,
                    message: ""
                }
            }
            ,
            o
        }
    }
    , {
        "./embroidery.js": 14
    }],
    16: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t) {
                var e = 0;
                return 243 === t ? r.stitchTypes.end : 195 === (195 & t) ? r.stitchTypes.trim | r.stitchTypes.stop : (128 & t && (e |= r.stitchTypes.trim),
                64 & t && (e |= r.stitchTypes.stop),
                e)
            }
            var r = t("./embroidery.js")()
              , i = {
                extension: ".exy",
                canRead: !0,
                canWrite: !1
            };
            return i.read = function(t, i) {
                var n, o, a, s = !1, h = !1, c = [], l = t.byteLength;
                for (t.seek(256); t.tell() < l - 3; )
                    c[0] = t.getUint8(),
                    c[1] = t.getUint8(),
                    c[2] = t.getUint8(),
                    o = 0,
                    a = 0,
                    1 & c[0] && (o += 1),
                    2 & c[0] && (o -= 1),
                    4 & c[0] && (o += 9),
                    8 & c[0] && (o -= 9),
                    128 & c[0] && (a += 1),
                    64 & c[0] && (a -= 1),
                    32 & c[0] && (a += 9),
                    16 & c[0] && (a -= 9),
                    1 & c[1] && (o += 3),
                    2 & c[1] && (o -= 3),
                    4 & c[1] && (o += 27),
                    8 & c[1] && (o -= 27),
                    128 & c[1] && (a += 3),
                    64 & c[1] && (a -= 3),
                    32 & c[1] && (a += 27),
                    16 & c[1] && (a -= 27),
                    4 & c[2] && (o += 81),
                    8 & c[2] && (o -= 81),
                    32 & c[2] && (a += 81),
                    16 & c[2] && (a -= 81),
                    n = e(c[2]),
                    h = n & r.stitchTypes.jump,
                    s && (n |= r.stitchTypes.jump),
                    i.addStitchRel(o, a, n, !0),
                    s = h;
                i.addStitchRel(0, 0, r.stitchTypes.end, !0),
                i.invertPatternVertical()
            }
            ,
            i
        }
    }
    , {
        "./embroidery.js": 14
    }],
    17: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t) {
                return t >= 128 ? -(255 & ~t) - 1 : t
            }
            var r = t("./embroidery.js")()
              , i = {
                extension: ".jef",
                canRead: !0,
                canWrite: !1
            }
              , n = r.Color
              , o = [new n(0,0,0,"Black"), new n(0,0,0,"Black"), new n(255,255,255,"White"), new n(255,255,23,"Yellow"), new n(250,160,96,"Orange"), new n(92,118,73,"Olive Green"), new n(64,192,48,"Green"), new n(101,194,200,"Sky"), new n(172,128,190,"Purple"), new n(245,188,203,"Pink"), new n(255,0,0,"Red"), new n(192,128,0,"Brown"), new n(0,0,240,"Blue"), new n(228,195,93,"Gold"), new n(165,42,42,"Dark Brown"), new n(213,176,212,"Pale Violet"), new n(252,242,148,"Pale Yellow"), new n(240,208,192,"Pale Pink"), new n(255,192,0,"Peach"), new n(201,164,128,"Beige"), new n(155,61,75,"Wine Red"), new n(160,184,204,"Pale Sky"), new n(127,194,28,"Yellow Green"), new n(185,185,185,"Silver Grey"), new n(160,160,160,"Grey"), new n(152,214,189,"Pale Aqua"), new n(184,240,240,"Baby Blue"), new n(54,139,160,"Powder Blue"), new n(79,131,171,"Bright Blue"), new n(56,106,145,"Slate Blue"), new n(0,32,107,"Nave Blue"), new n(229,197,202,"Salmon Pink"), new n(249,103,107,"Coral"), new n(227,49,31,"Burnt Orange"), new n(226,161,136,"Cinnamon"), new n(181,148,116,"Umber"), new n(228,207,153,"Blonde"), new n(225,203,0,"Sunflower"), new n(225,173,212,"Orchid Pink"), new n(195,0,126,"Peony Purple"), new n(128,0,75,"Burgundy"), new n(160,96,176,"Royal Purple"), new n(192,64,32,"Cardinal Red"), new n(202,224,192,"Opal Green"), new n(137,152,86,"Moss Green"), new n(0,170,0,"Meadow Green"), new n(33,138,33,"Dark Green"), new n(93,174,148,"Aquamarine"), new n(76,191,143,"Emerald Green"), new n(0,119,114,"Peacock Green"), new n(112,112,112,"Dark Grey"), new n(242,255,255,"Ivory White"), new n(177,88,24,"Hazel"), new n(203,138,7,"Toast"), new n(247,146,123,"Salmon"), new n(152,105,45,"Cocoa Brown"), new n(162,113,72,"Sienna"), new n(123,85,74,"Sepia"), new n(79,57,70,"Dark Sepia"), new n(82,58,151,"Violet Blue"), new n(0,0,160,"Blue Ink"), new n(0,150,222,"Solar Blue"), new n(178,221,83,"Green Dust"), new n(250,143,187,"Crimson"), new n(222,100,158,"Floral Pink"), new n(181,80,102,"Wine"), new n(94,87,71,"Olive Drab"), new n(76,136,31,"Meadow"), new n(228,220,121,"Mustard"), new n(203,138,26,"Yellow Ochre"), new n(198,170,66,"Old Gold"), new n(236,176,44,"Honeydew"), new n(248,128,64,"Tangerine"), new n(255,229,5,"Canary Yellow"), new n(250,122,122,"Vermillion"), new n(107,224,0,"Bright Green"), new n(56,108,174,"Ocean Blue"), new n(227,196,180,"Beige Grey"), new n(227,172,129,"Bamboo")];
            return i.colors = o,
            i.read = function(t, i) {
                var n, a, s, h, c, l, u, p, d = 0;
                for (t.seek(24),
                u = t.getInt32(t.tell(), !0),
                p = t.getInt32(t.tell(), !0),
                t.seek(t.tell() + 84),
                l = 0; l < u; l += 1)
                    i.addColor(o[t.getUint32(t.tell(), !0) % 78]);
                for (l = 0; l < 6 - u; l += 1)
                    t.getUint32();
                for (; d < p + 100; ) {
                    if (n = r.stitchTypes.normal,
                    a = t.getUint8(),
                    s = t.getUint8(),
                    128 === a)
                        if (1 & s)
                            a = t.getUint8(),
                            s = t.getUint8(),
                            n = r.stitchTypes.stop;
                        else if (2 === s || 4 === s)
                            a = t.getUint8(),
                            s = t.getUint8(),
                            n = r.stitchTypes.trim;
                        else if (16 === s) {
                            i.addStitchRel(0, 0, r.stitchTypes.end, !0);
                            break
                        }
                    h = e(a),
                    c = e(s),
                    i.addStitchRel(h, c, n, !0),
                    d += 1
                }
                return i.invertPatternVertical(),
                !0
            }
            ,
            i
        }
    }
    , {
        "./embroidery.js": 14
    }],
    18: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t, e, r) {
                var i = t + (e << 8) + (r << 16);
                return i > 8388607 ? -((8388607 & ~i) - 1) : i
            }
            function r(t) {
                return t < 0 ? Math.ceil(t - .5) : Math.floor(t + .5)
            }
            function i(t, e, r, i) {
                var o = 0;
                t.writeUint8(0),
                t.writeUint8(255 & e),
                t.writeUint8(e >> 8 & 255),
                t.writeUint8(e >> 16 & 255),
                t.writeUint8(0),
                t.writeUint8(255 & r),
                t.writeUint8(r >> 8 & 255),
                t.writeUint8(r >> 16 & 255),
                i & n.stitchTypes.stop && (o |= 1,
                o |= 2),
                i & n.stitchTypes.trim && (o |= 4),
                t.writeUint8(o)
            }
            var n = t("./embroidery.js")()
              , o = {
                extension: ".pcs",
                canRead: !0,
                canWrite: !0
            };
            return o.read = function(t, r) {
                var i, o, a, s, h, c, l = [], u = 0, p = 0, d = 0, f = 0;
                if (!r)
                    return {
                        success: !1,
                        file: null,
                        message: "pattern argument null"
                    };
                switch (r.metadata = {},
                r.metadata.version = t.getUint8(),
                h = t.getUint8()) {
                case 2:
                    r.hoop.width = 80,
                    r.hoop.height = 80;
                    break;
                case 3:
                    r.hoop.width = 115,
                    r.hoop.height = 120
                }
                for (c = t.getUint16(t.tell(), !0),
                i = 0; i < c; i += 1)
                    o = t.getUint8(),
                    a = t.getUint8(),
                    s = t.getUint8(),
                    r.addColor(new n.Color(o,a,s,"")),
                    t.getUint8();
                for (f = t.getUint16(t.tell(), !0),
                i = 0; i < f; i += 1)
                    d = n.stitchTypes.normal,
                    l = t.getBytes(9),
                    1 === (1 & l[8]) ? d = n.stitchTypes.stop : 4 === (4 & l[8]) && (d = n.stitchTypes.trim),
                    u = e(l[1], l[2], l[3]),
                    p = e(l[5], l[6], l[7]),
                    0 === u && 0 === p ? r.addStitchRel(u, p, d, !0) : r.addStitchAbs(u, p, d, !0);
                return r.addStitchRel(0, 0, n.stitchTypes.end, !0),
                r.invertPatternVertical(),
                !0
            }
            ,
            o.write = function(t) {
                var e, n, o, a, s;
                if (!t)
                    return {
                        success: !1,
                        file: null,
                        message: "pattern argument is null"
                    };
                if (t.colors.length > 16)
                    return {
                        success: !1,
                        file: null,
                        message: "Error PCS does not support greater that 16 colors"
                    };
                for (t.invertPatternVertical(),
                s = new jDataView(1e5),
                s.writeUint8("2".charCodeAt(0)),
                s.writeUint8(3),
                n = t.colors.length,
                s.writeUint16(16, !0),
                e = 0; e < n; e += 1)
                    o = t.colors[e],
                    s.writeUint8(o.r),
                    s.writeUint8(o.g),
                    s.writeUint8(o.b),
                    s.writeUint8(0);
                for (e = n; e < 16; e += 1)
                    s.writeUint32(0);
                for (s.writeUint16(t.stitches.length, !0),
                e = 0; e < t.stitches.length; e += 1)
                    a = t.stitches[e],
                    i(s, r(a.x), r(a.y), a.flags);
                return {
                    success: !0,
                    file: s,
                    message: ""
                }
            }
            ,
            o
        }
    }
    , {
        "./embroidery.js": 14
    }],
    19: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t, e, r) {
                var i = 2047 & Math.abs(e)
                  , n = 128;
                r & c.stitchTypes.trim ? n |= 32 : r & c.stitchTypes.jump && (n |= 16),
                e < 0 && (i = e + 4096 & 2047,
                i |= 2048),
                t.writeUint8(i >> 8 & 15 | n),
                t.writeUint8(255 & i)
            }
            function r(t, e) {
                t.writeUint8(254),
                t.writeUint8(176),
                t.writeUint8(e)
            }
            function i(t) {
                return t < 0 ? Math.ceil(t - .5) : Math.floor(t + .5)
            }
            function n(t, n) {
                var o, a, s, h, l = 0, u = 0, p = 2;
                for (o = 0; o < n.stitches.length; o += 1)
                    if (a = n.stitches[o],
                    s = i(a.x - l),
                    h = i(a.y - u),
                    l += s,
                    u += h,
                    a.flags & c.stitchTypes.stop)
                        r(t, p),
                        p = 2 === p ? 1 : 2;
                    else {
                        if (a.flags & c.stitchTypes.end) {
                            t.writeUint8(255);
                            break
                        }
                        s < 63 && s > -64 && h < 63 && h > -64 && !(a.flags & (c.stitchTypes.jump | c.stitchTypes.trim)) ? (t.writeUint8(s < 0 ? s + 128 : s),
                        t.writeUint8(h < 0 ? h + 128 : h)) : (e(t, s, a.flags),
                        e(t, h, a.flags))
                    }
            }
            function o(t, e) {
                var r, i;
                if (!t)
                    return void c.log("writeImage(), file argument is null");
                for (r = 0; r < 38; r += 1)
                    for (i = 0; i < 6; i += 1) {
                        var n = 8 * i
                          , o = 0;
                        0 !== e[r][n] && (o |= 1),
                        0 !== e[r][n + 1] && (o |= 2),
                        0 !== e[r][n + 2] && (o |= 4),
                        0 !== e[r][n + 3] && (o |= 8),
                        0 !== e[r][n + 4] && (o |= 16),
                        0 !== e[r][n + 5] && (o |= 32),
                        0 !== e[r][n + 6] && (o |= 64),
                        0 !== e[r][n + 7] && (o |= 128),
                        t.writeUint8(o)
                    }
            }
            function a(t) {
                var e, r;
                for (e = 0; e < 38; e += 1)
                    for (r = 0; r < 48; r += 1)
                        t[e][r] = 0
            }
            function s(t, e) {
                var r, i = new Array(t);
                for (r = 0; r < i.length; r += 1)
                    i[r] = new Array(e);
                return i
            }
            function h(t, e, r) {
                var h, u, p, d, f, m, g, v, y, x, b = new s(38,48);
                for (e.writeString("LA:"),
                p = 0; p < Math.min(r.length, 16); p += 1)
                    e.writeUint8(r.charCodeAt(p));
                for (p = 0; p < 16 - r.length; p += 1)
                    e.writeUint8(32);
                for (e.writeUint8(13),
                p = 0; p < 12; p += 1)
                    e.writeUint8(32);
                for (e.writeUint8(255),
                e.writeUint8(0),
                e.writeUint8(6),
                e.writeUint8(38),
                p = 0; p < 12; p += 1)
                    e.writeUint8(32);
                for (d = t.colors.length,
                e.writeUint8(d - 1),
                p = 0; p < d; p += 1)
                    e.writeUint8(t.colors[p].findNearestColorIndex(l.pecColors));
                for (p = 0; p < 463 - d; p += 1)
                    e.writeUint8(32);
                e.writeUint8(0),
                e.writeUint8(0),
                f = e.tell(),
                e.writeUint8(0),
                e.writeUint8(0),
                e.writeUint8(0),
                e.writeUint8(49),
                e.writeUint8(255),
                e.writeUint8(240),
                t.calculateBoundingBox(),
                g = i(t.height()),
                v = i(t.width()),
                e.writeUint16(v, !0),
                e.writeUint16(g, !0),
                e.writeUint16(480, !0),
                e.writeUint16(432, !0),
                e.writeUint16(36864 | -i(t.left), !1),
                e.writeUint16(36864 | -i(t.top), !1),
                n(e, t),
                m = e.tell() - f + 2;
                var w = e.tell();
                for (e.seek(f),
                e.writeUint8(255 & m),
                e.writeUint8(m >> 8 & 255),
                e.writeUint8(m >> 16 & 255),
                e.seek(w),
                a(b),
                x = 32 / g,
                y = 42 / v,
                p = 0; p < t.stitches.length; p += 1) {
                    var _ = t.stitches[p];
                    h = i((_.x - t.left) * y) + 3,
                    u = i((_.y - t.top) * x) + 3,
                    b[u][h] = 1
                }
                for (o(e, b),
                p = 0; p < t.stitches.length; p += 1) {
                    for (a(b); p < t.stitches.length; ) {
                        var M = t.stitches[p];
                        if (h = i((M.x - t.left) * y) + 3,
                        u = i((M.y - t.top) * x) + 3,
                        M.flags & c.stitchTypes.stop) {
                            p += 1;
                            break
                        }
                        b[u][h] = 1,
                        p += 1
                    }
                    o(e, b)
                }
            }
            var c = t("./embroidery.js")()
              , l = t("./pesformat.js")()
              , u = t("jdataview")
              , p = {
                extension: ".pec",
                canRead: !0,
                canWrite: !0
            };
            return p.read = function(t, e) {
                var r, i;
                for (t.seek(56),
                r = t.getUint8(),
                i = 0; i <= r; i += 1)
                    e.addColor(l.pecColors[t.getUint8() % 65]);
                return t.seek(540),
                l.readPecStitches(t, e),
                !0
            }
            ,
            p.write = function(t, e) {
                var r, i = new u(1e5);
                return 0 === t.stitches.length ? (c.log("pattern contains no stitches\n"),
                0) : (t.stitches[t.stitches.length - 1].flags !== c.stitchTypes.end && t.addStitchRel(t, 0, 0, c.stitchTypes.end, !0),
                r = t.getInvertedPattern(),
                r.fixColorCount(),
                i.writeString("#PEC0001"),
                h(r, i, e),
                {
                    success: !0,
                    file: i,
                    message: ""
                })
            }
            ,
            p
        }
    }
    , {
        "./embroidery.js": 14,
        "./pesformat.js": 20,
        jdataview: 6
    }],
    20: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            var e = t("./embroidery.js")()
              , r = {
                extension: ".pes",
                canRead: !0,
                canWrite: !1
            }
              , i = e.Color
              , n = [new i(0,0,0,"Unknown"), new i(14,31,124,"Prussian Blue"), new i(10,85,163,"Blue"), new i(0,135,119,"Teal Green"), new i(75,107,175,"Cornflower Blue"), new i(237,23,31,"Red"), new i(209,92,0,"Reddish Brown"), new i(145,54,151,"Magenta"), new i(228,154,203,"Light Lilac"), new i(145,95,172,"Lilac"), new i(158,214,125,"Mint Green"), new i(232,169,0,"Deep Gold"), new i(254,186,53,"Orange"), new i(255,255,0,"Yellow"), new i(112,188,31,"Lime Green"), new i(186,152,0,"Brass"), new i(168,168,168,"Silver"), new i(125,111,0,"Russet Brown"), new i(255,255,179,"Cream Brown"), new i(79,85,86,"Pewter"), new i(0,0,0,"Black"), new i(11,61,145,"Ultramarine"), new i(119,1,118,"Royal Purple"), new i(41,49,51,"Dark Gray"), new i(42,19,1,"Dark Brown"), new i(246,74,138,"Deep Rose"), new i(178,118,36,"Light Brown"), new i(252,187,197,"Salmon Pink"), new i(254,55,15,"Vermillion"), new i(240,240,240,"White"), new i(106,28,138,"Violet"), new i(168,221,196,"Seacrest"), new i(37,132,187,"Sky Blue"), new i(254,179,67,"Pumpkin"), new i(255,243,107,"Cream Yellow"), new i(208,166,96,"Khaki"), new i(209,84,0,"Clay Brown"), new i(102,186,73,"Leaf Green"), new i(19,74,70,"Peacock Blue"), new i(135,135,135,"Gray"), new i(216,204,198,"Warm Gray"), new i(67,86,7,"Dark Olive"), new i(253,217,222,"Flesh Pink"), new i(249,147,188,"Pink"), new i(0,56,34,"Deep Green"), new i(178,175,212,"Lavender"), new i(104,106,176,"Wisteria Violet"), new i(239,227,185,"Beige"), new i(247,56,102,"Carmine"), new i(181,75,100,"Amber Red"), new i(19,43,26,"Olive Green"), new i(199,1,86,"Dark Fuschia"), new i(254,158,50,"Tangerine"), new i(168,222,235,"Light Blue"), new i(0,103,62,"Emerald Green"), new i(78,41,144,"Purple"), new i(47,126,32,"Moss Green"), new i(255,204,204,"Flesh Pink"), new i(255,217,17,"Harvest Gold"), new i(9,91,166,"Electric Blue"), new i(240,249,112,"Lemon Yellow"), new i(227,243,91,"Fresh Green"), new i(255,153,0,"Orange"), new i(255,240,141,"Cream Yellow"), new i(255,200,200,"Applique")];
            return r.pecColors = n,
            r.readPecStitches = function(t, r) {
                for (var i, n, o, a = 0, s = e.stitchTypes, h = t.byteLength; t.tell() < h; ) {
                    if (n = t.getUint8(),
                    o = t.getUint8(),
                    i = s.normal,
                    255 === n && 0 === o) {
                        r.addStitchRel(0, 0, s.end, !0);
                        break
                    }
                    254 === n && 176 === o ? (t.getInt8(),
                    r.addStitchRel(0, 0, s.stop, !0),
                    a += 1) : (128 & n ? (32 & n && (i = s.trim),
                    16 & n && (i = s.jump),
                    n = ((15 & n) << 8) + o,
                    2048 & n && (n -= 4096),
                    o = t.getUint8()) : n >= 64 && (n -= 128),
                    128 & o ? (32 & o && (i = s.trim),
                    16 & o && (i = s.jump),
                    o = ((15 & o) << 8) + t.getUint8(),
                    2048 & o && (o -= 4096)) : o > 63 && (o -= 128),
                    r.addStitchRel(n, o, i, !0),
                    a += 1)
                }
            }
            ,
            r.read = function(t, r) {
                var i, o, a = t.getInt32(8, !0);
                for (t.seek(a + 48),
                o = t.getInt8() + 1,
                i = 0; i < o; i += 1)
                    r.addColor(n[t.getInt8()]);
                t.seek(a + 532),
                this.readPecStitches(t, r),
                r.addStitchRel(0, 0, e.stitchTypes.end)
            }
            ,
            r
        }
    }
    , {
        "./embroidery.js": 14
    }],
    21: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t) {
                return t >= 128 ? -(255 & ~t) - 1 : t
            }
            var r = t("./embroidery.js")()
              , i = t("./jefformat.js")()
              , n = {
                extension: ".sew",
                canRead: !0,
                canWrite: !1
            };
            return n.read = function(t, n) {
                var o, a, s, h, c, l, u, p = 0, d = i.colors, f = t.byteLength, m = t.getInt16(t.tell(), !0);
                for (o = 0; o < m; o += 1)
                    u = t.getInt16(t.tell(), !0) % 76,
                    n.addColor(d[u]);
                for (t.seek(7544),
                o = 0; t.tell() < f; o += 1) {
                    if (c = t.getUint8(),
                    l = t.getUint8(),
                    h = r.stitchTypes.normal,
                    p && (h = r.stitchTypes.trim,
                    p = 0),
                    128 === c)
                        if (1 === l)
                            c = t.getUint8(),
                            l = t.getUint8(),
                            h = r.stitchTypes.stop;
                        else if (2 === l || 4 === l)
                            p = 1,
                            c = t.getUint8(),
                            l = t.getUint8(),
                            h = r.stitchTypes.trim;
                        else if (16 === l)
                            break;
                    a = e(c),
                    s = e(l),
                    127 !== Math.abs(a) && 127 !== Math.abs(s) || (p = 1,
                    h = r.stitchTypes.trim),
                    n.addStitchRel(a, s, h, !0)
                }
                return n.addStitchRel(0, 0, r.stitchTypes.end, !0),
                n.invertPatternVertical(),
                !0
            }
            ,
            n
        }
    }
    , {
        "./embroidery.js": 14,
        "./jefformat.js": 17
    }],
    22: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t) {
                var e = t.getInt16();
                return t.getString(e)
            }
            function r(t) {
                return t > 128 ? -(~t + 1 & 255) : t
            }
            function i(t) {
                return (65535 & t) >= 32768 ? -(~t + 1 & 65535) : t
            }
            function n(t) {
                return {
                    right: t.getInt32(),
                    bottom: t.getInt32(),
                    left: t.getInt32(),
                    top: t.getInt32(),
                    unknown1: t.getInt32(),
                    unknown2: t.getInt32(),
                    unknown3: t.getInt32(),
                    numberOfBytesRemaining: t.getInt32(),
                    xOffset: t.getInt32(),
                    yOffset: t.getInt32(),
                    byte1: t.getUint8(),
                    byte2: t.getUint8(),
                    byte3: t.getUint8(),
                    right2: t.getInt32(),
                    left2: t.getInt32(),
                    bottom2: t.getInt32(),
                    top2: t.getInt32(),
                    width: t.getInt32(),
                    height: t.getInt32()
                }
            }
            var o = t("./embroidery.js")()
              , a = {
                extension: ".vp3",
                canRead: !0,
                canWrite: !1
            };
            return a.read = function(t, a) {
                var s, h, c, l, u, p, d, f, m, g, v, y, x, b, w, _, M, S, E, T, A, L, C, R, P, U = 0, I = 0, D = 0, O = 0, N = o.stitchTypes;
                for (s = t.getBytes(5),
                h = t.getUint8(),
                U = e(t),
                p = t.getInt16(),
                d = t.getUint8(),
                f = t.getInt32(),
                D = e(t),
                m = t.tell(),
                n(t),
                O = e(t),
                t.seek(t.tell() + 18),
                u = t.getBytes(6),
                I = e(t),
                c = t.getInt16(),
                l = t.tell(),
                g = 0; g < c; g += 1) {
                    for (t.seek(3 + l),
                    l = t.getInt32(),
                    l += t.tell(),
                    w = t.getInt32(),
                    _ = t.getInt32(),
                    b = t.getUint8(),
                    t.getUint8(),
                    v = t.getUint8(),
                    y = t.getUint8(),
                    x = t.getUint8(),
                    a.addColor(new o.Color(v,x,y,"")),
                    t.seek(t.tell() + 6 * b - 1),
                    E = e(t),
                    T = e(t),
                    A = e(t),
                    M = t.getInt32(),
                    S = t.getInt32(),
                    L = t.getInt16(),
                    t.seek(t.tell() + L),
                    C = t.getInt32(),
                    t.seek(t.tell() + 3); t.tell() < l - 1; )
                        if (R = r(t.getUint8()),
                        P = r(t.getUint8()),
                        128 === R)
                            switch (P) {
                            case 0:
                            case 3:
                                break;
                            case 1:
                                R = i(t.getInt16()),
                                P = i(t.getInt16()),
                                t.getInt16(),
                                a.addStitchRel(R, P, N.trim, !0)
                            }
                        else
                            a.addStitchRel(R, P, N.normal, !0);
                    g + 1 < c && a.addStitchRel(0, 0, N.stop, !0)
                }
                return a.addStitchRel(0, 0, N.end, !0),
                !0
            }
            ,
            a
        }
    }
    , {
        "./embroidery.js": 14
    }],
    23: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            function e(t) {
                return t >= 128 && t > 128 ? -(~t + 1 & 255) : t
            }
            var r = t("./embroidery.js")()
              , i = {
                extension: ".xxx",
                canRead: !0,
                canWrite: !1
            };
            return i.read = function(t, i) {
                var n, o, a, s, h, c, l, u, p, d = 0, f = 0, m = 0, g = 0, v = 0, y = 0;
                if (!i)
                    return {
                        success: !1,
                        file: null,
                        message: "pattern argument is null"
                    };
                for (t.seek(39),
                s = t.getInt16(t.tell(), !0),
                t.seek(252),
                h = t.getInt32(t.tell(), !0),
                t.seek(h + 6),
                c = 0; c < s; c += 1)
                    t.getUint8(),
                    l = t.getUint8(),
                    u = t.getUint8(),
                    p = t.getUint8(),
                    i.addColor(new r.Color(l,u,p,""));
                for (t.seek(256),
                c = 0; !m && t.tell() < h; c += 1) {
                    if (a = r.stitchTypes.normal,
                    g && (a = r.stitchTypes.trim),
                    g = 0,
                    n = t.getUint8(),
                    o = t.getUint8(),
                    126 === n || 125 === n)
                        d = o + (t.getUint8() << 8),
                        0 !== (32768 & d) && (d = -~(65535 & d) - 1),
                        f = t.getInt16(),
                        a = r.stitchTypes.trim;
                    else if (127 === n) {
                        if (23 !== o && 70 !== o && o >= 8)
                            n = 0,
                            o = 0,
                            g = 1,
                            a = r.stitchTypes.stop;
                        else {
                            if (1 !== o)
                                continue;
                            a = r.stitchTypes.trim,
                            n = t.getUint8(),
                            o = t.getUint8()
                        }
                        d = e(n),
                        f = e(o)
                    } else
                        d = e(n),
                        f = e(o);
                    i.addStitchRel(d, f, a, !0)
                }
                if (v = i.stitchList,
                y = !1,
                v) {
                    for (; null !== v.next; )
                        y = v,
                        v = v.next;
                    !i.stitchList && v.stitch.flags === r.stitchTypes.stop && y && (v = 0,
                    y.next = null,
                    i.changeColor(i, i.currentColorIndex - 1))
                }
                return i.addStitchRel(0, 0, r.stitchTypes.end, !0),
                i.invertPatternVertical(),
                !0
            }
            ,
            i
        }
    }
    , {
        "./embroidery.js": 14
    }],
    24: [function(t, e, r) {
        e.exports = function() {
            "use strict";
            var e = t("./embroidery.js")()
              , r = {
                extension: ".zsk",
                canRead: !0,
                canWrite: !1
            };
            return r.read = function(t, r) {
                var i, n, o, a, s = [], h = 0, c = t.byteLength, l = e.Color;
                for (t.seek(560),
                h = t.getUint8(); 0 !== h; )
                    i = t.getUint8(),
                    n = t.getUint8(),
                    o = t.getUint8(),
                    r.addColor(new l(i,n,o,"")),
                    t.seek(t.tell() + 72),
                    h = t.getUint8();
                for (t.seek(t.tell() + 46); t.tell() < c - 3; ) {
                    if (s[0] = t.getUint8(),
                    s[1] = t.getUint8(),
                    s[2] = t.getUint8(),
                    a = e.stitchTypes.normal,
                    4 & s[0] && (s[2] = -s[2]),
                    8 & s[0] && (s[1] = -s[1]),
                    2 & s[0] && (a = e.stitchTypes.jump),
                    32 & s[0]) {
                        if (2 === s[1])
                            a = e.stitchTypes.trim;
                        else {
                            if (s[1] === -1)
                                break;
                            0 !== s[2] && (h = s[2]),
                            a = e.stitchTypes.stop,
                            r.changeColor(h - 1)
                        }
                        s[1] = 0,
                        s[2] = 0
                    }
                    r.addStitchRel(s[1] / 10, s[2] / 10, a, !0)
                }
                return r.addStitchRel(0, 0, e.stitchTypes.end, !0),
                r.invertPatternVertical(),
                !0
            }
            ,
            r
        }
    }
    , {
        "./embroidery.js": 14
    }]
}, {}, [10]);
